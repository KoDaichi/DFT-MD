<!DOCTYPE html>
<html class="writer-html5" lang="ja">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>9. 原子ダイナミクス &mdash; PHASE/0 Manual 2024.01 ドキュメント</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../_static/css/phase0.css?v=84baaed2" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js?v=df52f328"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=4825356b"></script>
        <script src="../_static/translations.js?v=4dbe4bdc"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="next" title="10. 誘電応答解析機能 UVSOR" href="../uvsor/uvsor.html" />
    <link rel="prev" title="8. 解析機能" href="../analysis/analysis.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            PHASE/0 Manual
              <img src="../_static/image1.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction/introduction.html">1. はじめに</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install/install.html">2. PHASE/0のインストール</a></li>
<li class="toctree-l1"><a class="reference internal" href="../first_step/first_step.html">3. PHASE/0の基本的な利用方法</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input_parameters/input_parameters.html">4. 入力パラメータファイル：nfinp.data（詳細版）</a></li>
<li class="toctree-l1"><a class="reference internal" href="../basics/basics.html">5. 基本機能を利用した計算例</a></li>
<li class="toctree-l1"><a class="reference internal" href="../electronic_structure/electronic_structure.html">6. 電子状態解析：バンド構造と状態密度</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced_electronic_structure/advanced_electronic_structure.html">7. 高度な電子状態計算</a></li>
<li class="toctree-l1"><a class="reference internal" href="../analysis/analysis.html">8. 解析機能</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">9. 原子ダイナミクス</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#section-phonon">9.1. 振動解析</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id3">9.1.1. 機能の概要</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">9.1.2. 入力パラメータ</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">9.1.3. 計算結果の出力</a></li>
<li class="toctree-l3"><a class="reference internal" href="#advanced-phonon-partial">9.1.4. 一部の原子のみ振動解析の対象とする方法（バージョン2020.01以降）</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">9.1.5. 原子間力をファイルから読み込む方法（バージョン2020.01以降）</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id8">9.1.6. 計算例：水分子の振動解析</a></li>
<li class="toctree-l3"><a class="reference internal" href="#si2">9.1.7. 計算例：シリコン結晶(Si2)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id9">9.1.7.1. 入力パラメータ</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id10">9.1.7.2. 振動数レベル図</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id11">9.1.7.3. 振動モードの可視化</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id12">9.1.8. 計算例：銅 (100)面に吸着したエチレン分子の振動解析</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id13">9.2. フォノンバンド計算</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id14">9.2.1. 機能の概要</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id16">9.2.2. 利用方法</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id17">9.2.2.1. 基本的な入力パラメータ</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id18">9.2.2.2. 計算の実行</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id19">9.2.2.3. 出力ファイル</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id20">9.2.3. 例題</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id21">9.2.3.1. シリコン結晶</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id22">9.2.3.2. ヨウ化カリウム</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id23">9.2.3.3. スズの温度誘起相転移</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#project-phonon-band-to-atoms-section">9.2.4. フォノンバンドの原子群への射影（バージョン2022.01以降）</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id25">9.2.4.1. 入力ファイル</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id26">9.2.4.2. 可視化スクリプト</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id27">9.2.4.3. 例題</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#project-phonon-band-to-surface-bz-section">9.2.5. バルクのフォノンバンドの表面ブリルアンゾーンへの射影（バージョン2022.01以降）</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id29">9.2.5.1. 入力</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id30">9.2.5.2. 可視化スクリプト</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id31">9.2.5.3. 例題</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#phonon-band-unfolding-section">9.2.6. フォノンバンドアンフォールディング (バージョン2024.01以降)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id34">9.2.6.1. 入力ファイル</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id35">9.2.6.2. 出力ファイル</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id36">9.2.6.3. 可視化スクリプト</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id37">9.2.6.4. 例題</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id38">9.2.7. 使用上の注意</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#section-unitcell-optimization">9.3. ストレステンソルを利用したユニットセル最適化機能</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id40">9.3.1. 入力パラメータ</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id41">9.3.2. バージョン2019.01未満の場合の注意点</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id42">9.3.3. ストレステンソル補正（バージョン2019.01以降）</a></li>
<li class="toctree-l3"><a class="reference internal" href="#advanced-latopt-reuse-wfchg-section">9.3.4. 電荷密度および波動関数の再利用（バージョン2019.02以降）</a></li>
<li class="toctree-l3"><a class="reference internal" href="#advanced-latopt-sametime">9.3.5. 格子と原子座標を同時に最適化する方法（バージョン2023.01以降）</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id45">9.3.6. 計算結果の出力</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tio2">9.3.7. 計算例：ルチル型TiO<sub>2</sub> (ストレス補正なし)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tio2-2019-01">9.3.8. 計算例：ルチル型TiO<sub>2</sub> (ストレス補正あり、バージョン2019.01以降)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tio2-2023-01">9.3.9. 計算例：ルチル型TiO<sub>2</sub> (ストレス補正あり、原子座標と格子同時最適化、バージョン2023.01以降)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#section-molecular-dynamics">9.4. 分子動力学法シミュレーション</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id47">9.4.1. 機能の概要</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id48">9.4.2. 入力パラメータ</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id49">9.4.3. 計算結果の出力</a></li>
<li class="toctree-l3"><a class="reference internal" href="#advanced-nvemd-section">9.4.4. 使用方法：エネルギー一定の分子動力学シミュレーション</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id51">9.4.4.1. 手法の選択</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id52">9.4.4.2. 計算結果の例</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#advanced-nvtmd-section">9.4.5. 使用方法：温度一定の分子動力学シミュレーション</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id54">9.4.5.1. 熱浴の設定</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id55">9.4.5.2. 熱浴の割り当て</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id56">9.4.5.3. 熱浴の“段数”の設定 (バージョン2019.01以降)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id58">9.4.5.4. “温度プロファイル”の設定 (バージョン2019.01以降)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-md-langevin">9.4.5.5. ランジュバン熱浴の設定(バージョン2021.02以降)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#section-npt-md">9.4.6. 使用方法：温度・圧力一定の分子動力学シミュレーション</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id63">9.4.6.1. 入力パラメーターファイルの書き方</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id64">9.4.6.2. 計算結果</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id65">9.4.7. 分子動力学シミュレーションにまつわるその他の設定</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id66">9.4.7.1. 速度スケーリングによる温度制御の分子動力学シミュレーション</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id67">9.4.7.2. 全運動量がゼロになるよう速度をシフトする方法</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id68">9.4.7.3. 原子の初期速度を手動で指定する方法</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id69">9.4.7.4. 原子を領域に閉じ込める方法 (バージョン2019.01以降)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-ion-dynamics-fix-bond">9.4.7.5. 水素との結合を凍結する方法 (バージョン2022.01以降)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id71">9.4.8. 使用における注意点</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#neb">9.5. NEB 法</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id73">9.5.1. 機能の概要</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id76">9.5.2. 入力パラメータ</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id77">9.5.2.1. 概要</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id78">9.5.2.2. NEB機能を有効にする</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id79">9.5.2.3. 収束判定</a></li>
<li class="toctree-l4"><a class="reference internal" href="#neb-symmetry">9.5.2.4. 結晶の対称性指定について</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id81">9.5.2.5. 両端のレプリカの指定：入力で直接指定する方法</a></li>
<li class="toctree-l4"><a class="reference internal" href="#advanced-neb-endpoint-from-dynm">9.5.2.6. 両端のレプリカの指定：両端のレプリカの原子座標をファイルから指定する方法 (バージョン2020.01以降)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#advanced-neb-legacy-endpoint-from-file">9.5.2.7. 両端のレプリカの指定：両端のレプリカの原子座標をファイルから指定する方法 (2019.02以前)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#proportional">9.5.2.8. 中間レプリカの指定：中間レプリカの原子座標を両端の原子座標の線形補間で指定する方法(proportional)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#file">9.5.2.9. 中間レプリカの指定：中間レプリカの原子座標をファイルから指定する方法(file)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id84">9.5.2.10. NEB関連ファイルの指定</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#advanced-neb-from-2020">9.5.3. 入力パラメーター指定（バージョン2020.01以降）</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id86">9.5.3.1. NEB法の精度などの設定</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nfdynm-data">9.5.3.2. 始状態・終状態としてnfdynm.dataファイルを利用する方法</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ci-neb">9.5.3.3. CI-NEBの切り替え</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id87">9.5.3.4. nfdynm.dataファイルを反応経路に見立てて初期レプリカ列にする方法</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id88">9.5.3.5. 始状態と終状態のエネルギーを指定する方法</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id89">9.5.4. 計算の実行方法</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id90">9.5.5. 計算結果の出力</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id92">9.5.6. 計算例：シリコン表面に水素分子が解離吸着する反応</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id93">9.5.6.1. 入力ファイル</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id94">9.5.6.2. 計算結果</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id95">9.5.7. バージョン2020.01以降の機能を活用した計算例</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id96">9.5.7.1. 問題</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id97">9.5.7.2. 入力ファイル</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id99">9.5.7.3. 計算結果</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id100">9.5.8. 使用における注意点</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dimer">9.6. Dimer 法</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id102">9.6.1. 機能の概要</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id104">9.6.2. 入力パラメータ</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id105">9.6.3. 計算の実行方法</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id106">9.6.4. 出力ファイル</a></li>
<li class="toctree-l3"><a class="reference internal" href="#si">9.6.5. 計算例1: Si上の水素分子解離</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pt">9.6.6. 計算例2: Ptにおける酸素原子の拡散</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id107">9.6.7. 制限事項</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#blue-moon">9.7. 拘束条件付きダイナミクスとBlue Moon 法による自由エネルギー解析</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id108">9.7.1. 機能の概要</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id109">9.7.2. 入力パラメータ</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id110">9.7.2.1. タグ一覧</a></li>
<li class="toctree-l4"><a class="reference internal" href="#driver">9.7.2.2. driver変数の設定</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id111">9.7.2.3. 拘束条件の設定</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id112">9.7.2.4. ダイナミクスのアルゴリズムの指定</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id113">9.7.2.5. 反応座標を変化させる指定</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id114">9.7.3. 計算の実行方法</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id115">9.7.4. 計算結果の出力</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id116">9.7.5. Blue Moon法による自由エネルギーの計算</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id117">9.7.5.1. 機能の概要</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bluemoon">9.7.5.2. bluemoonプログラムのコンパイル</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id119">9.7.5.3. bluemoonプログラムの入力パラメータ</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id120">9.7.5.4. bluemoonプログラムの実行方法</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id121">9.7.5.5. 計算結果の出力</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#h2o2h2s2">9.7.6. 計算例：H<sub>2</sub>O<sub>2</sub>およびH<sub>2</sub>S<sub>2</sub>分子の回転障壁の解析</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id123">9.7.7. 使用における注意点</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#meta-dynamics">9.8. Meta-dynamics 法</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id124">9.8.1. 機能の概要</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id128">9.8.2. 入力パラメータ</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id129">9.8.3. 計算の実行方法</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id130">9.8.4. 計算結果の出力</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id131">9.8.5. 計算例：炭化水素のエネルギー表面</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id132">9.8.5.1. 概要</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id133">9.8.5.2. 入力パラメータ</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id134">9.8.5.3. 計算結果</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id135">9.8.6. 使用における注意点</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#section-constant-chemical-potential">9.9. 化学ポテンシャル一定のシミュレーション</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id137">9.9.1. 概要</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id139">9.9.2. 入力パラメーター</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id140">9.9.3. 計算の実行</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id141">9.9.4. 例題</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id142">9.9.5. 使用上の注意</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#section-rigid-body-dynamics">9.10. 剛体ダイナミクス (バージョン2022.01以降)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id144">9.10.1. 概要</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id145">9.10.2. 使い方</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id146">9.10.2.1. 入力</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id147">9.10.2.2. 出力</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id148">9.10.3. 計算例</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#section-neural-network-potential">9.11. 機械学習によるニューラルネットワークポテンシャルの作成 (バージョン2021.01以降)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id150">9.11.1. 概要</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id155">9.11.2. 使い方</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id156">9.11.2.1. 教師データの作成</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id157">9.11.2.2. サンプル時の収束判定条件の切り替え</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id158">9.11.2.3. 教師データの形式</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id159">9.11.3. ニューラルネットワークポテンシャル作成例</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id160">9.11.3.1. 用いた結晶</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id161">9.11.3.2. 第一原理計算</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id162">9.11.3.3. ニューラルネットワークポテンシャルの作成の準備</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id167">9.11.3.4. 教師データの変換</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id169">9.11.3.5. ニューラルネットワークポテンシャルの学習</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id170">9.11.3.6. ニューラルネットワークポテンシャルの検証</a></li>
<li class="toctree-l4"><a class="reference internal" href="#aenetlammps">9.11.3.7. ænetインターフェースを組み込んだLAMMPSの使い方</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pimd-2022-01">9.12. PIMDコードを用いた経路積分分子動力学シミュレーション (バージョン2022.01以降)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id171">9.12.1. 概要</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id175">9.12.2. ビルド方法</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id176">9.12.3. 使い方</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id177">9.12.4. 計算例</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id178">9.12.5. 注意事項</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../uvsor/uvsor.html">10. 誘電応答解析機能 UVSOR</a></li>
<li class="toctree-l1"><a class="reference internal" href="../supplement/supplement.html">11. 補遺</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">PHASE/0 Manual</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active"><span class="section-number">9. </span>原子ダイナミクス</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/ion_dynamics/ion_dynamics.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="ion-dynamics-chapter">
<span id="id1"></span><h1><span class="section-number">9. </span>原子ダイナミクス<a class="headerlink" href="#ion-dynamics-chapter" title="この見出しへのパーマリンク"></a></h1>
<section id="section-phonon">
<span id="id2"></span><h2><span class="section-number">9.1. </span>振動解析<a class="headerlink" href="#section-phonon" title="この見出しへのパーマリンク"></a></h2>
<section id="id3">
<h3><span class="section-number">9.1.1. </span>機能の概要<a class="headerlink" href="#id3" title="この見出しへのパーマリンク"></a></h3>
<p>PHASEには格子振動の基準モードを計算する振動解析機能があります。まず、原子を平衡位置からわずかに変位させて力計算を行います。その力から力定数行列を計算し、それから動力学行列を計算します。動力学行列の固有値問題を解くことにより、基準振動の振動数と固有ベクトルを計算します。</p>
<p><span class="math notranslate nohighlight">\(i\)</span>番目の原子の安定位置から変位を<span class="math notranslate nohighlight">\(\mathbf{u}_{i}\)</span>とします。
変位が微小で二次以上の項が無視できるとき、格子系の運動方程式は</p>
<div class="math notranslate nohighlight" id="equation-advanced-phonon-gamma-eq1">
<span class="eqno">(9.1)<a class="headerlink" href="#equation-advanced-phonon-gamma-eq1" title="この数式へのパーマリンク"></a></span>\[m_{i}{\ddot{u}}_{\text{iα}} = - \sum_{\text{jβ}}^{}\Phi_{i\alpha,j\beta}u_{\text{jβ}}\]</div>
<p>と書けます。<span class="math notranslate nohighlight">\(\Phi_{i\alpha,j\beta}\)</span>は力の定数で、原子変位に関する系のエネルギー<span class="math notranslate nohighlight">\(E(\mathbf{u}_{1},\mathbf{u}_{2},\ldots)\)</span>の二階微分として定義されています。</p>
<div class="math notranslate nohighlight" id="equation-advanced-phonon-gamma-eq2">
<span class="eqno">(9.2)<a class="headerlink" href="#equation-advanced-phonon-gamma-eq2" title="この数式へのパーマリンク"></a></span>\[\Phi_{i\alpha,j\beta} = \frac{\partial^{2}E}{\partial u_{\text{iα}}\partial u_{\text{jβ}}}\]</div>
<p>力の定数はヘルマン-ファインマン力を原子変位で微分することにより、 求めることができます。</p>
<div class="math notranslate nohighlight" id="equation-advanced-phonon-gamma-eq3">
<span class="eqno">(9.3)<a class="headerlink" href="#equation-advanced-phonon-gamma-eq3" title="この数式へのパーマリンク"></a></span>\[\Phi_{i\alpha,j\beta} = - \frac{\partial F_{\text{iα}}}{\partial u_{\text{jβ}}}\]</div>
<p>本プログラムでは、この微分は中央差分近似で行われます。変位パラメターを<span class="math notranslate nohighlight">\(a\)</span>とすると</p>
<div class="math notranslate nohighlight" id="equation-advanced-phonon-gamma-eq4">
<span class="eqno">(9.4)<a class="headerlink" href="#equation-advanced-phonon-gamma-eq4" title="この数式へのパーマリンク"></a></span>\[\frac{\partial F_{\text{iα}}}{\partial u_{\text{jβ}}} = \frac{F_{\text{iα}}|_{u_{\text{jβ}} = a} - F_{\text{iα}}|_{u_{\text{jβ}} = - a}}{2a}\]</div>
<p>と書けます。
力の定数には結晶の対称性による制約があり、これを満たすように力の定数を補正する必要があります。第一に、<span class="math notranslate nohighlight">\(i,j\)</span>原子が空間群の対称操作<span class="math notranslate nohighlight">\(\{ R|\mathbf{T}\}\)</span>で<span class="math notranslate nohighlight">\(i^{'},j^{'}\)</span>原子に移るとき、力定数テンソル<span class="math notranslate nohighlight">\(\Phi_{i,j}\)</span>は力定数テンソル<span class="math notranslate nohighlight">\(\Phi_{i^{'},j^{'}}\)</span>を回転行列Rで回転させたものに等しいです。つまり、</p>
<div class="math notranslate nohighlight">
\[R\mathbf{r}_{i} + \mathbf{T} = \mathbf{r}_{i^{'}}\]</div>
<div class="math notranslate nohighlight" id="equation-advanced-phonon-gamma-eq5">
<span class="eqno">(9.5)<a class="headerlink" href="#equation-advanced-phonon-gamma-eq5" title="この数式へのパーマリンク"></a></span>\[R\mathbf{r}_{j} + \mathbf{T} = \mathbf{r}_{j^{'}}\]</div>
<p>ならば、</p>
<div class="math notranslate nohighlight" id="equation-advanced-phonon-gamma-eq6">
<span class="eqno">(9.6)<a class="headerlink" href="#equation-advanced-phonon-gamma-eq6" title="この数式へのパーマリンク"></a></span>\[\Phi_{i,j} = R^{T}\Phi_{i^{'},j^{'}}R\]</div>
<p>でなければなりません。
第二に、力定数テンソル<span class="math notranslate nohighlight">\(\Phi_{i,j}\)</span>の成分<span class="math notranslate nohighlight">\(\text{αβ}\)</span>を原子の番号<span class="math notranslate nohighlight">\(j\)</span>すべてにわたり足し合わせると、ゼロになります。つまり、</p>
<div class="math notranslate nohighlight" id="equation-advanced-phonon-gamma-eq7">
<span class="eqno">(9.7)<a class="headerlink" href="#equation-advanced-phonon-gamma-eq7" title="この数式へのパーマリンク"></a></span>\[\sum_{j}^{}\Phi_{i\alpha,j\beta} = 0\]</div>
<p>です。 第三に、力定数行列は対称でなければなりません。つまり、</p>
<div class="math notranslate nohighlight" id="equation-advanced-phonon-gamma-eq8">
<span class="eqno">(9.8)<a class="headerlink" href="#equation-advanced-phonon-gamma-eq8" title="この数式へのパーマリンク"></a></span>\[\Phi_{i\alpha,j\beta} = \Phi_{j\beta,i\alpha}\]</div>
<p>です。 換算変位<span class="math notranslate nohighlight">\(w_{\text{iα}} = u_{\text{iα}}\sqrt{m_{i}}\)</span>と
動力学行列<span class="math notranslate nohighlight">\(D_{i\alpha,j\beta} = \Phi_{i\alpha,j\beta}/\sqrt{m_{i}m_{j}}\)</span>を用いて、
格子系の運動方程式 <a class="reference internal" href="#equation-advanced-phonon-gamma-eq1">(9.1)</a> を</p>
<div class="math notranslate nohighlight" id="equation-advanced-phonon-gamma-eq9">
<span class="eqno">(9.9)<a class="headerlink" href="#equation-advanced-phonon-gamma-eq9" title="この数式へのパーマリンク"></a></span>\[{\ddot{w}}_{\text{iα}} = - \sum_{\text{jβ}}^{}D_{i\alpha,j\beta}w_{\text{jβ}}\]</div>
<p>と書き換えます。この方程式を解くために、
<span class="math notranslate nohighlight">\(w_{\text{iα}} = Q\xi_{\text{iα}}e^{i\omega t + \delta}\)</span>
という解を仮定します。</p>
<div class="math notranslate nohighlight" id="equation-advanced-phonon-gamma-eq10">
<span class="eqno">(9.10)<a class="headerlink" href="#equation-advanced-phonon-gamma-eq10" title="この数式へのパーマリンク"></a></span>\[\omega^{2}\xi_{\text{iα}} = \sum_{\text{jβ}}^{}D_{i\alpha,j\beta}\xi_{\text{jβ}}\]</div>
<p>これは固有値が<span class="math notranslate nohighlight">\(\omega^{2}\)</span>で、固有ベクトルが<span class="math notranslate nohighlight">\(\xi_{\text{iα}}\)</span>となる、
行列<span class="math notranslate nohighlight">\(D_{i\alpha,j\beta}\)</span>の固有値問題です。振動解析機能ではこの固有値問題を解き、格子振動の基準モードを求めます。</p>
</section>
<section id="id4">
<h3><span class="section-number">9.1.2. </span>入力パラメータ<a class="headerlink" href="#id4" title="この見出しへのパーマリンク"></a></h3>
<p>振動解析を行うには、まず原子が平衡位置にあることが必要です。平衡状態にないと動力学行列の固有値が負になり、振動数が純虚数のソフトモードが現れます。平衡位置の原子座標は、構造最適化機能を用いて計算します。構造最適化計算が終了したら、nfdynm.dataの最後に記述されている最適構造での入力パラメータファイルを作成します。</p>
<p>振動解析の設定は、Phononブロックで指定します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Phonon{
   sw_phonon = on
   sw_calc_force = on
   sw_vibrational_modes = on
   displacement = 0.05
}
</pre></div>
</div>
<p>振動解析の入力変数を以下に示します。</p>
<p>振動解析に関係する変数の説明</p>
<table class="longtable docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>変数名またはタグ名</p></th>
<th class="head"><p>デフォルト値</p></th>
<th class="head"><p>説明</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>sw_phonon</p></td>
<td><p>OFF</p></td>
<td><p>格子振動解析を有効にする
かどうかのスイッチです。</p></td>
</tr>
<tr class="row-odd"><td><p>sw_calc_force</p></td>
<td><p>OFF</p></td>
<td><p>振動解析のための力計算を行う
かどうかのスイッチです。</p>
<p>ON：格子振動解析のための力計算を行い
ます。(計算した力はforc
e.dataに出力されます。）</p>
<p>OFF：sw_vibrational_modes
=ONならファイル&quot;F_FORCE&quot;から力
のデータを読み込みます。</p>
</td>
</tr>
<tr class="row-even"><td><p>displacement</p></td>
<td><p>0.1</p></td>
<td><p>原子変位パラメーター。</p></td>
</tr>
<tr class="row-odd"><td><p>sw_vibrational_modes</p></td>
<td><p>OFF</p></td>
<td><p>格子振動解析を行うかどうかのスイッチです。</p>
<p>ON：格子振動解析が行われ、mode.dataファイ
ルに結果が出力されます。</p>
<p>OFF：格子振動解析は行われません。</p>
</td>
</tr>
<tr class="row-even"><td><p>norder</p></td>
<td><p>1</p></td>
<td><p>差分次数を変更するパラメターです。</p></td>
</tr>
<tr class="row-odd"><td><p>sw_polynomial_fit</p></td>
<td><p>OFF</p></td>
<td><p>ON：多項式フィットで力の微分を求めます。</p>
<p>OFF：差分で力の微分を求めます。</p>
</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><p>原子座標と対称性の入力</p></li>
</ul>
<p>原子座標は反転対称があってもすべて入力する必要があります。すなわち、原子座標のweight属性値による省略は利用できません。また、sw_inversionはOFFとする必要があります。振動モードの分類と入力座標の対称性チェックに系の空間群を使用するので、結晶構造またはその空間群をsymmetryブロックで正しく指定します。ただし、対称性自動判定機能を利用することも可能です。</p>
<ul class="simple">
<li><p>元素の質量の指定</p></li>
</ul>
<p>元素の質量はelement_listブロックの変数massで指定する。原子単位(a.u.)ではなく、原子質量単位(amu)で入力するには、#units
atomic_massを#tag行の上に挿入する。</p>
<ul class="simple">
<li><p>原子変位の選択</p></li>
</ul>
<p>原子変位はPhononブロックのdisplacementで設定します。通常、原子変位は0.1
a.u.以下にとると良いです。振動数の原子変位依存性を調べて、希望する振動数の収束が得られる原子変位に設定します。norderを2に設定することで、差分の次数を3から5に換えることができます。diplacementで設定した値をuとすれば、原子変位は-u,-u/2,u/2,uになります。sw_polynamial_fitをONにして多項式フィットにすれば、norderを2より大きく設定できます。そのときの原子変位は-u/norder,-u/(norder-1),...,u/(norder-1),u/norderです。norderを大きくすると微分精度はよくなりますが、力計算の回数が増えるので、計算時間はnorderが1の場合の2*norder倍になるので注意してください。</p>
</section>
<section id="id5">
<h3><span class="section-number">9.1.3. </span>計算結果の出力<a class="headerlink" href="#id5" title="この見出しへのパーマリンク"></a></h3>
<p>振動解析結果は、振動解析結果ファイルmode.data、力のデータforce.dataに出力されます。</p>
<p>mode.dataには振動解析の結果が記述されます。まず最初に基本並進ベクトル<span class="math notranslate nohighlight">\(\mathbf{a}_{i} = (a_{\text{ix}},a_{\text{iy}},a_{\text{iz}})\)</span>が次の形式で記述されます。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>--- primitive lattice vectors ---
  a_1x a_1y a_1z
  a_2x a_2y a_2z
  a_3x a_3y a_3z
</pre></div>
</div>
<p>次に原子の数natmと各原子の座標<span class="math notranslate nohighlight">\((x_{i},y_{i},z_{i})\)</span>と質量<span class="math notranslate nohighlight">\(m_{i}\)</span>とラベルname(i)が次の形式記述されます。</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="o">---</span><span class="w"> </span><span class="n">Equilibrium</span><span class="w"> </span><span class="n">position</span><span class="w"> </span><span class="nb">and </span><span class="n">mass</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">atom</span><span class="o">---</span>
<span class="w"> </span><span class="n">Natom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">natm</span>
<span class="w"> </span><span class="k">do </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">natm</span>
<span class="w">    </span><span class="n">i</span><span class="w">  </span><span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w">  </span><span class="n">y</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="n">z</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="n">name</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="w"> </span><span class="k">end do</span>
</pre></div>
</div>
<p>次に振動解析の結果が次の形式で記述されます。</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="o">---</span><span class="w"> </span><span class="n">Vibrational</span><span class="w"> </span><span class="n">modes</span><span class="w"> </span><span class="o">---</span>
<span class="w"> </span><span class="n">Nmode</span><span class="o">=</span><span class="w"> </span><span class="n">nmode</span><span class="p">;</span><span class="w"> </span><span class="n">Natom</span><span class="o">=</span><span class="w"> </span><span class="n">natm</span>
<span class="w"> </span><span class="k">do </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="n">nmode</span>
<span class="w">   </span><span class="n">n</span><span class="o">=</span><span class="w">   </span><span class="n">m</span><span class="w">  </span><span class="n">representation</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="n">acvtive</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="w">   </span><span class="n">hbarW</span><span class="o">=</span><span class="w"> </span><span class="n">omega_ha</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">om</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">omega_ev</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">nu</span><span class="o">=</span><span class="w"> </span><span class="n">omega_nu</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="w">   </span><span class="k">do </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">natm</span>
<span class="w">      </span><span class="n">i</span><span class="w">  </span><span class="n">vec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">vec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="n">vec</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="w">   </span><span class="k">end do</span>
<span class="k"> end do</span>
</pre></div>
</div>
<p>representationは既約表現の配列です。active(m)はラマン活性なモードあれば
Rになり、赤外活性なモードであればIRとなります。両活性であれば、IR&amp;Rとなります。
サイレントモードの場合には何も表示されません。
vecは固有ベクトルの配列で、omega_haはHartree単位での振動数で、
omega_evは電子ボルト単位での振動数で、omega_nuは波数です。</p>
<p>力データファイルforce.dataには力の定数を計算するための力のデータが記述されます。その力データは次の形式で出力されます。</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="n">num_force_data</span><span class="p">,</span><span class="w"> </span><span class="n">norder</span><span class="p">,</span><span class="w"> </span><span class="n">sw_ploynomial_fit</span>
<span class="k">do </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">num_force_data</span>
<span class="w">   </span><span class="n">displaced_atom</span><span class="p">,</span><span class="w"> </span><span class="n">displacement</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">)</span>
<span class="w">   </span><span class="k">do </span><span class="n">ia</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">natm</span>
<span class="w">      </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">force_data</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
<span class="w">   </span><span class="k">end do</span>
<span class="k">end do</span>
</pre></div>
</div>
<p>num_force_dataは力を計算する原子配置の数で、displaced_atomは変位した原子の番号で、配列displacementが原子の変位ベクトル<span class="math notranslate nohighlight">\((u_{x},u_{y},u_{z})\)</span>です。
norderは入力で指定したnorderの値が記述されます。sw_ploynomial_fitは入力のsw_ploynomial_fitがONのときに、ONを表す1が記述されます。OFFの場合には、0が記述されます。</p>
<p>sw_calc_forceをOFFに設定することで、出力された力を読み込み、振動解析をやり直すことができます。元素の質量を変更することは問題ありませんが、力計算に関連する変数は変更してはなりません。</p>
</section>
<section id="advanced-phonon-partial">
<span id="id6"></span><h3><span class="section-number">9.1.4. </span>一部の原子のみ振動解析の対象とする方法（バージョン2020.01以降）<a class="headerlink" href="#advanced-phonon-partial" title="この見出しへのパーマリンク"></a></h3>
<p>バージョン2020.01以降より、一部の原子のみを振動解析の対象とすることができるようになりました。本計算機能を用いると、たとえば表面に吸着した分子の振動解析を行う際分子と表面数層のみを考慮することによって必要な原子間力計算回数を減らすことが可能になります。</p>
<p>基本的には通常の振動解析と同様の設定を施せばこの計算機能を用いることができます。各原子のmobile属性値を、変位の対象にしたい場合onに、したくない場合offに設定します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>structure{
  atom_list{
    atoms{
      #default mobile = on
      #tag element rx ry rz weight mobile
        Cu 0 0 0 1 off
        Cu 0 0.250000000015 0.090375000005 1 off
        Cu 0.250000000015 0 0.090375000005 1 off
        Cu 0.250000000015 0.250000000015 0 1 off
        Cu -0.00133991609598 -6.13618712873e-06 0.183172868018 on
        Cu 0.00243063003687 0.247502210432 0.274544823036 on
        Cu 0.248598303756 0.999991722423 0.274874965184 on
        Cu 0.249918873555 0.250806431959 0.18373526966 on
        Cu 0 0.500000000029 0 1 off
        ...
        ...
    }
  }
}
</pre></div>
</div>
<p>通常mobile属性値のデフォルト値はoffですが、振動解析の場合はonがデフォルト値となります。<em>なお、mobile属性がoffの原子が存在する振動解析の場合は対称性を考慮しないようにしてください。</em></p>
</section>
<section id="id7">
<h3><span class="section-number">9.1.5. </span>原子間力をファイルから読み込む方法（バージョン2020.01以降）<a class="headerlink" href="#id7" title="この見出しへのパーマリンク"></a></h3>
<p>原子間力が計算済みの場合(force.dataファイルが存在し、原子間力データが記録されている場合)、計算開始前にファイルから読み込み、その原子間力の計算をスキップさせることが可能となりました（2020.01以降この動作が規定の振る舞い）あえて原子間力を新たに計算し直したい場合は、以下の設定を施します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>phonon{
  sw_read_force_pre = off
}
</pre></div>
</div>
<p>phononブロックの下のsw_read_force_preによって可能な場合はファイルから原子間力を読み込むかどうかを設定します。このパラメーターのデフォルト値はonなので、offとすることによってこの振る舞いを抑制し、原子間力を計算し直すことができます。</p>
</section>
<section id="id8">
<h3><span class="section-number">9.1.6. </span>計算例：水分子の振動解析<a class="headerlink" href="#id8" title="この見出しへのパーマリンク"></a></h3>
<p>水分子の振動解析例を紹介します。入力データは <code class="code docutils literal notranslate"><span class="pre">samples/phonon/H2O</span></code> 以下にあります。</p>
<p>構造最適化</p>
<p>振動解析を行うには原子が平衡状態になければなりませんので、振動解析を行うときと同じ条件で構造最適化を行います。平衡状態にないと動力学行列の固有値が負になり、振動数が純虚数のソフトモードが現れます。水分子の構造最適化の入力例を以下に示します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Control {
    condition = initial
    cpumax = 1 day ! maximum cpu time
    max_iteration = 6000
}

accuracy {
    cutoff_wf = 25.00 rydberg
    cutoff_cd = 225.00 rydberg
    num_bands = 8
    initial_wavefunctions = atomic_orbitals
    initial_charge_density = atomic_charge_density
    ksampling {
            method = gamma
    }
    scf_convergence {
            delta_total_energy = 1.e-10
            succession = 3
    }
    force_convergence {
            max_force = 1.e-4
    }
}

structure {
    unit_cell_type = primitive
    unit_cell {
            a_vector = 15.0 0.0 0.0
            b_vector = 0.0 15.0 0.0
            c_vector = 0.0 0.0 15.0
    }
    symmetry {
            tspace {
                    lattice_system = primitive
                    generators {
                    #tag rotation tx ty tz
                            C2z    0   0   0
                            IC2x   0   0   0
                    }
            }
            sw_inversion = off
    }

    magnetic_state = para

    atom_list {
            coordinate_system = cartesian
            atoms {
            #tag  rx             ry       rz          element
                    -1.442399231   0.000000000   1.126191510  H
                     1.442399231   0.000000000   1.126191510  H
                     0.000000000   0.000000000  -0.005814677  O
            }
    }
    element_list {
    #units atomic_mass
    #tag element  atomicnumber zeta  dev  mass
            H   1   1.00   0.5   1.00794
            O   8   0.17   1.0  15.9994 }
}

wavefunction_solver {
    solvers {
    #tag sol    till_n
            mddavidson   1
            rmm3        -1
    }
    rmm {
            edelta_change_to_rmm = 1.d-3
    }
}

charge_mixing {
    mixing_methods {
    #tag id method   rmxs
             1  pulay   0.4
    }
}

printoutlevel {
    base = 1
}
</pre></div>
</div>
<p>file_names.dataにはelement_listと同じ順番でポテンシャルファイルH_ggapbe_paw_nc_01m.ppとO_ggapbe_paw_us_02m.ppを指定します。この入力を使用して得た水分子の構造を <a class="reference internal" href="#advanced-phonon-fig1"><span class="std std-numref">図 9.1</span></a> に示します。</p>
<figure class="align-default" id="advanced-phonon-fig1">
<a class="reference internal image-reference" href="../_images/image82.svg"><img alt="../_images/image82.svg" src="../_images/image82.svg" width="150pt" /></a>
<figcaption>
<p><span class="caption-number">図 9.1 </span><span class="caption-text">水分子の構造</span><a class="headerlink" href="#advanced-phonon-fig1" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
<p>振動解析</p>
<p>構造最適化後に振動解析を行うには、入力の原子座標を最適化した座標に換えて、Phononブロックを加え、振動解析の設定をします。最適化原子座標は構造最適化計算の出力ファイルnfdynm.dataに記述されている最後のステップの原子座標です。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>atom_list{
     coordinate_system = cartesian
     atoms{
        !#tag  rx             ry       rz          element
              -1.446816228    0.000    1.123327795 H
               1.446816228    0.000    1.123327795 H
               0.0            0.0      0.0         O
     }
}
</pre></div>
</div>
<p>振動解析の設定はたとえば以下のようにします。原子変位は0.05とします。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Phonon{
   sw_phonon = on
   sw_calc_force = on
   sw_vibrational_modes = on
   displacement = 0.05
}
</pre></div>
</div>
<p>PHASEを実行します。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>%<span class="w"> </span>mpirun<span class="w">  </span>../../../bin/phase
</pre></div>
</div>
<p>PHASEを実行すると、振動解析結果のファイルmode.dataが出力されます。</p>
<p>振動数レベル図はツールfreq.plを使用して作成します。分子の場合には以下のように-molというオプションを付けてfreq.plを実行します。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>%<span class="w"> </span>freq.pl<span class="w"> </span>-mol<span class="w"> </span>mode.data
</pre></div>
</div>
<p>この例題の水分子の基準モードの振動数を <a class="reference internal" href="#advanced-phonon-fig2"><span class="std std-numref">図 9.2</span></a> に示します。</p>
<figure class="align-default" id="advanced-phonon-fig2">
<img alt="../_images/image83.svg" src="../_images/image83.svg" /><figcaption>
<p><span class="caption-number">図 9.2 </span><span class="caption-text">水分子の振動モードの振動数</span><a class="headerlink" href="#advanced-phonon-fig2" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
<p>基準振動の固有ベクトルの図を作成するための拡張trajectory形式のファイルは、ツールanimate.plで作成します。原点の移動を指定したファイルcontrol.inpを用意します。control.inpは以下のように記述します。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>origin<span class="w">  </span><span class="m">7</span>.5<span class="w"> </span><span class="m">7</span>.5<span class="w"> </span><span class="m">7</span>.5
</pre></div>
</div>
<p>ツールanimate.plを以下のように実行します。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>%<span class="w"> </span>animate.pl<span class="w"> </span>mode.data<span class="w"> </span>control.inp
</pre></div>
</div>
<p>基準振動の固有ベクトルの拡張trajectory形式のファイルmode_*.tr2が生成されます。</p>
<p>この例題の水分子の基準モードの固有ベクトルを <a class="reference internal" href="#advanced-phonon-fig3"><span class="std std-numref">図 9.3</span></a> に示します。生成された振動モードの拡張trajectory形式のファイルmode_7.tr2,mode_8.tr2,mode_9.tr2を可視化したものです。</p>
<figure class="align-default" id="advanced-phonon-fig3">
<img alt="../_images/image84.png" src="../_images/image84.png" />
<figcaption>
<p><span class="caption-number">図 9.3 </span><span class="caption-text">水分子の振動モードの固有ベクトル</span><a class="headerlink" href="#advanced-phonon-fig3" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
</section>
<section id="si2">
<h3><span class="section-number">9.1.7. </span>計算例：シリコン結晶(Si2)<a class="headerlink" href="#si2" title="この見出しへのパーマリンク"></a></h3>
<section id="id9">
<h4><span class="section-number">9.1.7.1. </span>入力パラメータ<a class="headerlink" href="#id9" title="この見出しへのパーマリンク"></a></h4>
<p>シリコン結晶の振動解析の例題です。計算例題は、 <code class="code docutils literal notranslate"><span class="pre">samples/phonon/Si2</span></code> です。</p>
<p>入力パラメータファイルnfinput.dataでは、element_listにシリコン原子の質量28.0855
amuが指定されています。質量の単位を原子質量単位とするため、#unitsの後にatomic_massを指定しています</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>element_list{     #units atomic_mass
　　　　　　　　　#tag element  atomicnumber mass
                             Si       14     28.0855
        }
</pre></div>
</div>
<p>振動解析のパラメータをPhononブロックで指定します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Phonon{
   sw_phonon = on
   sw_calc_force = on
   displacement = 0.1
   sw_vibrational_modes = on
}
</pre></div>
</div>
<p>sw_calc_forceとsw_vibrational_modesがともにONなので、振動解析のための力計算を行い、振動解析が行われます。</p>
<p>PHASEを実行します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>% mpirun  ../../../bin/phase
</pre></div>
</div>
<p>計算が終了すると、出力ファイルmode.dataに振動解析の結果が出力されます。mode.dataの最初の部分は以下のようになっています。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>--- primitive lattice vectors ---
  0.0000000000   5.0875600000   5.0875600000
  5.0875600000   0.0000000000   5.0875600000
  5.0875600000   5.0875600000   0.0000000000
--- Equilibrium position and mass of each atom---
Natom=    2
   1   1.2718900000   1.2718900000   1.2718900000    51196.42133 Si
   2  -1.2718900000  -1.2718900000  -1.2718900000    51196.42133 Si
--- Vibrational modes ---
Nmode=    6 Natom=    2
n=     1 T1u      hbarW =  0.00000000E+00 Ha =  0.00000000E+00 eV; nu=  0.00000000E+00 cm^-1
    1   0.0000000000  0.0000000000  0.7071067812
    2   0.0000000000  0.0000000000  0.7071067812
</pre></div>
</div>
<p>最初の二行目から三行目は基本並進ベクトルをあらわしています。六行目は原子数を表しています。その次の行からは、原子の番号、デカルト座標、質量、ラベルが一行にあらわされています。Vibrational
modesというタイトル行の次の行にはモード数と原子数があらわされています。これ以降には各振動モードの既約表現を先頭行として、次行に振動数があらわされ、その次の行から固有ベクトルがあらわされています。固有ベクトルは原子の番号の後にその原子に帰属するベクトルの３成分があらわされています。</p>
</section>
<section id="id10">
<h4><span class="section-number">9.1.7.2. </span>振動数レベル図<a class="headerlink" href="#id10" title="この見出しへのパーマリンク"></a></h4>
<p>振動解析の出力ファイルmode.dataの振動数のデータから振動数レベル図を作成します。
以下のように、ツールfreq.plを実行すると、Postscript形式の振動数レベル図freq.epsが出力されます。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>% freq.pl mode.data
</pre></div>
</div>
<p>シリコン結晶の振動解析の振動レベル図を <a class="reference internal" href="#advanced-phonon-fig4"><span class="std std-numref">図 9.4</span></a> に示します。この図から振動数が517 cm<sup>-1</sup>であるモードがあることが分かります。
このモードの既約表現はT<sub>2g</sub>であるので、同じ振動数のモードが三重に縮重しています。T<sub>2g</sub>モードがラマン活性である場合、図中の規約表現の右側にRが表示されます。赤外活性である場合にはIRと表示されます。</p>
<figure class="align-default" id="advanced-phonon-fig4">
<a class="reference internal image-reference" href="../_images/image85.svg"><img alt="../_images/image85.svg" src="../_images/image85.svg" width="300pt" /></a>
<figcaption>
<p><span class="caption-number">図 9.4 </span><span class="caption-text">バルクSiの領域中心フォノンモードの振動数</span><a class="headerlink" href="#advanced-phonon-fig4" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
</section>
<section id="id11">
<h4><span class="section-number">9.1.7.3. </span>振動モードの可視化<a class="headerlink" href="#id11" title="この見出しへのパーマリンク"></a></h4>
<p>振動解析の出力ファイルmode.dataから拡張Trajectory形式のファイルを作成することにより、固有ベクトルを矢印表示したり、原子が振動するアニメーションとして振動モードを可視化したりできます。ツールanimate.plを使用して、振動解析の出力ファイルmode.dataから振動数の情報を取り出し、拡張Trajectory形式のファイル(拡張子:tr2)を作成します。</p>
<p>原点の移動とセルベクトルの変更を指定したファイルcontrol.inpを用意します。control.inpは以下のように記述します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>origin  1.27189 1.27189 1.27189
vector1 10.17512 0 0
vector2 0 10.17512 0
vector3 0 0 10.17512
</pre></div>
</div>
<p>ツールanimate.plを以下のように実行すると、拡張Trajectory形式のファイルがモードの数だけ出力されます。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>% animate.pl mode.data control.inp
</pre></div>
</div>
<p>この例題では切り出すセルをブラベー格子の単位胞にとり、セルの原点にシリコン原子がくるように設定しています。
たとえば、出力された拡張Trajectory形式のファイルmode_6.tr2を可視化すると、 <a class="reference internal" href="#advanced-phonon-fig5"><span class="std std-numref">図 9.5</span></a> のように固有ベクトルが矢印で示されます。
<a class="reference internal" href="#advanced-phonon-fig5"><span class="std std-numref">図 9.5</span></a> に示されているセルは、出力されたgrid.mol2ファイルを読み込ことで表示できます。また、出力された拡張Trajectory形式から、原子の振動を可視化することができます。</p>
<figure class="align-default" id="advanced-phonon-fig5">
<a class="reference internal image-reference" href="../_images/image86.svg"><img alt="../_images/image86.svg" src="../_images/image86.svg" width="300pt" /></a>
<figcaption>
<p><span class="caption-number">図 9.5 </span><span class="caption-text">バルクSiの領域中心フォノンモードの固有ベクトル</span><a class="headerlink" href="#advanced-phonon-fig5" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
</section>
</section>
<section id="id12">
<h3><span class="section-number">9.1.8. </span>計算例：銅 (100)面に吸着したエチレン分子の振動解析<a class="headerlink" href="#id12" title="この見出しへのパーマリンク"></a></h3>
<p>Cu(100)面にエチレン分子を配置した系の振動解析を実施しました。サンプルデータは <code class="code docutils literal notranslate"><span class="pre">samples/phonon/Cu100_C2H4</span></code> の下にあります。まずはCu(100)面にエチレン分子を吸着させ、通常の構造最適化を実施しました。
結果得られた原子配置は <a class="reference internal" href="#advanced-phonon-fig6"><span class="std std-numref">図 9.6</span></a> に示す通り。</p>
<figure class="align-default" id="advanced-phonon-fig6">
<a class="reference internal image-reference" href="../_images/image87.jpeg"><img alt="../_images/image87.jpeg" src="../_images/image87.jpeg" style="width: 300pt;" /></a>
<figcaption>
<p><span class="caption-number">図 9.6 </span><span class="caption-text">Cu (100)面にC<sub>2</sub>H<sub>4</sub>分子を吸着させた系。</span><a class="headerlink" href="#advanced-phonon-fig6" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
<p>分子のみを考慮するケース(サンプルデータが置かれたディレクトリーはmolonly)、分子と表面第一層まで考慮するケース(サンプルデータが置かれたディレクトリーはph1)、分子と表面第二層まで考慮するケース(サンプルデータが置かれたディレクトリーはph2)、そしてすべての原子を考慮する(サンプルデータが置かれたディレクトリーはphall)振動解析を実施しました。比較のため、孤立分子の振動解析も行いました。得られた振動数の上位5つを
<a class="reference internal" href="#advanced-phonon-table1"><span class="std std-numref">表 9.1</span></a> に報告します。</p>
<table class="docutils align-default" id="advanced-phonon-table1">
<caption><span class="caption-number">表 9.1 </span><span class="caption-text">振動数top 5（単位：cm<sup>-1</sup>）</span><a class="headerlink" href="#advanced-phonon-table1" title="このテーブルへのパーマリンク"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>分子のみ</p></th>
<th class="head"><p>分子+1層</p></th>
<th class="head"><p>分子+2層</p></th>
<th class="head"><p>全原子</p></th>
<th class="head"><p>孤立分子</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>3041.4</p></td>
<td><p>3039.7</p></td>
<td><p>3039.4</p></td>
<td><p>3039.4</p></td>
<td><p>3057.8</p></td>
</tr>
<tr class="row-odd"><td><p>3014.0</p></td>
<td><p>3012.2</p></td>
<td><p>3012.0</p></td>
<td><p>3012.0</p></td>
<td><p>3028.5</p></td>
</tr>
<tr class="row-even"><td><p>2946.3</p></td>
<td><p>2944.3</p></td>
<td><p>2944.1</p></td>
<td><p>2944.1</p></td>
<td><p>2973.7</p></td>
</tr>
<tr class="row-odd"><td><p>2942.2</p></td>
<td><p>2940.1</p></td>
<td><p>2939.8</p></td>
<td><p>2939.8</p></td>
<td><p>2957.6</p></td>
</tr>
<tr class="row-even"><td><p>1475.9</p></td>
<td><p>1478.4</p></td>
<td><p>1478.7</p></td>
<td><p>1478.9</p></td>
<td><p>1618.1</p></td>
</tr>
</tbody>
</table>
<p>分子のみ考慮する場合ではやくも3
cm<sup>-1</sup>以下の精度で振動数が計算できていることが分かります。1層取り込むとこれが0.5
cm<sup>-1</sup>以下となり、ほぼ収束していると考えてよいでしょう。2層取り込んだ結果は最大でも0.2
cm<sup>-1</sup>の誤差となっており、これは同じ結果が得られているといってもよい精度です。</p>
</section>
</section>
<section id="id13">
<h2><span class="section-number">9.2. </span>フォノンバンド計算<a class="headerlink" href="#id13" title="この見出しへのパーマリンク"></a></h2>
<section id="id14">
<h3><span class="section-number">9.2.1. </span>機能の概要<a class="headerlink" href="#id14" title="この見出しへのパーマリンク"></a></h3>
<p>PHASEには、 <span class="math notranslate nohighlight">\(\Gamma\)</span> 点だけでなく一般の<strong>k</strong>点における格子振動解析を行い、フォノンの状態密度やバンド構造を計算する機能があります。
文献 <a class="reference internal" href="#parlinski97" id="id15"><span>[Parlinski97]</span></a> のアルゴリズムに従って計算します。</p>
</section>
<section id="id16">
<h3><span class="section-number">9.2.2. </span>利用方法<a class="headerlink" href="#id16" title="この見出しへのパーマリンク"></a></h3>
<section id="id17">
<h4><span class="section-number">9.2.2.1. </span>基本的な入力パラメータ<a class="headerlink" href="#id17" title="この見出しへのパーマリンク"></a></h4>
<p>この機能を利用するためには、 <span class="math notranslate nohighlight">\(\Gamma\)</span> 点の場合と同様phononブロックを作成し、設定を行います。典型的には、以下のようになります。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>phonon{
  sw_phonon = on
  sw_vibrational_modes = on
  sw_calc_force = on
  displacement = 0.1
  method = dos
  lattice{
    l1 = 2
    l2 = 2
    l3 = 2
  }
  dos{
    mesh{
      nx = 10
      ny = 10
      nz = 10
    }
  }
}
</pre></div>
</div>
<p>基本的な入力パラメーターを以下に示します。</p>
<table class="longtable docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>第1ブロック識別子</p></th>
<th class="head"><p>第2、第3ブロック識別子</p></th>
<th class="head"><p>タグ識別子</p></th>
<th class="head"><p>説明</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>phonon</p></td>
<td></td>
<td></td>
<td><p>フォノン計算の設定を行うためのブロック</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>sw_phonon</p></td>
<td><p>PHASEの</p>
<p>振動解析機能を
利用するかどうかを指定します。Γ点のみの場合と同様です。</p>
</td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>sw_vibrational_modes</p></td>
<td><p>振動解析を行うかどうかを指定します。Γ点のみの場合と同様です。</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>sw_calc_force</p></td>
<td><p>力定数の計算を行うかどうかを指定します。Γ点のみの場合と同様です。</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>displacement</p></td>
<td><p>力定数の計算を行う際に、原子をどの程度移動させるかを指定します。Γ点のみの場合と同様です。デフォルト値は0.1
bohrです。</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>method</p></td>
<td><p>“手法”を指定します。状態密度計算の場合はdos,
バンド構造計算の場合はband
を指定します。</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>lattice</p></td>
<td></td>
<td><p>一
般<strong>k</strong>点の振動解析は、スーパーセルの力定数を必要とします。そのスーパーセルの大きさを指定するブロックです。</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>nx</p></td>
<td><p><em>a</em>軸を何倍するかを指定します。</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>ny</p></td>
<td><p><em>b</em>軸を何倍するかを指定します。</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>nz</p></td>
<td><p><em>c</em>軸を何倍するかを指定します。</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>dos</p></td>
<td></td>
<td><p>状態密度の計算方法を指定するブロックです。</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>mesh</p></td>
<td></td>
<td><p>状態密度計算に利用する<em>k</em> 点のメッシュを指定するブロックです。</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>nx</p></td>
<td><p>1つめの逆格子ベクトルの分割数を指定します。</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>ny</p></td>
<td><p>2つめの逆格子ベクトルの分割数を指定します。</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>nz</p></td>
<td><p>3つめの逆格子ベクトルの分割数を指定します。</p></td>
</tr>
</tbody>
</table>
<p>methodをbandと設定すると、フォノンバンドの計算になります。バンド構造の計算は、電子バンド構造と同様band_kpoint.plを利用して計算する<em>k</em>点の情報が記録されたkpoint.dataファイルを作成したあとに実行します。</p>
<p>バンド数および<strong>k</strong>点分割数</p>
<p>フォノンバンド計算を行う場合、スーパーセルの作成が行われます。バンド数や<strong>k</strong>点分割数は、生成されたスーパーセルに合わせてPHASEが自動的に変更します。以下の注意が必要です。</p>
<ul class="simple">
<li><p>スーパーセルは、ブラベー格子に対して作成されます。通常のPHASE
による計算の場合unit cell type がBravais
の場合は基本格子に対して<strong>k</strong>
点を定義しますが、フォノンバンドの場合はブラベー格子に対して行うようにしてください。</p></li>
<li><p>バンド数は、定義した原子にしたがって通常の計算と同じように決定してください。</p></li>
</ul>
<p>イオン性結晶の場合の設定方法</p>
<p>イオン性結晶の場合、Γ点においてオプティカルモードの縦波と横波が異なった振動数を持ちます。この現象は、LO-TO
分裂と呼ばれます。この効果を取り入れる場合、入力ファイルにおいてさらに以下の指定を行う必要があります。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>phonon{
  sw_lo_to_splitting = on
  electronic_dielectric_constant{
    exx = 2.6
    eyy = 2.6
    ezz = 2.6
    exy = 0.0
    exz = 0.0
    eyz = 0.0
  }
}
</pre></div>
</div>
<p>変数sw_lo_to_splitting をon とすることによってLO-TO
分裂を考慮した計算を行うことができます。electronic_dielectric_constantブロックには、電子系の誘電テンソルを指定します。electronic_dielectric_constantブロックの下のexx,
eyy, ezz, exy, exz, eyz
に対応する誘電テンソルの成分を指定します。誘電テンソルは、実測値もしくはUVSOR-Epsilon
による計算値をご利用ください。原子の有効電荷も指定する必要があります。これは、作業ディレクトリーにeffchg.data
ファイルを作成し、以下のように指定します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>2
1
1.12 0.0 0.0
0.0 1.12 0.0
0.0 0.0 1.12
2
-1.12 0.0 0.0
0.0 -1.12 0.0
0.0 0.0 -1.12
</pre></div>
</div>
<p>ファイルの1 行目に原子数を記述します。2
行目以降に有効電荷の値を指定します。まず指定対象の原子のID
を指定し、さらに有効電荷テンソルを指定します。有効電荷テンソルは、形式電荷を利用することもできますが、</p>
<p>UVSOR-Berry によって得られたボルン有効電荷を利用することが望ましいです。</p>
</section>
<section id="id18">
<h4><span class="section-number">9.2.2.2. </span>計算の実行<a class="headerlink" href="#id18" title="この見出しへのパーマリンク"></a></h4>
<p>入力データが準備できたら、通常通りPHASE を実行します。まずは、PHASE
は入力の指定にしたがってスーパーセルを作成します。ログファイルには以下のように報告されます。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>natm_super,natm2_super= 64 64
ia,cps(3),pos(3),ityp
1 1.27189 1.27189 1.27189 0.06250 0.06250 0.06250 1
2 8.90323 8.90323 8.90323 0.43750 0.43750 0.43750 1
3 1.27189 6.35945 6.35945 0.06250 0.31250 0.31250 1
4 8.90323 13.99079 13.99079 0.43750 0.68750 0.68750 1
5 6.35945 1.27189 6.35945 0.31250 0.06250 0.31250 1
6 13.99079 8.90323 13.99079 0.68750 0.43750 0.68750 1
7 6.35945 6.35945 1.27189 0.31250 0.31250 0.06250 1
8 13.99079 13.99079 8.90323 0.68750 0.68750 0.43750 1
9 11.44701 1.27189 1.27189 0.56250 0.06250 0.06250 1
10 19.07835 8.90323 8.90323 0.93750 0.43750 0.43750 1
11 11.44701 6.35945 6.35945 0.56250 0.31250 0.31250 1
12 19.07835 13.99079 13.99079 0.93750 0.68750 0.68750 1
13 16.53457 1.27189 6.35945 0.81250 0.06250 0.31250 1
...
...
</pre></div>
</div>
<p>natm_super がスーパーセルの原子数です。cps は原子のカルテシアン座標、
pos はフラクショナル座標です。itypは原子の種類を識別する番号です。また,
スーパーセルに合わせて変化したバンド数と<strong>k</strong>点のメッシュが次のように報告されます。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>num_bands will be changed.
neg,meg= 192 192
k-point mesh will be changed.
mesh= 1 1 1
</pre></div>
</div>
<p>neg が新しいバンド数, mesh が新しい<strong>k</strong> 点メッシュです。</p>
</section>
<section id="id19">
<h4><span class="section-number">9.2.2.3. </span>出力ファイル<a class="headerlink" href="#id19" title="この見出しへのパーマリンク"></a></h4>
<p>mode.dataファイル</p>
<p>振動解析の結果はmode.data
ファイルに記録されます。フォノンバンドの場合のmode.dataファイルは、たとえば以下のようになります。Γ点の場合と比較して、振動モードの記述の仕方が異なります。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>--- Vibrational modes ---
Nmode= 6 Natom= 2 Nqvec 120
iq= 1 q=( 0.00000, 0.00000, 0.00000) ( 0.00000, 0.00000, 0.00000)
n= 1 T1u IR
hbarW= 0.00000000E+00 Ha = 0.00000000E+00 eV; nu= 0.00000000E+00 cm^-1
1 0.0000000000 0.7071067812 0.0000000000
2 0.0000000000 0.7071067812 0.0000000000
1 0.0000000000 0.0000000000 0.0000000000
2 0.0000000000 0.0000000000 0.0000000000
n= 2 T1u IR
...
iq= 2 q=( 0.01875, 0.01875, 0.03750) ( 0.02316, 0.02316, 0.00000)
n= 1 B2 IR&amp;R
hbarW= 0.63506708E-04 Ha = 0.17281054E-02 eV; nu= 0.13938112E+02 cm^-1
1 0.4999599615 -0.4999599615 0.0000000000
2 0.4999599615 -0.4999599615 0.0000000000
1 0.0063274755 -0.0063274755 0.0000000000
2 0.0063274755 -0.0063274755 0.0000000000
n= 2 B1 IR&amp;R
...
</pre></div>
</div>
<p>モードの数と原子数の後に、<strong>k</strong>点の数が示されます。各<strong>k</strong>
点の振動数モードの記述の前に, <strong>k</strong>
点の座標が部分座標とカルテシアン座標で示されます。振動モードの固有ベクトルは一般には複素数となるので,
固有ベクトルの実部の後に,
虚部が記述されます。なお、Γ点の場合と同様に振動の対称性および赤外ラマンの活性/不活性の判定が出力されますが、この情報はΓ点以外では意味がない点にご注意ください。</p>
<p>phdos.dataファイル</p>
<p>フォノンの状態密度はphdos.data
ファイルに出力されます。その内容は、典型的には下記のようなものです。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span># Index Omega(mHa) Omega(eV) Omega(cm-1) DOS(States/Ha) DOS(States/eV) DOS(States/cm-1) IntDOS(States)
0 -0.00050000 -0.00001361 -0.10973732 0.00000000  0.00000000 0.00000000 0.00000000
1  0.00950000  0.00025851  2.08500903 0.00473815  0.17412390 0.00002159 0.00001500
2  0.01950000  0.00053062  4.27975539 0.01996324  0.73363561 0.00009096 0.00012976
3  0.02950000  0.00080274  6.47450174 0.04568839  1.67901746 0.00020817 0.00044927
4  0.03950000  0.00107485  8.66924810 0.08191360  3.01026946 0.00037323 0.00107853
5  0.04950000  0.00134696 10.86399446 0.24722290  9.08527497 0.00112643 0.00286860
6  0.05950000  0.00161908 13.05874081 0.37130693 13.64527929 0.00169180 0.00591423
7  0.06950000  0.00189119 15.25348717 0.49343689 18.13347292 0.00224826 0.01020273
8  0.07950000  0.00216331 17.44823352 0.67844022 24.93222060 0.00309120 0.01602478
...................
...................
</pre></div>
</div>
<p>1 列目は状態密度のインデックス、2, 3, 4 列目がそれぞれmHa, eV, cm-1
単位のエネルギー、5, 6, 7 列目がそれぞれstates/Ha, states/eV, states/cm-1 単位での状態密度、8 列目が積算状態密度です。積算状態密度は、最も高エネルギーの状態においては原子数×3 になります。</p>
<p>解析用Perlスクリプト</p>
<p>フォノンバンド計算の結果解析用のPerl スクリプトがPHASE
には備わっています。以下の3 種類のPerl
スクリプトを利用して結果の解析を行うことができます。</p>
<p>phonon_dos.pl</p>
<p>フォノンの状態密度データから、「フォノン状態密度図」を作成するPerlスクリプトです。以下のように使用します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>% phonon_dos.pl phdos.data OPTIONS
</pre></div>
</div>
<p>phdos.data が、PHASE
が出力するフォノン状態密度データです。実行すると、phonon_dos.eps
というEPS形式の画像ファイルが作成されます。下記のオプションを利用することができます。</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>--units=UNITS or -u UNITS</p></td>
<td><p>エネルギーの単位を指定します。mHa,
meV, THz, cm-1のいずれかです。デフォルト値はcm-1です。</p></td>
</tr>
<tr class="row-even"><td><p>--width=WIDTH or -w WIDTH</p></td>
<td><p>作成される図の幅を指定します。デフォルト値は1です。</p></td>
</tr>
<tr class="row-odd"><td><p>--erange=[emin:emax] or -e
[emin:emax]</p></td>
<td><p>エネルギーの範囲を指定します。</p></td>
</tr>
<tr class="row-even"><td><p>--drange=DRANGE or -d DRANGE</p></td>
<td><p>状態密度の範囲を指定します。</p></td>
</tr>
<tr class="row-odd"><td><p>--title=TITLE or -t TITLE</p></td>
<td><p>図のタイトルを指定します。</p></td>
</tr>
<tr class="row-even"><td><p>--font=FONT or -f FONT</p></td>
<td><p>グラフに利用するフォントサイズを指定します。デフォルト値は18です。</p></td>
</tr>
<tr class="row-odd"><td><p>--keep or -k</p></td>
<td><p>中間のデータファイルを保持する場合、このオプションを有効にします。</p></td>
</tr>
<tr class="row-even"><td><p>--mono or -m</p></td>
<td><p>モノクログラフを描画したい場合にこのオプションを指定します。</p></td>
</tr>
<tr class="row-odd"><td><p>--dinc=DINC</p></td>
<td><p>状態密度の目盛を指定します。</p></td>
</tr>
<tr class="row-even"><td><p>--einc=EINC</p></td>
<td><p>エネルギーの目盛を指定します。</p></td>
</tr>
</tbody>
</table>
<p>phonon_band.pl</p>
<p>フォノンバンドのデータから「フォノンバンド図」を作成するPerl
スクリプトです。以下のように使用します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>% phonon_band.pl mode.data OPTIONS
</pre></div>
</div>
<p>mode.data
が、振動解析の結果が記録されたファイルです。実行すると、phonon_band.eps
というEPS
形式の画像ファイルが作成されます。オプションには、下記のようなものがあります。</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>--control=CONTROL or -c
CONTROL</p></td>
<td><p>band_kpoint.plファイルの入力ファイルを指定します。デフォルト値はbandkpt.inです。</p></td>
</tr>
<tr class="row-even"><td><p>--ptype=PTYPE or -p PTYPE</p></td>
<td><p>グラフ描画に利用するプロット種を指定します。lineを指定すると実線、circleを指定すると丸でフォノンバンドを描画します。デフォルト値はlineです。</p></td>
</tr>
<tr class="row-odd"><td><p>--units=UNITS or -u UNITS</p></td>
<td><p>エネルギーの単位を指定します。mHa,
meV, THz, cm-1のいずれかです。デフォルト値はcm-1
です。</p></td>
</tr>
<tr class="row-even"><td><p>--width=WIDTH or -w WIDTH</p></td>
<td><p>作成される図の幅を指定します。デフォルト値は1です。</p></td>
</tr>
<tr class="row-odd"><td><p>--erange=[emin:emax] or -e
[emin:emax]</p></td>
<td><p>エネルギーの範囲を指定します。</p></td>
</tr>
<tr class="row-even"><td><p>--title=TITLE or -t TITLE</p></td>
<td><p>図のタイトルを指定します。</p></td>
</tr>
<tr class="row-odd"><td><p>--font=FONT or -f FONT</p></td>
<td><p>グラフに利用するフォントサイズを指定します。デフォルト値は18です。</p></td>
</tr>
<tr class="row-even"><td><p>--mono or -m</p></td>
<td><p>モノクログラフを描画したい場合にこのオプションを指定します。</p></td>
</tr>
<tr class="row-odd"><td><p>--keep or -k</p></td>
<td><p>中間のデータファイルを保持する場合、このオプションを有効にします。</p></td>
</tr>
<tr class="row-even"><td><p>--einc=EINC</p></td>
<td><p>エネルギーの目盛を指定します。</p></td>
</tr>
</tbody>
</table>
<p>phonon_energy.pl</p>
<p>フォノンの状態密度から、振動に由来する内部エネルギーとヘルムホルツの自由エネルギーや比熱を計算するスクリプトです。振動に由来するヘルムホルツの自由エネルギーに通常のDFT計算で得られる全エネルギーを加えれば、有限温度における固体の自由エネルギーを計算することができ、温度誘起の相転移を解析することなども可能です。</p>
<p>波数<strong>k</strong>のフォノンのエネルギーは、その振動数<span class="math notranslate nohighlight">\(\omega_{\mathbf{k}}\)</span>を利用して<span class="math notranslate nohighlight">\(\left( \frac{1}{2} + n \right)\hbar\omega_{k}\)</span>と記述することができます。分配関数は<span class="math notranslate nohighlight">\(Q_{k} = \sum_{n}^{}e^{\frac{- U_{\text{kn}}}{k_{B}T}}\)</span>と記述されるので、フォノンのエネルギーを代入し整理すると以下の結果が得られます。</p>
<div class="math notranslate nohighlight">
\[Q_{k} = \frac{\exp\left\lbrack - \frac{\hbar\omega_{k}}{2k_{B}T} \right\rbrack}{1 - \exp\left\lbrack - \frac{\hbar\omega_{k}}{k_{B}T} \right\rbrack}.\]</div>
<p>ヘルムホルツの自由エネルギーは<span class="math notranslate nohighlight">\(F_{\text{vib}} = \sum_{k}^{}{- k_{B}T\log Q_{k}}\)</span>と記述できるので、以下のように記述されます。</p>
<div class="math notranslate nohighlight">
\[F_{\text{vib}} = \sum_{k}^{}\left\lbrack \frac{\hbar\omega_{k}}{2} + k_{B}T\log\left( 1 - \exp\left\lbrack - \frac{\hbar\omega_{k}}{k_{B}T} \right\rbrack \right) \right\rbrack.\]</div>
<p>振動による平均の内部エネルギーは<span class="math notranslate nohighlight">\(U_{\text{vib}} = \frac{1}{Q_{k}}\sum_{n}^{}{U_{\text{kn}}\exp\left( - \frac{U_{\text{kn}}}{k_{B}T} \right)}\)</span>と記述できるので、以下のように記述することができます。</p>
<div class="math notranslate nohighlight">
\[U_{\text{vib}} = \sum_{k}^{}{\left\lbrack \frac{\hbar\omega_{k}}{2} + \frac{\hbar\omega_{k}}{\exp{\left\lbrack \frac{\hbar \omega}{k_{B}T} \right\rbrack - 1\ }} \right\rbrack.}\]</div>
<p>エントロピーは、<span class="math notranslate nohighlight">\(F_{\text{vib}}\)</span>および<span class="math notranslate nohighlight">\(U_{\text{vib}}\)</span>から<span class="math notranslate nohighlight">\(\left( U_{\text{vib}} - F_{\text{vib}} \right)/T\)</span> と計算することができます。定積比熱は内部エネルギーの温度に関する偏微分で与えられるので、以下のように計算することができます。</p>
<div class="math notranslate nohighlight">
\[C_{v} = \frac{\partial U_{\text{vib}}}{\partial T} = k_{B}\left\lbrack \frac{\frac{\hbar\omega_{k}}{k_{B}T}\exp{\left( \frac{\hbar\omega_{k}}{2k_{B}T} \right)}}{\exp{\left( \frac{\hbar\omega_{k}}{k_{B}T} \right) - 1}} \right\rbrack^{2}.\]</div>
<p>phonon_energy.plを利用すると、以上のような計算を実行することが可能です。以下のように利用します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>% phonon_energy.pl mode.data
</pre></div>
</div>
<p>この操作によって、以下の3つのファイルが作成されます。</p>
<p><strong>phonon_energy.dataファイル</strong>
内部エネルギー、ヘルムホルツ自由エネルギー、エントロピー、比熱の計算結果が以下の形式で記録されているファイルです。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span># T (K) Internal Energy (eV) Free energy (eV) Entropy (eV/K) Cv (kB/atom)
0 0.125434126153072 0.125434126153072 0 0 30 0.12552700746085 0.125409486111375 3.91737831580881e-06
0.0820122071540538 60 0.126828216477476 0.124936822438767 3.15232339784872e-05
0.435633166874193 90 0.130001095247047 0.123379006005857 7.35787693465625e-05
0.787404251770626 120 0.134948880737123 0.120473935403623 0.000120624544445835 1.12444793146534
.......
.......
.......
</pre></div>
</div>
<p>1列目に温度が、2列目以降からは内部エネルギーとヘルムホルツ自由エネルギーがeV単位で、エントロピーがeV/K単位で、原子あたりの比熱が<em>k</em><sub>B</sub>単位で記述されます。</p>
<p><strong>phonon_energy.eps ファイル</strong>
内部エネルギー、ヘルムホルツ自由エネルギー、エントロピーを温度の関数としてプロットしたEPSファイルです。</p>
<p><strong>phonon_Cv.eps ファイル</strong>
比熱と温度の関係をプロットしたEPSファイルです。</p>
<p>Si結晶の場合に得られるphonon_energy.epsおよびphonon_Cv.epsの例を示します。phonon_energy.plスクリプトは、フォノン状態密度計算を実行した際に得られるmode.dataファイルを利用する必要がある点にご注意ください。フォノンバンド計算を実行した際に得られるmode.dataファイルを利用すると、以下のようなエラーが発生し途中で終了してしまいます。なお、得られるエネルギーは、入力で指定した原子数分となります。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>% phonon_energy.pl mode.data
weight undefined for q-point no. 1 at /home/user/phase/bin/phonon_energy.pl line 131, &lt;MD&gt; line 4450.
</pre></div>
</div>
<figure class="align-default" id="id179">
<img alt="../_images/image91.png" src="../_images/image91.png" />
<figcaption>
<p><span class="caption-number">図 9.7 </span><span class="caption-text">phonon_energy.eps（左図）とphonon_Cv.eps（右図)の例</span><a class="headerlink" href="#id179" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
<p>phonon_energy.plスクリプトのオプションは、下記の通りです。</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>--width=WIDTH or -w WIDTH</strong></p></td>
<td><p>作成される図の幅を指定します。デフォルト値は1です。</p></td>
</tr>
<tr class="row-even"><td><p><strong>--trange=[tmin:tmax] or -t
[tmin:tmax]</strong></p></td>
<td><p>温度の範囲を指定します。デフォルト値は0
Kから3000 Kです。</p></td>
</tr>
<tr class="row-odd"><td><p><strong>--nT=NT or -n NT</strong></p></td>
<td><p>温度の点の数を指定します。デフォルト値は100です。</p></td>
</tr>
<tr class="row-even"><td><p><strong>--font=FONT or -f FONT</strong></p></td>
<td><p>グラフに利用するフォントサイズを指定します。デフォルト値は18
です。</p></td>
</tr>
<tr class="row-odd"><td><p><strong>--mono or -m</strong></p></td>
<td><p>モノクログラフを描画したい場合にこのオプションを指定します。</p></td>
</tr>
<tr class="row-even"><td><p><strong>--tinc=TINC</strong></p></td>
<td><p>温度の目盛を指定します。</p></td>
</tr>
<tr class="row-odd"><td><p><strong>--einc=EINC</strong></p></td>
<td><p>エネルギーの目盛を指定します。</p></td>
</tr>
<tr class="row-even"><td><p><strong>--cinc=EINC</strong></p></td>
<td><p>比熱の目盛を指定します。</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="id20">
<h3><span class="section-number">9.2.3. </span>例題<a class="headerlink" href="#id20" title="この見出しへのパーマリンク"></a></h3>
<section id="id21">
<h4><span class="section-number">9.2.3.1. </span>シリコン結晶<a class="headerlink" href="#id21" title="この見出しへのパーマリンク"></a></h4>
<p>最も簡単な例の1 つとして、シリコン結晶のフォノンバンドとフォノン状態密度の計算を実行した例を紹介します。
この例題の入力ファイルは、 <code class="code docutils literal notranslate"><span class="pre">samples/phono_band/Si</span></code> 以下にあります。</p>
<p>まずはバンド計算を行います。 <code class="code docutils literal notranslate"><span class="pre">samples/phonon_band/Si/band</span></code> 以下の入力ファイルを利用します。</p>
<p>band_kpoint.pl 用の入力ファイル、bandkpt.in
の内容は、以下のようになっています。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>0.02
-0.8333333 0.8333333 0.8333333
0.8333333 -0.8333333 0.8333333
0.8333333 0.8333333 -0.8333333
0 0 0 1 # {/Symbol G}
1 1 0 2 # X
5 3 0 8 # U
0 0 0 1 # {/Symbol G}
1 0 0 2 # L
</pre></div>
</div>
<p>このbandkpt.in ファイルを利用して、以下のようにkpoint.data
ファイルを作成します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>% band_kpoint.pl bandkpt.in
</pre></div>
</div>
<p>入力の、原子配置の指定は以下のようになっています。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>structure{
  unit_cell_type = bravis
  unit_cell{
    a = 10.17512
    b = 10.17512
    c = 10.17512
    alpha = 90.0
    beta = 90.0
    gamma = 90.0
  }
  symmetry{
    tspace{
      lattice_system = facecentered
    }
    method = automatic
  }
  atom_list{
    coordinate_system = internal
    atoms{
      #tag element rx ry rz mobile
          Si 0.125 0.125 0.125 0
          Si 0.875 0.875 0.875 0
    }
  }
  element_list{
    #units atomic_mass
    #tag element atomicnumber mass
        Si 14 28.0855
  }
}
</pre></div>
</div>
<p>unit_cell_type をbravais とし、lattice_system
パラメータによってこの系がfacecentered,
すなわち面心であることを指定しています。上述したように、通常のPHASE
の計算ではこのような指定がなされている場合単位胞を基本格子に変換しますが、フォノンバンド計算ではそのようなことは行われません。次に、phonon
ブロックを次のように記述しています。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Phonon{
  sw_phonon = on
  sw_calc_force = on
  sw_vibrational_modes = on
  lattice{
    l1 = 2
    l2 = 2
    l3 = 2
  }
  method = band
}
</pre></div>
</div>
<p>スーパーセルは、<em>a</em>, <em>b</em>, <em>c</em> 軸それぞれを2
倍とする設定を採用しています。以上の設定のもとPHASE
を通常通り実行します。計算が終了すると、その結果がmode.data
に記録されます。mode.data
ファイルからフォノンバンド図を得るためには、以下の操作を行います。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>% phonon_band.pl mode.data --control=bandkpt.in
</pre></div>
</div>
<p>--control オプションでband kpoint.pl
用の入力ファイルを指定していますが、この指定がない場合はバンド図に特殊点を表す縦線などは描画されなくなります。結果は次に示す図のようになります。</p>
<figure class="align-default" id="id180">
<img alt="../_images/image92.png" src="../_images/image92.png" />
<figcaption>
<p><span class="caption-number">図 9.8 </span><span class="caption-text">シリコン結晶のフォノンバンド</span><a class="headerlink" href="#id180" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
<p>フォノンの状態密度の計算に必要な入力データは、 <code class="code docutils literal notranslate"><span class="pre">samples/phonon_band/Si/dos</span></code>
以下にあります（力定数は計算済みなので、bandディレクトリーの下にあるforce.dataファイルをコピーして利用すると力定数計算をスキップすることも可能ですが、この場合はsw_calc_forceパラメータをoffに設定してください）このサンプルの入力パラメータファイルには、以下のような記述がなされています。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Phonon{
  sw_phonon = on
  sw_vibrational_modes = on
  lattice{
    l1 = 2
    l2 = 2
    l3 = 2
  }
  dos{
    mesh{
      nx = 10
      ny = 10
      nz = 10
    }
  }
  method = dos
}
</pre></div>
</div>
<p>method = dos
と指定することによって状態密度計算を行うことを指定しています。dos
ブロックの下のmesh
ブロックにおいて、状態密度計算で利用するメッシュを10×10×10
としています。入力をこのように編集し終えたらPHASE
を実行します。フォノン状態密度の計算結果はphdos.data
ファイルに記録されます。このデータをもとにphonon dos.pl
スクリプトを利用してフォノン状態密度図を作成します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>% phonon_dos.pl phdos.data
</pre></div>
</div>
<p>この結果得られるフォノン状態密度図は次に示す通りです。</p>
<figure class="align-default" id="id181">
<img alt="../_images/image93.png" src="../_images/image93.png" />
<figcaption>
<p><span class="caption-number">図 9.9 </span><span class="caption-text">シリコン結晶のフォノン状態密度。</span><a class="headerlink" href="#id181" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
</section>
<section id="id22">
<h4><span class="section-number">9.2.3.2. </span>ヨウ化カリウム<a class="headerlink" href="#id22" title="この見出しへのパーマリンク"></a></h4>
<p>ヨウ化カリウムはNaCl 型の結晶構造をもつ、イオン性の結晶です。 <a class="reference internal" href="#advanced-phband-fig1"><span class="std std-numref">図 9.10</span></a> にその結晶構造を示します。ここでは、この結晶を例にLO-TO
分裂を考慮したフォノンバンド計算を紹介します。この例題の入力ファイルは、 <code class="code docutils literal notranslate"><span class="pre">samples/phonon_band/KI</span></code> 以下にあります。</p>
<figure class="align-default" id="advanced-phband-fig1">
<img alt="../_images/image94.png" src="../_images/image94.png" />
<figcaption>
<p><span class="caption-number">図 9.10 </span><span class="caption-text">ヨウ化カリウムの結晶構造</span><a class="headerlink" href="#advanced-phband-fig1" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
<p>LO-TO分裂を考慮した計算を行うためには、電子系の誘電テンソルと有効電荷が必要です。これらは以下のようにして得ました。</p>
<ul class="simple">
<li><p><strong>誘電テンソル</strong>：UVSOR-Epsilonを利用して計算しました。この際、2.2
eVのギャップ補正を施しました。結果は、xx, yy, zz方向がそれぞれ2.6となりました。</p></li>
<li><p><strong>有効電荷</strong>：UVSOR-Berryを利用して、ボルン有効電荷テンソルの計算を行いました。結果は、カリウムの有効電荷が1.1262, ヨウ素の有効電荷が－1.1262となりました。</p></li>
</ul>
<p>これらを設定し、sw_lo_to_splittingをonとする以外はシリコン結晶の場合と同じです。に、得られたフォノンバンドを示します。比較のため、LO-TO分裂を考慮せずに計算した結果も合わせて表示しています。赤線がLO-TO分裂を考慮せずに計算した結果、青線が考慮して計算した結果に対応します。この図から明らかなように、Γ点付近ではLO-TO分裂によって考慮しない場合は縮退している状態が分裂しています。</p>
<figure class="align-default" id="id182">
<img alt="../_images/image95.png" src="../_images/image95.png" />
<figcaption>
<p><span class="caption-number">図 9.11 </span><span class="caption-text">KI 結晶のフォノンバンド。赤線がLO-TO分裂を考慮せずに計算した結果、青線がLO-TO 分裂を考慮して計算した結果。</span><a class="headerlink" href="#id182" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
</section>
<section id="id23">
<h4><span class="section-number">9.2.3.3. </span>スズの温度誘起相転移<a class="headerlink" href="#id23" title="この見出しへのパーマリンク"></a></h4>
<p>最後に、フォノン自由エネルギー解析の簡単な適用例としてスズの温度誘起相転移の例を紹介します。この例題の入力ファイルは、 <code class="code docutils literal notranslate"><span class="pre">samples/phonon_band/Sn/a-Sn</span></code> （αスズ）および <code class="code docutils literal notranslate"><span class="pre">samples/phband/Sn/b-Sn</span></code> （βスズ）にあります。</p>
<p>スズには、αスズとβスズと呼ばれる同素体があります。αスズはダイヤモンド構造、βスズはその名の通りβスズ構造をとります。その結晶構造を、 <a class="reference internal" href="#advanced-phband-fig2"><span class="std std-numref">図 9.12</span></a> に示します。</p>
<figure class="align-default" id="advanced-phband-fig2">
<img alt="../_images/image96.png" src="../_images/image96.png" />
<figcaption>
<p><span class="caption-number">図 9.12 </span><span class="caption-text">αスズ（左図）とβスズ（右図）の結晶構造</span><a class="headerlink" href="#advanced-phband-fig2" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
<p>βスズ構造はダイヤモンド構造を<em>c</em>軸方向から押しつぶしたような結晶構造であり、体心正方晶を取ります。常温ではβスズが安定ですが、低温下ではαスズが安定になります。これは、結晶そのものの全エネルギーはαスズの方が低いが、温度上昇に伴うフォノンの自由エネルギーの低下はβスズの方が大きいためある温度で自由エネルギーはβスズの方が低くなり、相転移するからであると考えられます。このような現象を、フォノンの自由エネルギー計算と結晶の全エネルギー計算を組み合わせて確認していきます。</p>
<p>まずは、格子定数の最適化を行いました。ただし、βスズ構造の<em>c</em>/<em>a</em>比は0.54614と固定して最適化しました。結果は、次の表に示す通りです。</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p></p></th>
<th class="head"><p>格子定数<em>a</em> (Å)</p></th>
<th class="head"><p>格子定数 <em>c</em> (Å)</p></th>
<th class="head"><p>全エネルギー (ha./cell)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>αスズ</p></td>
<td><p>6.6555</p></td>
<td><p>6.6555</p></td>
<td><p>-136.147884</p></td>
</tr>
<tr class="row-odd"><td><p>βスズ</p></td>
<td><p>5.9184</p></td>
<td><p>3.2323</p></td>
<td><p>-136.144694</p></td>
</tr>
</tbody>
</table>
<p>この結果から明らかなように、全エネルギーはαスズの方が低いので、絶対零度ではαスズが安定であると考えられます。</p>
<p>続いて、得られた安定な格子定数のもとで振動解析を行いました。自由エネルギーを評価する場合に必要な計算は、状態密度のみです。αスズ、βスズに対してシリコンの場合と同様の設定をPhononブロックで行い、振動解析を実施しました。計算終了後に得られたmode.dataファイルを、phonon_energy.plスクリプトで処理します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>% phonon_energy.pl mode.data
</pre></div>
</div>
<p>結果得られるphonon_energy.dataファイルの3列目にフォノンの自由エネルギーが記録されます。これは単位胞あたりの値なので、上述の全エネルギーの単位胞あたりのエネルギーを加え、温度の関数としてプロットすると
<a class="reference internal" href="#advanced-phband-fig3"><span class="std std-numref">図 9.13</span></a> のような結果が得られます。</p>
<figure class="align-default" id="advanced-phband-fig3">
<img alt="../_images/image97.png" src="../_images/image97.png" />
<figcaption>
<p><span class="caption-number">図 9.13 </span><span class="caption-text">αスズとβスズの自由エネルギーと温度の関係。赤線がαスズ、緑線がβスズに対応する。</span><a class="headerlink" href="#advanced-phband-fig3" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
<p><a class="reference internal" href="#advanced-phonon-fig3"><span class="std std-numref">図 9.3</span></a> においてαスズの曲線（赤線）とβスズの曲線（緑線）が交差する温度が転位温度と考えられます。この計算ではおおよそ510
Kとなりました。実際には290
Kなので相転移温度が高く評価されてしまいましたが、このような計算によって温度誘起の構造相転移を説明できることはお分かりいただけたと思います。</p>
</section>
</section>
<section id="project-phonon-band-to-atoms-section">
<span id="id24"></span><h3><span class="section-number">9.2.4. </span>フォノンバンドの原子群への射影（バージョン2022.01以降）<a class="headerlink" href="#project-phonon-band-to-atoms-section" title="この見出しへのパーマリンク"></a></h3>
<p>フォノンバンドを計算する際、特定の原子あるいは原子群の成分を抽出し可視化することができます。</p>
<section id="id25">
<h4><span class="section-number">9.2.4.1. </span>入力ファイル<a class="headerlink" href="#id25" title="この見出しへのパーマリンク"></a></h4>
<p>まず、入力パラメーターファイルに対象の原子群を検出するための縁となるkeyの値を原子に設定します。たとえば以下のように設定します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>structure{
    atom_list{
        atoms{
            #default mobile=yes
            #tag element rx   ry   rz  key
                 Si  0.00 0.00 0.00  1
                 Si  0.25 0.25 0.25  2
        }
   }
}
</pre></div>
</div>
<p>ついで、phononブロックにおいて次の設定を施します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>phonon{
  ..
  use_qpoint_data_file = yes
}
</pre></div>
</div>
<p>さらに、file_names.dataファイルにおいてファイルポインター <code class="docutils literal notranslate"><span class="pre">F_QPOINT</span></code> によってk点座標が記録されたファイルを指定します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&amp;fnames
F_QPOINT = &#39;./kpoint.data&#39;
/
</pre></div>
</div>
<p>この状態で通常通りフォノンバンドの計算を実行します。</p>
</section>
<section id="id26">
<h4><span class="section-number">9.2.4.2. </span>可視化スクリプト<a class="headerlink" href="#id26" title="この見出しへのパーマリンク"></a></h4>
<p>可視化にはphonon_band_atom_proj.pyを用います。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>usage: phonon_band_atom_proj.py [-h]
 [--atom_id [ATOM_ID [ATOM_ID ...]]]
               [--element [ELEMENT [ELEMENT ...]]] [--key [KEY [KEY ...]]]
               [--z_range Z_RANGE Z_RANGE]
               [--mode_sym [MODE_SYM [MODE_SYM ...]]] [--neglect_mass]
               [--disp_squared] [--e_range E_RANGE E_RANGE] [--e_inc E_INC]
               [--unit UNIT] [--plot_style PLOT_STYLE]
               [--circle_scale CIRCLE_SCALE] [--cb_range CB_RANGE CB_RANGE]
               [--fig_format FIG_FORMAT] [--out_file OUT_FILE]
               [--ref_file REF_FILE] [--ndiv_erange_map NDIV_ERANGE_MAP]
               [--broadening_width_map BROADENING_WIDTH_MAP]
               [--threshold THRESHOLD]
               phonon_file  qpt_file
</pre></div>
</div>
<p>phonon_file 及びqpt_fileは、最低限実行に必要なファイルで、それぞれ <code class="docutils literal notranslate"><span class="pre">mode.data</span></code> 及び <code class="docutils literal notranslate"><span class="pre">bandqpt.in</span></code> に対応します。上記で括弧内は省略可能なオプションで、その意味は以下のとおりです。</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 30.0%" />
<col style="width: 40.0%" />
<col style="width: 30.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>引数</p></td>
<td><p>意味</p></td>
<td><p>デフォルト値</p></td>
</tr>
<tr class="row-even"><td><p>--atom_id</p></td>
<td><p>原子インデックスのリスト (任意の個数)</p></td>
<td><p>なし</p></td>
</tr>
<tr class="row-odd"><td><p>--element</p></td>
<td><p>元素のリスト (任意の個数)</p></td>
<td><p>なし</p></td>
</tr>
<tr class="row-even"><td><p>--key</p></td>
<td><p>key 値のリスト (任意の個数)</p></td>
<td><p>なし</p></td>
</tr>
<tr class="row-odd"><td><p>--z_range</p></td>
<td><p>原子座標のz成分の最小値、最大値 (単位：bohr)</p></td>
<td><p>なし</p></td>
</tr>
<tr class="row-even"><td><p>--proj_qdir</p></td>
<td><p>縦波成分の比率を抽出する (バージョン2024.01以降)</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>--e_range</p></td>
<td><p>表示するエネルギー領域の 最小値、最大値</p></td>
<td><p>なし</p></td>
</tr>
<tr class="row-even"><td><p>--e_inc</p></td>
<td><p>エネルギー領域のインクリメント</p></td>
<td><p>なし</p></td>
</tr>
<tr class="row-odd"><td><p>--unit</p></td>
<td><p>エネルギーの単位 (meV, THz, cm-1)</p></td>
<td><p>cm-1</p></td>
</tr>
<tr class="row-even"><td><p>--plot_style</p></td>
<td><p>重みを表現する手法の指定 (1,2,3) 1: 円の半径、2: 色、 3: 色及び円の半径</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-odd"><td><p>--circle_scale</p></td>
<td><p>円の半径のスケール</p></td>
<td><p>1.0</p></td>
</tr>
<tr class="row-even"><td><p>--cb_range</p></td>
<td><p>重みの範囲の最小値、最大値</p></td>
<td><p>なし</p></td>
</tr>
<tr class="row-odd"><td><p>--fig_format</p></td>
<td><p>可視化画像の形式 (png/eps)</p></td>
<td><p>eps</p></td>
</tr>
<tr class="row-even"><td><p>--out_file</p></td>
<td><p>(拡張子を除く)出力ファイル名</p></td>
<td><p>atom_projected_phonon_band</p></td>
</tr>
</tbody>
</table>
<p>以下に実行例を示します。key 及び atom_id 値は、連番の場合、”-“ でつなげることができます。
例えば、”1-3” は “1 2 3” と同義です。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>python3  phonon_band_atom_proj.py  mode.data  bandqpt.in
--key 1-3 6  --element Si O --atom_id 11-13 17 20 21  --z_range 10.5  18.0
--unit THz --e_range 0 1000
--plot_style 3 --circle_scale 0.8 --cb_range 0.0 0.4　--out_file weight_phband
</pre></div>
</div>
<p>上記コマンドを実行すると、次に示すような形式で <code class="docutils literal notranslate"><span class="pre">weight_phband.dat</span></code> に各基準振動での重みの値が出力されます。 <code class="docutils literal notranslate"><span class="pre">out_file</span></code> 無指定の場合には、出力ファイル名は <code class="docutils literal notranslate"><span class="pre">atom_projected_phonon_band.dat</span></code> です。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>#      dq           freq[meV]        weight
     0.00000000    15.56924599     0.53087651
     0.01022875    15.50472679     0.49987256
</pre></div>
</div>
<p>拡張子 gnuのファイルは gnuplot 用のファイルです。このファイルをgnuplot で loadすると、png あるいは eps ファイルが生成されます。</p>
</section>
<section id="id27">
<h4><span class="section-number">9.2.4.3. </span>例題<a class="headerlink" href="#id27" title="この見出しへのパーマリンク"></a></h4>
<p><strong>SiO2 (alpha quartz)</strong></p>
<p>SiO2に適用した例を紹介します。入力ファイルは <code class="docutils literal notranslate"><span class="pre">samples/phonon_band/projected_pband/SiO2-bulk/phonon</span></code> 以下に配置されています。計算条件は次に示す通り。</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>平面波カットオフ [Ry]</p></td>
<td><p>25.0</p></td>
</tr>
<tr class="row-even"><td><p>電荷密度カットオフ [Ry]</p></td>
<td><p>225.0</p></td>
</tr>
<tr class="row-odd"><td><p>k 点サンプリング</p></td>
<td><p>monk (4×4×4)</p></td>
</tr>
<tr class="row-even"><td><p>交換相関相互作用</p></td>
<td><p>GGAPBE, PAW</p></td>
</tr>
<tr class="row-odd"><td><p>SCF 収束条件 [Ha/atom]</p></td>
<td><p>1.0E-8</p></td>
</tr>
<tr class="row-even"><td><p>displacement</p></td>
<td><p>0.05</p></td>
</tr>
<tr class="row-odd"><td><p>latticeの指定</p></td>
<td><p>l1=2, l2=2, l3=2</p></td>
</tr>
<tr class="row-even"><td><p>擬ポテンシャル</p></td>
<td><p>Si_ggapbe_paw_nc_01m.pp O_ggapbe_paw_us_02.pp</p></td>
</tr>
<tr class="row-odd"><td><p>格子定数 [Å, deg.]</p></td>
<td><p>a = 5.1059, b = 5.1059, c = 5.5842, alpha = 90, beta =90, gamma = 120</p></td>
</tr>
</tbody>
</table>
<p>用いた <code class="docutils literal notranslate"><span class="pre">bandqpt.in</span></code> ファイルの内容は下記の通り。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>0.02
  0.6512  0.0000  0.0000
  0.3760  0.7519  0.0000
  0.0000  0.0000  0.5954
0 0 1 2 # A
0 0 0 1 # {/Symbol G}
-1 -1 0 3 # K
0 -1 0 2 # M
0 0 0 1 # {/Symbol G}
</pre></div>
</div>
<p>可視化コマンドと得られる結果は下記の通り。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>python3  phonon_band_atom_proj.py  mode.data  bandqpt.in
--element Si --fig_format png --unit meV --e_range 0 160
--plot_style 2 --circle_scale 2
</pre></div>
</div>
<figure class="align-default" id="id183">
<img alt="../_images/projected_pband_SiO2_1.png" src="../_images/projected_pband_SiO2_1.png" />
<figcaption>
<p><span class="caption-number">図 9.14 </span><span class="caption-text">alpha quartz (ブラベー格子)の重み付きフォノンバンド。Si原子の寄与。</span><a class="headerlink" href="#id183" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>python3  phonon_band_atom_proj.py  mode.data  bandqpt.in
--element O --fig_format png --unit meV --e_range 0 160
--plot_style 2 --circle_scale 2
</pre></div>
</div>
<figure class="align-default" id="id184">
<img alt="../_images/projected_pband_SiO2_2.png" src="../_images/projected_pband_SiO2_2.png" />
<figcaption>
<p><span class="caption-number">図 9.15 </span><span class="caption-text">alpha quartz (ブラベー格子)の重み付きフォノンバンド。O原子の寄与。</span><a class="headerlink" href="#id184" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
<p>次に、SiO2 (0001)表面に適用した例を紹介します。入力ファイルは <code class="docutils literal notranslate"><span class="pre">samples/phonon_band/projected_pband/SiO2-surf/phonon_surf</span></code> 以下に配置されています。表面のOおよび裏面のSi原子はH原子で終端しました。計算条件は以下の通り。</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>平面波カットオフ [Ry]</p></td>
<td><p>25.0</p></td>
</tr>
<tr class="row-even"><td><p>電荷密度カットオフ [Ry]</p></td>
<td><p>225.0</p></td>
</tr>
<tr class="row-odd"><td><p>k 点サンプリング</p></td>
<td><p>monk (4×4×1)</p></td>
</tr>
<tr class="row-even"><td><p>交換相関相互作用</p></td>
<td><p>GGAPBE, PAW</p></td>
</tr>
<tr class="row-odd"><td><p>SCF 収束条件 [Ha/atom]</p></td>
<td><p>1.0E-8</p></td>
</tr>
<tr class="row-even"><td><p>displacement</p></td>
<td><p>0.05</p></td>
</tr>
<tr class="row-odd"><td><p>latticeの指定</p></td>
<td><p>l1=2, l2=2, l3=1</p></td>
</tr>
<tr class="row-even"><td><p>擬ポテンシャル</p></td>
<td><p>Si_ggapbe_paw_nc_01m.pp O_ggapbe_paw_us_02.pp H_ggapbe_paw_nc_01m.pp</p></td>
</tr>
<tr class="row-odd"><td><p>Si原子層</p></td>
<td><p>10 (表面のO原子及び裏面のSi原子を H原子で終端)</p></td>
</tr>
<tr class="row-even"><td><p>格子定数 [Å, deg.] (真空層を含む)</p></td>
<td><p>a = 5.1059, b = 5.1059, c = 35.0000, alpha = 90, beta =90, gamma = 120</p></td>
</tr>
</tbody>
</table>
<p>用いた <code class="docutils literal notranslate"><span class="pre">bandqpt.in</span></code> ファイルの内容は下記の通り。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>0.01
  0.6512  0.0000  0.0000
  0.3760  0.7519  0.0000
  0.0000  0.0000  0.0739
0 0 0 1 # {/Symbol G}
-1 -1 0 3 # K
0 -1 0 2 # M
0 0 0 1 # {/Symbol G}
</pre></div>
</div>
<p>以下に、可視化コマンドと得られた図を示します。指定した z_range値は、表面あるいは裏面から3 Si原子層までにある全ての原子に対応します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>python3  phonon_band_atom_proj.py  mode.data  bandqpt.in
--z_range 26.0 36.0 --fig_format png --unit meV --e_range 0 160
--plot_style 3 --circle_scale 0.8
</pre></div>
</div>
<figure class="align-default" id="id185">
<img alt="../_images/projected_pband_SiO2_0001_1.png" src="../_images/projected_pband_SiO2_0001_1.png" />
<figcaption>
<p><span class="caption-number">図 9.16 </span><span class="caption-text">alpha quartz (0001)表面の重み付きフォノンバンド。表面側成分。</span><a class="headerlink" href="#id185" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>python3 phonon_band_atom_proj.py  mode.data  bandqpt.in
--z_range 0.0 10.0 --fig_format png --unit meV --e_range 0 160
--plot_style 3 --circle_scale 0.8
</pre></div>
</div>
<figure class="align-default" id="id186">
<img alt="../_images/projected_pband_SiO2_0001_2.png" src="../_images/projected_pband_SiO2_0001_2.png" />
<figcaption>
<p><span class="caption-number">図 9.17 </span><span class="caption-text">alpha quartz (0001)表面の重み付きフォノンバンド。裏面側成分。</span><a class="headerlink" href="#id186" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>python3  phonon_band_atom_proj.py  mode.data  bandqpt.in
--atom_id 31-34  --fig_format png --unit meV --e_range 0 160
--plot_style 3 --circle_scale 0.8
</pre></div>
</div>
<figure class="align-default" id="id187">
<img alt="../_images/projected_pband_SiO2_0001_3.png" src="../_images/projected_pband_SiO2_0001_3.png" />
<figcaption>
<p><span class="caption-number">図 9.18 </span><span class="caption-text">alpha quartz (0001)表面の重み付きフォノンバンド。表面側H原子、およびそれに結合しているO原子の成分。</span><a class="headerlink" href="#id187" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>python3  phonon_band_atom_proj.py  mode.data  bandqpt.in
--atom_id 1 2 --fig_format png --unit meV --e_range 0 160
--plot_style 3 --circle_scale 0.8
</pre></div>
</div>
<figure class="align-default" id="id188">
<img alt="../_images/projected_pband_SiO2_0001_4.png" src="../_images/projected_pband_SiO2_0001_4.png" />
<figcaption>
<p><span class="caption-number">図 9.19 </span><span class="caption-text">alpha quartz (0001)表面の重み付きフォノンバンド。裏面側H原子の成分。</span><a class="headerlink" href="#id188" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
<p><strong>Si結晶における縦波比率の可視化 (バージョン2024.01以降)</strong></p>
<p>Si結晶の縦波成分の比率を可視化する例を紹介します。入力ファイルは <code class="docutils literal notranslate"><span class="pre">samples/phonon_band/projected_pband/Si2</span></code> 以下に配置されています。PHASE/0による計算を実行し、以下の要領で可視化スクリプトを実行します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>phonon_band_atom_proj.py  mode.data  bandqpt.in --proj_qdir  --plot_style 3  --fig_format png
</pre></div>
</div>
<p>その結果、次に示す図のように縦波の比率を色と円の半径で表したプロットを得ることができます。赤く半径が大きい点ほど、縦波成分が多いことを意味します。</p>
<figure class="align-default" id="id189">
<img alt="../_images/projected_pband_Si2_longitudinal.png" src="../_images/projected_pband_Si2_longitudinal.png" />
<figcaption>
<p><span class="caption-number">図 9.20 </span><span class="caption-text">Si 結晶(2原子)のフォノンバンドにおける縦波成分の可視化</span><a class="headerlink" href="#id189" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
</section>
</section>
<section id="project-phonon-band-to-surface-bz-section">
<span id="id28"></span><h3><span class="section-number">9.2.5. </span>バルクのフォノンバンドの表面ブリルアンゾーンへの射影（バージョン2022.01以降）<a class="headerlink" href="#project-phonon-band-to-surface-bz-section" title="この見出しへのパーマリンク"></a></h3>
<p>バルクのフォノンバンドを表面ブリルアンゾーンに射影する方法を説明します。</p>
<section id="id29">
<h4><span class="section-number">9.2.5.1. </span>入力<a class="headerlink" href="#id29" title="この見出しへのパーマリンク"></a></h4>
<p><code class="docutils literal notranslate"><span class="pre">band_kpoint.pl</span></code> を用いてk点座標データファイルを作成します。表面フォノンバンド用の <code class="docutils literal notranslate"><span class="pre">bandqpt.in</span></code> ファイルはたとえば以下のような内容になります。
（表面平行方向を、表面モデルと同じ形状に設定した） バルクのフォノンバンド計算でも、同じ入力ファイルを用います。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>0.02
  0.6076  0.0000  0.0000
  0.0000  0.8592  0.0000
  0.0000  0.0000  0.0831
0 1 0 2 # Y
0 0 0 1 # {/Symbol G}
1 0 0 2 # X
</pre></div>
</div>
<p>band_kpoint.plを以下の要領で実行します</p>
<p>表面の場合</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>band_kpoint.pl  bandqpt.in –outfile=qpoint.data
</pre></div>
</div>
<p>バルクの場合</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>band_kpoint.pl  bandqpt.in –outfile=qpoint.data  –zdiv=N  -zshift=1
</pre></div>
</div>
<p>表面の場合との違いは、各(qx,qy) にて、[0,1] の範囲で N 等分した qz 値を出力する点です。zshift &gt; 0 の場合には、qz を 0.5/N だけシフトします。</p>
<p>この状態で通常通りフォノンバンドの計算を実行します。</p>
</section>
<section id="id30">
<h4><span class="section-number">9.2.5.2. </span>可視化スクリプト<a class="headerlink" href="#id30" title="この見出しへのパーマリンク"></a></h4>
<p>可視化には前節同様phonon_band_atom_proj.pyを用います。ここではバルクのフォノンバンドの表面ブリルアンゾーンへ射影に特有のオプションを説明します。</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 30.0%" />
<col style="width: 40.0%" />
<col style="width: 30.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>引数</p></td>
<td><p>意味</p></td>
<td><p>デフォルト値</p></td>
</tr>
<tr class="row-even"><td><p>--ref_file</p></td>
<td><p>バルクのmode.data</p></td>
<td><p>なし</p></td>
</tr>
<tr class="row-odd"><td><p>--ndiv_erange_map</p></td>
<td><p>バルクのフォノンのスペクトルを計算するためのエネルギー軸の分割数</p></td>
<td><p>なし</p></td>
</tr>
<tr class="row-even"><td><p>--broadening_width_map</p></td>
<td><p>バルクのフォノンのスペクトルをなまらせる幅(エネルギー軸の分解能を単位とする)</p></td>
<td><p>5</p></td>
</tr>
<tr class="row-odd"><td><p>--threshold</p></td>
<td><p>プロットする表面フォノンバンドの重みのしきい値</p></td>
<td><p>0.01</p></td>
</tr>
</tbody>
</table>
<p>以下に実行例を示します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>python3  phonon_band_atom_proj.py  mode.data  bandqpt.in
--key 1 2 3 --fig_format png
--unit meV --e_range 0 200
--ref_file mode.data.bulk  --threshold 0.85
</pre></div>
</div>
<p>--ref_file を用いた場合には、plot_style の指定は無効になります。</p>
</section>
<section id="id31">
<h4><span class="section-number">9.2.5.3. </span>例題<a class="headerlink" href="#id31" title="この見出しへのパーマリンク"></a></h4>
<p>H終端Si(110)表面に適用した例を紹介します。
バルクの入力ファイルは <code class="docutils literal notranslate"><span class="pre">samples/phonon_band/projected_pband/Si-bulk/phonon</span></code> に、表面の入力ファイルは <code class="docutils literal notranslate"><span class="pre">samples/phonon_band/projected_pband/Si-surf/phonon_surf</span></code> 以下に配置されています。</p>
<p>計算条件は下記の通り。</p>
<p>バルク</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>平面波カットオフ [Ry]</p></td>
<td><p>25.0</p></td>
</tr>
<tr class="row-even"><td><p>電荷密度カットオフ [Ry]</p></td>
<td><p>225.0</p></td>
</tr>
<tr class="row-odd"><td><p>k 点サンプリング</p></td>
<td><p>monk (4×4×6)</p></td>
</tr>
<tr class="row-even"><td><p>交換相関相互作用</p></td>
<td><p>GGAPBE, PAW</p></td>
</tr>
<tr class="row-odd"><td><p>SCF 収束条件 [Ha/atom]</p></td>
<td><p>1.0E-8</p></td>
</tr>
<tr class="row-even"><td><p>displacement</p></td>
<td><p>0.05</p></td>
</tr>
<tr class="row-odd"><td><p>latticeの指定</p></td>
<td><p>l1=2, l2=2, l3=2</p></td>
</tr>
<tr class="row-even"><td><p>擬ポテンシャル</p></td>
<td><p>Si_ggapbe_paw_nc_01m.pp</p></td>
</tr>
<tr class="row-odd"><td><p>格子定数 [Å,deg.]</p></td>
<td><p>a = 5.4726, b = 3.8697, c = 3.8697, alpha = 90, beta = 90, gamma = 90</p></td>
</tr>
</tbody>
</table>
<p>表面</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>平面波カットオフ [Ry]</p></td>
<td><p>25.0</p></td>
</tr>
<tr class="row-even"><td><p>電荷密度カットオフ [Ry]</p></td>
<td><p>225.0</p></td>
</tr>
<tr class="row-odd"><td><p>k 点サンプリング</p></td>
<td><p>monk (4×4×1)</p></td>
</tr>
<tr class="row-even"><td><p>交換相関相互作用</p></td>
<td><p>GGAPBE, PAW</p></td>
</tr>
<tr class="row-odd"><td><p>SCF 収束条件 [Ha/atom]</p></td>
<td><p>1.0E-8</p></td>
</tr>
<tr class="row-even"><td><p>displacement</p></td>
<td><p>0.05</p></td>
</tr>
<tr class="row-odd"><td><p>latticeの指定</p></td>
<td><p>l1=2, l2=2, l3=1</p></td>
</tr>
<tr class="row-even"><td><p>擬ポテンシャル</p></td>
<td><p>Si_ggapbe_paw_nc_01m.pp H_ggapbe_paw_nc_01m.pp</p></td>
</tr>
<tr class="row-odd"><td><p>Si原子層</p></td>
<td><p>15</p></td>
</tr>
<tr class="row-even"><td><p>格子定数 [Å, deg.] (真空層含む)</p></td>
<td><p>a = 5.4726, b = 3.8697, c = 45.0000, alpha = 90, beta = 90, gamma = 90</p></td>
</tr>
</tbody>
</table>
<p>用いた <code class="docutils literal notranslate"><span class="pre">bandqpt.in</span></code> ファイルは以下の通り。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>0.01
  0.6076  0.0000  0.0000
  0.0000  0.8592  0.0000
  0.0000  0.0000  0.0831
0 1 0 2 # X
0 0 0 1 # {/Symbol G}
1 0 0 2 # X&#39;
</pre></div>
</div>
<p>表面については通常通り <code class="docutils literal notranslate"><span class="pre">band_kpoint.pl</span></code> を実行しました。バルクに関しては以下のコマンドを用いました。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>band_kpoint.pl bandqpt.in --outfile=qpoint.data --zdiv=50 --zshift=1X
</pre></div>
</div>
<p>以下に、可視化コマンドと得られた図を示します。指定した key 値は、表面及び裏面の5原子層のSi、および吸着H原子に対応します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>python3  phonon_band_atom_proj.py  mode.data  bandqpt.in
--key 1-6 12-17 --fig_format png --unit meV
--e_range 0 90 --ref_file  mode.data.bulk  --threshold 0.85
--out_file atom_projected_phonon_band_with_ref_bulk
( 現在のフォルダは、表面のフォノン計算を行ったフォルダとする。mode.data.bulk は、別のフォルダにある bulk のmode.data を指す。)
</pre></div>
</div>
<figure class="align-default" id="id190">
<img alt="../_images/projected_phonon_bulk_surface_Si.png" src="../_images/projected_phonon_bulk_surface_Si.png" />
<figcaption>
<p><span class="caption-number">図 9.21 </span><span class="caption-text">H終端Si(110)表面のフォノンバンド (青線)。表面あるいは裏面から5 Si原子層までの成分をプロット。灰色の領域は、バルクのフォノンバンドを射影したものに対応する。</span><a class="headerlink" href="#id190" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
</section>
</section>
<section id="phonon-band-unfolding-section">
<span id="id32"></span><h3><span class="section-number">9.2.6. </span>フォノンバンドアンフォールディング (バージョン2024.01以降)<a class="headerlink" href="#phonon-band-unfolding-section" title="この見出しへのパーマリンク"></a></h3>
<p>フォノンバンドも、 電子バンドと同じようにアンフォールド(<a class="reference internal" href="../electronic_structure/electronic_structure.html#advanced-band-unfold-section"><span class="std std-numref">6.7 章</span></a> 参照)することができます。フォノンバンドのアンフォールディングは、 <a class="reference internal" href="#zheng17" id="id33"><span>[Zheng17]</span></a> の方法を用いて行います。</p>
<section id="id34">
<h4><span class="section-number">9.2.6.1. </span>入力ファイル<a class="headerlink" href="#id34" title="この見出しへのパーマリンク"></a></h4>
<p>フォノンバンドアンフォールディングの機能を利用するには、phonon_band_unfoldingブロックで、sw_phonon_band_unfolding = onを指定します。また、電子バンドアンフォールディングと同じく、reference_cell ブロック内に、(基本格子等の) 射影したいセルの格子ベクトルを記入します。以下に入力例を示します。ハイライトしている部分が関係ある設定項目です。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span> structure{
     unit_cell_type = bravais
     unit_cell{
         a = 10.17512,   b = 10.17512,    c = 10.17512
         alpha = 90.0,    beta = 90.0,     gamma = 90.0
     }
<span class="hll">     reference_cell{
</span><span class="hll">        a_vector =  0.00000       5.08756        5.08756
</span><span class="hll">        b_vector =  5.08756       0.00000        5.08756
</span><span class="hll">        c_vector =  5.08756       5.08756        0.00000
</span><span class="hll">     }
</span> }
 Phonon{
     sw_phonon = on
     sw_vibrational_modes = on
     sw_calc_force = on
     displacement = 0.1

     method = band
     use_qpoint_data_file = yes

<span class="hll">     phonon_band_unfolding{
</span><span class="hll">        sw_phonon_band_unfolding = on
</span><span class="hll">        ngx = 4,   ngy = 4,  ngz = 4          ! default 値は 4
</span><span class="hll">     }
</span> }
</pre></div>
</div>
<p>ngx, ngy, ngz は、スーパーセルの逆格子ベクトルを単位としたときの、和をとるGベクトルの各方向の最大値です。qpoint.dataは、reference_cellに対応する bandqpt.in を用いて生成します。この仕様は、電子バンドアンフォールディングの場合と同じです。</p>
</section>
<section id="id35">
<h4><span class="section-number">9.2.6.2. </span>出力ファイル<a class="headerlink" href="#id35" title="この見出しへのパーマリンク"></a></h4>
<p>結果はmode.dataファイルに記録されます。フォノンバンドアンフォールディングの重みは、mode.data 内に “weight= ”として出力されます。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span> --- supercell lattice vectors ---
  10.1751200000   0.0000000000   0.0000000000
   0.0000000000  10.1751200000   0.0000000000
   0.0000000000   0.0000000000  10.1751200000
 --- reference cell lattice vectors ---
   0.0000000000   5.0875600000   5.0875600000
   5.0875600000   0.0000000000   5.0875600000
   5.0875600000   5.0875600000   0.0000000000
 --- Equilibrium position and mass of each atom---
 Natom=    8
 (中略)
 --- Vibrational modes ---
 Nmode=   24 Natom=    8 Nqvec  136
 iq=    1 q=(   0.0000000000,   0.0000000000,   0.0000000000) (   0.0000000000,   0.0000000000,   0.0000000000)
<span class="hll"> n=     1 T1u IR       weight= 0.99999995E+00
</span> hbarW= -0.14788702E-06 Ha = -0.40242108E-05 eV; nu= -0.32457453E-01 cm^-1
    1  -0.2040582657 -0.2040582615 -0.2040582515
    2  -0.2040582657 -0.2040582615 -0.2040582515
</pre></div>
</div>
</section>
<section id="id36">
<h4><span class="section-number">9.2.6.3. </span>可視化スクリプト<a class="headerlink" href="#id36" title="この見出しへのパーマリンク"></a></h4>
<p>可視化にはphonon_band_atom_proj.pyを利用します。バンドアンフォールディングの重みを抽出するには --unfolding オプションをつけて実行します。その他描画オプションなどについては <a class="reference internal" href="#project-phonon-band-to-atoms-section"><span class="std std-numref">9.2.4 章</span></a> を参照してください。</p>
</section>
<section id="id37">
<h4><span class="section-number">9.2.6.4. </span>例題<a class="headerlink" href="#id37" title="この見出しへのパーマリンク"></a></h4>
<p><strong>Si結晶 (8原子)</strong></p>
<p>8原子からなるSi結晶のフォノンバンドを2原子のプリミティブセルにアンフォールドする例を紹介します。入力ファイルは <code class="docutils literal notranslate"><span class="pre">samples/phonon_band/PhononBandUnfolding/Si8</span></code> 以下にあります。主な計算条件は下記の通り。</p>
<table class="docutils align-default" id="id191">
<caption><span class="caption-number">表 9.2 </span><span class="caption-text">Si 結晶 (8原子) のフォノンバンド計算条件</span><a class="headerlink" href="#id191" title="このテーブルへのパーマリンク"></a></caption>
<tbody>
<tr class="row-odd"><td><p>平面波カットオフ [Ry]</p></td>
<td><p>20</p></td>
</tr>
<tr class="row-even"><td><p>電荷密度カットオフ [Ry]</p></td>
<td><p>80</p></td>
</tr>
<tr class="row-odd"><td><p>k 点サンプリング</p></td>
<td><p>monk (2×2×2)</p></td>
</tr>
<tr class="row-even"><td><p>バンド数</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>交換相関相互作用</p></td>
<td><p>GGAPBE</p></td>
</tr>
<tr class="row-even"><td><p>擬ポテンシャル</p></td>
<td><p>Si_ggapbe_paw_nc_01m.pp</p></td>
</tr>
<tr class="row-odd"><td><p>初期波動関数</p></td>
<td><p>無指定</p></td>
</tr>
<tr class="row-even"><td><p>初期電荷密度</p></td>
<td><p>無指定</p></td>
</tr>
<tr class="row-odd"><td><p>スメアリング [eV]</p></td>
<td><p>無指定</p></td>
</tr>
<tr class="row-even"><td><p>SCF 収束条件 [Ha/atom]</p></td>
<td><p>無指定</p></td>
</tr>
</tbody>
</table>
<p>基本格子 (2原子) セルにアンフォールディングした重みを可視化するために用いたコマンド及び可視化結果を示します。この図においては、水色の半径が大きい点ほど、アンフォールディングの重みが大きいことを意味します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>phonon_band_atom_proj.py mode.data bandqpt.in --unfolding --plot_style 1 --fig_format png
</pre></div>
</div>
<figure class="align-default" id="si-phonon-unfold">
<img alt="../_images/Si_phonon_unfold.png" src="../_images/Si_phonon_unfold.png" />
</figure>
<p><strong>Si6AlP結晶(8原子)</strong></p>
<p>Si6AlP 結晶 (Si8原子中、2原子をAl及びP原子に置換)のフォノンバンドを2原子のプリミティブセルにアンフォールドする例を紹介します。入力ファイルは <code class="docutils literal notranslate"><span class="pre">samples/phonon_band/PhononBandUnfolding/Si6AlP</span></code> 以下にあります。なお、格子定数はSi 8原子の場合と同じとし、また原子座標はあらかじめ最適化したものを採用しました。その他主要な計算条件は下記の通り。</p>
<table class="docutils align-default" id="id192">
<caption><span class="caption-number">表 9.3 </span><span class="caption-text">Si6AlP 結晶 (8原子) のフォノンバンド計算条件</span><a class="headerlink" href="#id192" title="このテーブルへのパーマリンク"></a></caption>
<tbody>
<tr class="row-odd"><td><p>平面波カットオフ [Ry]</p></td>
<td><p>20</p></td>
</tr>
<tr class="row-even"><td><p>電荷密度カットオフ [Ry]</p></td>
<td><p>80</p></td>
</tr>
<tr class="row-odd"><td><p>k 点サンプリング</p></td>
<td><p>monk (2×2×2)</p></td>
</tr>
<tr class="row-even"><td><p>バンド数</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>交換相関相互作用</p></td>
<td><p>GGAPBE</p></td>
</tr>
<tr class="row-even"><td><p>擬ポテンシャル</p></td>
<td><p>Si_ggapbe_paw_nc_01m.pp,Al_ggapbe_paw_nc_01m.pp,P_ggapbe_paw_nc_01m.pp</p></td>
</tr>
<tr class="row-odd"><td><p>初期波動関数</p></td>
<td><p>無指定</p></td>
</tr>
<tr class="row-even"><td><p>初期電荷密度</p></td>
<td><p>無指定</p></td>
</tr>
<tr class="row-odd"><td><p>スメアリング [eV]</p></td>
<td><p>無指定</p></td>
</tr>
<tr class="row-even"><td><p>SCF 収束条件 [Ha/atom]</p></td>
<td><p>無指定</p></td>
</tr>
</tbody>
</table>
<p>bandqpt.inファイルはSi 8原子の場合と同じものを用いました。以下に、基本格子 (2原子) セルにアンフォールディングした重みを可視化するために用いたコマンド及び可視化結果を示します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>phonon_band_atom_proj.py mode.data bandqpt.in --unfolding --plot_style 1 --fig_format png
</pre></div>
</div>
<figure class="align-default" id="sialp-phonon-unfold">
<img alt="../_images/SiAlP_phonon_unfold.png" src="../_images/SiAlP_phonon_unfold.png" />
</figure>
</section>
</section>
<section id="id38">
<h3><span class="section-number">9.2.7. </span>使用上の注意<a class="headerlink" href="#id38" title="この見出しへのパーマリンク"></a></h3>
<ul class="simple">
<li><p>一般の<strong>k</strong> 点における振動解析を実行するためには、スーパーセルに対する振動解析を行う必要があります。したがって、Γ点のみの場合と比較すると非常に多くの計算時間が必要です。</p></li>
<li><p>フォノンバンド計算において最も計算量が多いのがスーパーセルに対する力の計算です。このデータは、1
度得られたら再利用することができます。たとえばフォノンの状態密度を計算したあとにフォノンバンドを計算する場合、または異なる対称線にそったフォノンバンドを計算する場合などは、以下のようにsw_calc_
forceパラメータをoff とすることによって力計算をやり直すことをさけることができます。なお、力計算の結果が保存されているファイルはforce.dataというファイルです。バンド計算と状態密度計算を異なるディレクトリで行う場合にsw_calc_force = offとする場合はこのファイルを当該ディレクトリにコピーして利用してください。</p></li>
</ul>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>phonon{
  sw_phonon = on
  sw_calc_force = off
}
</pre></div>
</div>
<ul class="simple">
<li><p>通常の計算の場合、入力で指定されたBravais格子はPrimitive 格子に変換されて計算が行われます。ところが、フォノンバンド計算の場合はこの変換は実施されず、Bravais 格子のままスーパーセルが作成され、計算が行われます。k点サンプリングメッシュを検討する際などに注意が必要です。</p></li>
<li><p>スーパーセル構築のパラメータ、l1, l2, l3
はもとの対称性を保つような指定の仕方をしてください。異なる対称性の場合、意味のある計算は行われません。</p></li>
</ul>
<p><strong>参考文献</strong></p>
<div role="list" class="citation-list">
<div class="citation" id="parlinski97" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id15">Parlinski97</a><span class="fn-bracket">]</span></span>
<p>K. Parlinski, Z. Q. Li and Y. Kawazoe, Physical Review Letters vol. 78 pp. 4063 (1997).</p>
</div>
<div class="citation" id="zheng17" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id33">Zheng17</a><span class="fn-bracket">]</span></span>
<p>F. Zheng and P. Zhang, Comput. Phys. Comm. 210, 139 (2017).</p>
</div>
</div>
</section>
</section>
<section id="section-unitcell-optimization">
<span id="id39"></span><h2><span class="section-number">9.3. </span>ストレステンソルを利用したユニットセル最適化機能<a class="headerlink" href="#section-unitcell-optimization" title="この見出しへのパーマリンク"></a></h2>
<p>PHASE/0には、ストレステンソルを利用して単位胞を最適化する機能が備わっています。ここでは、この機能の使い方の説明を行います。</p>
<section id="id40">
<h3><span class="section-number">9.3.1. </span>入力パラメータ<a class="headerlink" href="#id40" title="この見出しへのパーマリンク"></a></h3>
<p>まずは、通常通り入力パラメータファイルを記述します。セルを変形させたあとに座標の緩和を行いたい場合は通常通り原子座標最適化用のパラメータを設定すればセルの変形→力が収束していない場合は原子座標の最適化、という動作をするようになります。さらに、単位胞最適化用の、以下のような設定を加えます。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>structure_evolution{
  lattice{
    sw_optimize_lattice = on
  }
}
</pre></div>
</div>
<p>変数sw_optimize_latticeをonとすると本機能を利用することができます。latticeブロックには、以下の変数を定義することが可能です。</p>
<table class="longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p>sw_optimize_lattice</p></td>
<td><p>単位胞最適化機能を有効にする場合onとします。</p>
<p>デフォルト値はoffです。なお、このスイッチがonの場合はsw_stressは自動的にonになります。</p>
</td>
</tr>
<tr class="row-even"><td><p>sw_uniform</p></td>
<td><p>単位胞を一様に変化させたい場合にonとします。デフォルト値はoffです。このパラメータがonの場合、ストレステンソルの対角要素の平均値によって体積を変化させるように動作します。</p></td>
</tr>
<tr class="row-odd"><td><p>sw_rebuild_pws</p></td>
<td><p>単位胞を変形させた後に平面波基底を作り直すかどうかを指定します。デフォルト値はon,
つまり格子が変形する度に平面波を作り直します。Offとすることによって電子状態計算の収束性を向上させることができますが、格子が変形しても同じ平面波セットを利用している、ということは厳密にはカットオフエネルギーが微妙に変化している、ということに相当する点に注意が必要です。また、このパラメータをoffとすると継続計算ができなくなってしまいます。</p></td>
</tr>
<tr class="row-even"><td><p>method</p></td>
<td><p>最適化の手法を選択します。
bfgs, quench, steepest_descent
のいずれかを指定します。
デフォルト値はbfgsです。</p></td>
</tr>
<tr class="row-odd"><td><p>delta_stress</p></td>
<td><p>methodがquenchかsteepest_descent
の場合の更新の刻み幅を指定します。
デフォルト値は1です。</p></td>
</tr>
<tr class="row-even"><td><p>max_stress</p></td>
<td><p>収束判定に利用する、ストレステンソルの最大値を圧力の単位で指定します。デフォルト値は1.e-6
hartree/bohr<sup>3</sup>です。sw_uniformがonの場合はストレステンソルの対角要素の平均が収束判定に採用されます。</p></td>
</tr>
<tr class="row-odd"><td><p>sw_optimize_coordinates_once</p></td>
<td><p>原子配置の最適化は1回目の格子の更新時のみ行いたい場合にonとします。</p></td>
</tr>
<tr class="row-even"><td><p>fix_length_a</p></td>
<td><p>onとすると<em>a</em>軸の長さを固定して格子を最適化します。</p></td>
</tr>
<tr class="row-odd"><td><p>fix_length_b</p></td>
<td><p>onとすると<em>b</em>軸の長さを固定して格子を最適化します。</p></td>
</tr>
<tr class="row-even"><td><p>fix_length_c</p></td>
<td><p>onとすると<em>c</em>軸の長さを固定して格子を最適化します。</p></td>
</tr>
<tr class="row-odd"><td><p>fix_angle_alpha</p></td>
<td><p>onとすると格子定数αを固定して格子を最適化します。</p></td>
</tr>
<tr class="row-even"><td><p>fix_angle_beta</p></td>
<td><p>onとすると格子定数βを固定して格子を最適化します。</p></td>
</tr>
<tr class="row-odd"><td><p>fix_angle_gamma</p></td>
<td><p>onとすると格子定数γを固定して格子を最適化します。</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id41">
<h3><span class="section-number">9.3.2. </span>バージョン2019.01未満の場合の注意点<a class="headerlink" href="#id41" title="この見出しへのパーマリンク"></a></h3>
<p>ストレステンソルのカットオフエネルギーに対する収束性はかなり悪い場合があります。ストレスミニマムと全エネルギーのミニマムが一致しない場合、おそらくカットオフが不十分であることが要因と思われます。このようなケースに遭遇したら、ストレステンソルとカットオフエネルギーの関係をしらべていただくことを推奨します。</p>
</section>
<section id="id42">
<h3><span class="section-number">9.3.3. </span>ストレステンソル補正（バージョン2019.01以降）<a class="headerlink" href="#id42" title="この見出しへのパーマリンク"></a></h3>
<p>ストレステンソルの計算精度は低い場合が多いので、補正する設定を施すことが推奨されます。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>structure_evolution{
  stress{
    sw_stress_correction = on
  }
}
</pre></div>
</div>
</section>
<section id="advanced-latopt-reuse-wfchg-section">
<span id="id43"></span><h3><span class="section-number">9.3.4. </span>電荷密度および波動関数の再利用（バージョン2019.02以降）<a class="headerlink" href="#advanced-latopt-reuse-wfchg-section" title="この見出しへのパーマリンク"></a></h3>
<p>格子最適化を行う場合、格子が変形するたびに電荷密度や波動関数のメッシュは変化します。そのため、2019.01以前のバージョンにおいては波動関数や電荷密度は格子が変形するたびに作り直す振る舞いがデフォルトの振る舞いでしたが、バージョン2019.02以降より新しいメッシュに補間して古い電荷密度および波動関数データを割り当てる動作がデフォルトの振る舞いとなりました。この変更により、SCF計算の収束に要する回数を大幅に減らすことができるようになりました。この動作を抑制したい場合は以下のような設定を行います。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>structure_evolution {
  lattice {
    sw_optimize_lattice = on
    sw_interpolate_charge = off
    sw_interpolate_wfs = off
  }
}
</pre></div>
</div>
</section>
<section id="advanced-latopt-sametime">
<span id="id44"></span><h3><span class="section-number">9.3.5. </span>格子と原子座標を同時に最適化する方法（バージョン2023.01以降）<a class="headerlink" href="#advanced-latopt-sametime" title="この見出しへのパーマリンク"></a></h3>
<p>ストレステンソルを用いた格子の最適化においては、まずは原子座標の最適化が行われ、収束後格子の最適化が行われます。この二種類の最適化を同時に進行させることができます。この機能を利用するためには、入力パラメーターファイルに以下の記述を行います。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>structure_evolution {
  lattice{
    sw_optimize_coords_sametime = on
  }
}
</pre></div>
</div>
<p>多くの場合このオプションを使うと少ないステップ数で最終的な収束を得ることができます。</p>
<p>本機能を利用する場合は、格子緩和手法はBFGS（既定値）のみ使用できます。
また、sw_uniform=OFF（既定値）でご利用ください。</p>
</section>
<section id="id45">
<h3><span class="section-number">9.3.6. </span>計算結果の出力<a class="headerlink" href="#id45" title="この見出しへのパーマリンク"></a></h3>
<p>結果はoutput000ファイル、nfefn.dataファイル、nfdynm.dataファイルに記録されます。</p>
<p>output000ファイルには、ストレステンソルが記録されます。以下のコマンドによってその情報を抽出することができます。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>% grep –A3 ‘Total STRESS’ output000
   Total STRESS TENSOR
        0.0002320404        0.0000000000        0.0000000000
        0.0000000000        0.0002320404       -0.0000000000
        0.0000000000       -0.0000000000        0.0002117384
--
  Total STRESS TENSOR
        0.0002266097       -0.0000000000       -0.0000000000
       -0.0000000000        0.0002266097        0.0000000000
       -0.0000000000        0.0000000000        0.0002051476
--
...
...
</pre></div>
</div>
<p>通常の計算の場合ストレステンソルが1組出力されるのみですが、本機能を利用している場合はストレステンソルの履歴が出力されます。</p>
<p>nfefn.dataファイルには、通常通り全エネルギーや原子に働く力の最大値のほか、ストレステンソルの最大値（sw_uniformがonの場合は対角要素の平均値）が記録されます。たとえば、以下のような出力が得られます。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>iter_unitcell, iter_ion, iter_total, etotal, forcmx, stressmx
1 1 18 -181.4043211413 0.0020128619
1 2 27 -181.4043355689 0.0015666906
1 3 36 -181.4043464493 0.0011267018
1 4 44 -181.4043509953 0.0008837770
1 5 53 -181.4043582176 0.0000137026 0.0002326236
2 1 73 -181.4044226903 0.0000645338 0.0002272841
</pre></div>
</div>
<p>nfdynm.dataファイルも通常のものとほぼ同じですが、通常の計算の場合は一度しか出力されないヘッダーが、セルベクトルが変形される度に出力されます。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>#
# a_vector = 8.6795114819 0.0000000000 0.0000000000
# b_vector = 0.0000000000 8.6795114819 0.0000000000
# c_vector = 0.0000000000 0.0000000000 5.5916992108
# ntyp = 2 natm = 6
# (natm-&gt;type) 2 2 1 1 1 1
# (speciesname) 1 : O
# (speciesname) 2 : Ti
#
cps and forc at (iter_ion, iter_total = 1 18 )
1 0.000000000 0.000000000 0.000000000 0.000000 0.000000 0.000000
2 4.339755741 4.339755741 2.795849605 0.000000 0.000000 0.000000
3 2.643779197 2.643779197 0.000000000 -0.001423 -0.001423 0.000000
4 6.983534938 1.695976544 2.795849605 -0.001423 0.001423 0.000000
……
……
#
# a_vector = 8.7672856463 0.0000000000 0.0000000000
# b_vector = 0.0000000000 8.7672856463 0.0000000000
# c_vector = 0.0000000000 0.0000000000 5.6429940606
# ntyp = 2 natm = 6
# (natm-&gt;type) 2 2 1 1 1 1
# (speciesname) 1 : O
# (speciesname) 2 : T
#
cps and forc at (iter_ion, iter_total = 1 111 )
1 0.000000000 0.000000000 0.000000000 0.000000 0.000000 0.000000
2 4.383642823 4.383642823 2.821497030 0.000000 0.000000 0.000000
3 2.663907294 2.663907294 0.000000000 0.001773 0.001773 0.000000
4 7.047550117 1.719735530 2.821497030 0.001773 -0.001773 0.000000
5 1.719735530 7.047550117 2.821497030 -0.001773 0.001773 0.000000
6 -2.663907294 -2.663907294 0.000000000 -0.001773 -0.001773 0.000000
……
……
</pre></div>
</div>
</section>
<section id="tio2">
<span id="advanced-rutile-optimizatin"></span><h3><span class="section-number">9.3.7. </span>計算例：ルチル型TiO<sub>2</sub> (ストレス補正なし)<a class="headerlink" href="#tio2" title="この見出しへのパーマリンク"></a></h3>
<p>ルチル型TiO <sub>2</sub> の格子最適化を行った例を紹介します。入力データは <code class="code docutils literal notranslate"><span class="pre">samples/unitcel_optimization/TiO2</span></code> 以下にあります。</p>
<p>入力パラメータファイルには、以下のような設定を施しました。</p>
<ul class="simple">
<li><p>カットオフエネルギーは80 Rydberg</p></li>
<li><p>擬ポテンシャルはポータルサイトにおいて公開されているTi_ggapbe_paw_us_02.ppとO_ggapbe_paw_us_02m.pp</p></li>
<li><p>原子座標の最適化を施す設定；手法はBFGS法、収束判定となる力の最大値は2e-4</p></li>
<li><p>初期原子配置および格子定数は、無機材料データベースAtomWork（<a class="reference external" href="http://crystdb.nims.go.jp/">http://crystdb.nims.go.jp/</a>）に登録されていたルチル型TiO<sub>2</sub>のデータを採用</p></li>
<li><p>波動関数ソルバー、電荷密度ミキサーは指定せず、デフォルト設定を採用。</p></li>
</ul>
<p>採用したカットオフエネルギーは80
Rydbergと比較的大きなものですが、後述のようにTiO<sub>2</sub>の場合はこれくらい必要であると考えられます。</p>
<p>nfefn.dataファイルの内容は、以下のようになりました。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>iter_unitcell, iter_ion, iter_total, etotal, forcmx, stressmx
1 1 18 -181.4043211413 0.0020128619
1 2 27 -181.4043355689 0.0015666906
1 3 36 -181.4043464493 0.0011267018
1 4 44 -181.4043509953 0.0008837770
1 5 53 -181.4043582176 0.0000137026 0.0002326236
2 1 73 -181.4044226903 0.0000645338 0.0002272841
3 1 92 -181.4044839579 0.0001241955 0.0002222588
4 1 111 -181.4056948858 0.0025074070 0.0002222588
4 2 120 -181.4057176163 0.0020195652 0.0002222588
4 3 130 -181.4057600852 0.0000156213 0.0000444895
……
……
9 1 248 -181.4058191217 0.0001647915 0.0000332105
10 1 268 -181.4058328662 0.0000709369 0.0000119789
11 1 287 -181.4058349707 0.0000268520 0.0000015502
12 1 306 -181.4058351835 0.0000244918 0.0000006790
</pre></div>
</div>
<p>まずは、原子座標の最適化が5回実施されています。その間ストレステンソルは未計算なので、6列目は空欄になっています。5回目で原子に働く力の最大値が閾値より小さくなったので、セルを変形させたのちに計算が進行しています。この際に、単位胞最適化の更新回数を表す1列目の数値が2になっていることがわかります。また、6列目にストレステンソルの最大値が記録されています。2回目と3回目の更新時はセルを変形させても原子に働く力の最大値は閾値以下だったので原子座標の最適化は実施されませんでしたが、4回目セルベクトル更新時にはそうではなかったので原子座標の最適化が行われています。このようにセルの最適化と必要に応じた原子座標の最適化が行われつつ計算が進行し、セルの更新回数が12回となったところでストレステンソルの最大値が閾値以下となったので計算は収束したとみなされ終了しています。単位胞最適化収束の履歴を、図にまとめました。</p>
<figure class="align-default" id="id193">
<img alt="../_images/image215.png" src="../_images/image215.png" />
<figcaption>
<p><span class="caption-number">図 9.22 </span><span class="caption-text">単位胞最適化の履歴。赤線：全エネルギー、緑線：ストレステンソルの最大成分。</span><a class="headerlink" href="#id193" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
<p>安定な格子定数は、nfdynm.dataファイルに記録された最後のセルベクトル更新の情報からもとめることができます。この例の場合、<em>a</em>=8.7934
bohr, <em>c</em>=5.6164 bohrと得られました。</p>
<ul class="simple">
<li><p>ストレステンソルとカットオフエネルギー</p></li>
</ul>
<p>ストレステンソルは、全エネルギーや原子間力と比較してカットオフエネルギーに対して収束しづらい傾向があります。例として、ルチル型TiO<sub>2</sub>の、実測値の格子定数で計算したストレステンソルとカットオフエネルギーの関係を図にプロットしました。</p>
<figure class="align-default" id="id194">
<img alt="../_images/image216.png" src="../_images/image216.png" />
<figcaption>
<p><span class="caption-number">図 9.23 </span><span class="caption-text">ルチル型TiO<sub>2</sub>の場合の、ストレステンソルとカットオフエネルギーの関係</span><a class="headerlink" href="#id194" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
<p>図からわかるように、カットオフ50 Rydberg程度の場合ストレステンソルの符号が間違ってしまっています。このケースでは、ある程度収束したストレステンソルを得るためには、最低でも80 Rydberg程度以上のカットオフエネルギーが必要であることが示唆されます。</p>
</section>
<section id="tio2-2019-01">
<span id="advanced-rutile-opt"></span><h3><span class="section-number">9.3.8. </span>計算例：ルチル型TiO<sub>2</sub> (ストレス補正あり、バージョン2019.01以降)<a class="headerlink" href="#tio2-2019-01" title="この見出しへのパーマリンク"></a></h3>
<p><a class="reference internal" href="#advanced-rutile-optimizatin"><span class="std std-numref">9.3.7 章</span></a> で行った最適化を、ストレス補正を有効にして実行してみます。
入力データは <code class="code docutils literal notranslate"><span class="pre">samples/unitcell_optimization/TiO2_with_correction</span></code> にあります。</p>
<p>入力パラメータファイルには、以下のような設定を施しました。
計算条件は下記の通り。</p>
<ul class="simple">
<li><p>カットオフエネルギーは36 Rydberg</p></li>
<li><p>ストレス補正は有効
(structure_evolutionブロックの下のstressブロックにおいてsw_stress_correction
= onと設定)</p></li>
<li><p>擬ポテンシャルはポータルサイトにおいて公開されているTi_ggapbe_paw_us_02.ppとO_ggapbe_paw_us_02m.pp</p></li>
<li><p>原子座標の最適化を施す設定；手法はBFGS法、収束判定となる力の最大値は2e-4</p></li>
<li><p>初期原子配置および格子定数は、無機材料データベースAtomWork（ <a class="reference external" href="http://crystdb.nims.go.jp/">http://crystdb.nims.go.jp/</a> ）に登録されていたルチル型TiO<sub>2</sub>のデータを採用</p></li>
<li><p>波動関数ソルバー、電荷密度ミキサーは指定せず、デフォルト設定を採用。</p></li>
</ul>
<p>結果得られる単位胞最適化収束の履歴を次の図に示します。比較的低いカットオフ(36 Rydberg)を採用しているにも関わらずスムーズな最適化が行えました。結果得られる格子定数は、<em>a</em> = 8.806 bohr, <em>c</em> = 5.619 bohrとなりました。</p>
<figure class="align-default" id="id195">
<img alt="../_images/image217.svg" src="../_images/image217.svg" /><figcaption>
<p><span class="caption-number">図 9.24 </span><span class="caption-text">単位胞最適化の履歴。赤線：全エネルギー、緑線：ストレステンソルの最大成分。</span><a class="headerlink" href="#id195" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
</section>
<section id="tio2-2023-01">
<h3><span class="section-number">9.3.9. </span>計算例：ルチル型TiO<sub>2</sub> (ストレス補正あり、原子座標と格子同時最適化、バージョン2023.01以降)<a class="headerlink" href="#tio2-2023-01" title="この見出しへのパーマリンク"></a></h3>
<p><a class="reference internal" href="#advanced-rutile-optimizatin"><span class="std std-numref">9.3.7 章</span></a> で行った最適化を、ストレス補正を有効にし、さらに原子座標と格子を同時に最適化することによって行います。
入力データは <code class="code docutils literal notranslate"><span class="pre">samples/unitcell_optimization/TiO2_with_correction_sametime</span></code> にあります。入力設定は <code class="code docutils literal notranslate"><span class="pre">sw_optimize_coords_sametime=on</span></code> とした以外は <a class="reference internal" href="#advanced-rutile-opt"><span class="std std-numref">9.3.8 章</span></a> の場合と同一です。</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>手法</p></td>
<td><p>総SCF計算回数</p></td>
<td><p>格子定数 <span class="math notranslate nohighlight">\(a\)</span> (Bohr)</p></td>
<td><p>格子定数 <span class="math notranslate nohighlight">\(c\)</span> (Bohr)</p></td>
<td><p>全エネルギー(Hartree)</p></td>
</tr>
<tr class="row-even"><td><p>sw_optimize_coords_sametime=off</p></td>
<td><p>208</p></td>
<td><p>8.806</p></td>
<td><p>5.619</p></td>
<td><p>-181.3054220253</p></td>
</tr>
<tr class="row-odd"><td><p>sw_optimize_coords_sametime=on</p></td>
<td><p>125</p></td>
<td><p>8.806</p></td>
<td><p>5.620</p></td>
<td><p>-181.3054294087</p></td>
</tr>
</tbody>
</table>
<p>両手法でほぼ同じ結果を得ることができましたが、 <code class="code docutils literal notranslate"><span class="pre">sw_optimize_coords_sametime=on</span></code> とするとSCFの回数を4割程度削減することができました。この問題に限らず、多くの問題で計算時間の短縮が見込める手法です。</p>
</section>
</section>
<section id="section-molecular-dynamics">
<span id="id46"></span><h2><span class="section-number">9.4. </span>分子動力学法シミュレーション<a class="headerlink" href="#section-molecular-dynamics" title="この見出しへのパーマリンク"></a></h2>
<section id="id47">
<h3><span class="section-number">9.4.1. </span>機能の概要<a class="headerlink" href="#id47" title="この見出しへのパーマリンク"></a></h3>
<p>PHASEは、原子に働く力を利用して分子動力学法シミュレーションを行うことが可能です。
エネルギー一定、温度一定、圧力一定の分子動力学シミュレーションなどが実行できます。</p>
</section>
<section id="id48">
<h3><span class="section-number">9.4.2. </span>入力パラメータ<a class="headerlink" href="#id48" title="この見出しへのパーマリンク"></a></h3>
<p>分子動力学法シミュレーション機能と関連あるタグの一覧を表に示します。</p>
<p>分子動力学法シミュレーション機能に関連のあるタグの一覧</p>
<table class="longtable docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>第1
ブロック識別子</p></th>
<th class="head"><p>第2、第3
ブロック識別子</p></th>
<th class="head"><p>タグ識別子</p></th>
<th class="head"><p>説明</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>structure_evolution</p></td>
<td></td>
<td></td>
<td><p>原子座標データの更新方法を指定するブロック</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>method</p></td>
<td><p>原子座標の更新方法を指定する。分子動力学シミュレーションの場合、</p>
<p>velocity_verlet
（エネルギー一定の分子動力学シミュレーション）</p>
<p>temperature_control
（温度一定の分子動力学シミュレーション）</p>
<p>pressure_control
(エネルギー・圧力一定の分子動力学シミュレーション)</p>
<p>temperature_pressure_control
(温度・圧力一定の分子動力学シミュレーション)</p>
</td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>dt</p></td>
<td><p>時間刻みを指定する。</p>
<p>デフォルト値は100
au (約2.4 fs)</p>
</td>
</tr>
<tr class="row-odd"><td></td>
<td><p>temperature_control</p></td>
<td></td>
<td><p>温度制御の設定を行うブロック。</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>method</p></td>
<td></td>
<td><p>温度制御の方法を指定する。nose_hooverかvelocity_scalingのいずれか。nose_hooverの場合はNose-Hoover熱浴による温度制御が、velocity_scalingの場合は温度スケーリングによる温度制御が行われる。デフォルト値はnose_hoover.</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>sw_read_velocities</p></td>
<td></td>
<td><p>原子の初期速度を、PHASE/0に自動生成させるのではなく手動で入力する場合にこのパラメータをonとします。デフォルト値はoffです。</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>set_initial_velocity</p></td>
<td></td>
<td><p>原子の初期速度をプログラムが自動的に設定するかどうかを指定するスイッチ。デフォルト値はon</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>sw_shift_velocities</p></td>
<td></td>
<td><p>全運動量がゼロになるよう、MDステップごとに速度をシフトするかどうかを指定するスイッチです。デフォルト値はoffです。</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>thermostat</p></td>
<td></td>
<td><p>熱浴の設定を行うブロック。表形式データ。</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>temp</p></td>
<td><p>温度を指定する。</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>qmass</p></td>
<td><p>熱浴の質量を指定する。</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>tdamp</p></td>
<td><p>熱浴の質量を直接指定するのではなく、その周期を時間の単位で指定する。qmassによる指定の方が優先される。なお、qmassもtdampも指定がない場合、tdamp=50×dtに相当する周期の質量がデフォルト値として採用される。</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>pressure_control</p></td>
<td></td>
<td><p>圧力制御の設定を行うブロック。</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>pressure</p></td>
<td></td>
<td><p>目的の圧力を指定する。</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>mass_baro</p></td>
<td></td>
<td><p>バーロスタットの質量を指定する。</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>m11,m12,m13</p>
<p>m21,m22,m23</p>
<p>m31,m32,m33</p>
</td>
<td></td>
<td><p>格子の制御に拘束条件を加える。たとえば、m11
=
offとすると11成分(<em>a</em>軸・<em>a</em>軸)が変化しなくなる。</p></td>
</tr>
<tr class="row-even"><td><p>structure</p></td>
<td><p>atom_list</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>atoms</p></td>
<td></td>
<td><p>原子配置を指定するブロック。表形式データ。</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>mobile</p></td>
<td><p>原子が“可動”かどうかを指定する。可動にする場合onを指定する。</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>thermo group</p></td>
<td><p>原子に熱浴を割り当てる。定義した順に、整数値で指定する。</p>
<p>デフォルト値は0(熱浴に割り当てられていない状態)</p>
</td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>vx,vy,vz</p></td>
<td><p>原子の初期速度を手動入力する場合(sw_read_velocities=onの場合)に各原子の速度のx,y,z値を原子単位で入力する。入力が省略される場合、0とみなされる。</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>element_list</p></td>
<td></td>
<td><p>元素情報を指定する。表形式データ。</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>mass</p></td>
<td><p>対応する元素の質量を指定する。デフォルト値は原子単位であることに注意。</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id49">
<h3><span class="section-number">9.4.3. </span>計算結果の出力<a class="headerlink" href="#id49" title="この見出しへのパーマリンク"></a></h3>
<p>座標データはfile_names.dataファイルのF_DYNMによって指定されるファイルに各ステップでの座標値が出力されます。
その形式は、構造最適化の場合と同様です。</p>
<ul class="simple">
<li><p>原子座標</p></li>
</ul>
<p>原子座標は、構造緩和を行った場合と同様、file_names.data中のF_DYNM識別子によって指定されるファイル
(既定のファイル名はnfdynm.data)に記述されます。入力においてprintoutlevelブロックの下のiprivelocity変数の値を2以上にしていた場合
(分子動力学シミュレーションの場合はデフォルト値)、各原子の速度のデータも出力されます。速度のデータは、力のデータのあとに原子単位で出力されます。</p>
<ul class="simple">
<li><p>各ステップでのエネルギー</p></li>
</ul>
<p>各ステップでのエネルギーは、file_names.data中のF_ENF識別子によって指定されるファイル
(既定のファイル名はnfefn.data)に出力されます。サンプルによって得られる結果を以下に記します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>iter_ion、iter_total、etotal、ekina、econst、forcmx
   1      18     -7.8953179624     0.0000042358    -7.8953179624     0.0186964345
   2      30     -7.8953851218     0.0000665502    -7.8953185716     0.0183575424
   3      43     -7.8955768901     0.0002565396    -7.8953203505     0.0173392067
   4      56     -7.8958649874     0.0005418445    -7.8953231430     0.0156398790
   5      69     -7.8962052587     0.0008785990    -7.8953266596     0.0132645441
   6      83     -7.8965425397     0.0012120826    -7.8953304571     0.0102355854
   7      97     -7.8968179539     0.0014840140    -7.8953339398     0.0066063151
   8     111     -7.8969784478     0.0016420281    -7.8953364197     0.0024736141
   9     125     -7.8969875377     0.0016502900    -7.8953372478     0.0020111576
  10     139     -7.8968352058     0.0014992046    -7.8953360011     0.0066379641
  11     153     -7.8965440599     0.0012113794    -7.8953326806     0.0111430822
                          ...............................
                          ...............................
                          ...............................
</pre></div>
</div>
<p>一列目は原子座標の更新回数、二列目は電子のSCF計算の回数です。三列目は、系の内部エネルギー、
四列目は系の運動エネルギーです。五列目は系の内部エネルギーと運動エネルギーを足した値であり、エネルギー一定の分子動力学シミュレーションにおける保存量です。</p>
</section>
<section id="advanced-nvemd-section">
<span id="id50"></span><h3><span class="section-number">9.4.4. </span>使用方法：エネルギー一定の分子動力学シミュレーション<a class="headerlink" href="#advanced-nvemd-section" title="この見出しへのパーマリンク"></a></h3>
<p>エネルギー一定の分子動力学シミュレーションの入力パラメータ例です。</p>
<p>計算例題は、 <code class="code docutils literal notranslate"><span class="pre">samples/dynamics/molecular_dynamics/NVE</span></code> です。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>accuracy{
    cutoff_wf = 9.00 rydberg
    cutoff_cd = 36.00 rydberg
    num_bands = 8
    xctype = ldapw91
    force_convergence{
        max_force = 1.0e-8 Hartree/Bohr
    }
    initial_wavefunctions = matrix_diagon
    ksampling{
        mesh{
            nx = 4
            ny = 4
            nz = 4
        }
    }
    scf_convergence{
        delta_total_energy = 1e-12 Hartree
        succession = 3
    }
}
...
...
structure{
    unit_cell_type = primitive
    unit_cell{
        a_vector = 0.0000000000        5.1300000000        5.1300000000
        b_vector = 5.1300000000        0.0000000000        5.1300000000
        c_vector = 5.1300000000        5.1300000000        0.0000000000
    }
    atom_list{
        atoms{
            #tag element rx ry rz mobile
             Si 0.130 0.130 0.130 yes
             Si -0.130 -0.130 -0.130 yes
        }
    }
    element_list{
        #tag element atomicnumber
         Si 14
    }
}
...
...
structure_evolution{
    method = velocity_verlet
    dt = 100
}
...
...
</pre></div>
</div>
<p>この入力は、シリコン結晶の入力を少し変更したものとなっています。
atomsでは、各原子の“mobile”変数を“yes”と設定しています。ここを“no”あるいは“0”と設定すると、その原子は
分子動力学シミュレーションを行っても動くことはありません。さらに座標値をあえて安定でない値にしています。
具体的には、Si結晶の二つの原子を(111)方向にお互いから離れるように少しだけずらしています。</p>
<section id="id51">
<h4><span class="section-number">9.4.4.1. </span>手法の選択<a class="headerlink" href="#id51" title="この見出しへのパーマリンク"></a></h4>
<p>structure_evolutionブロックでは、“method”変数を“velocity_verlet”としています。この選択によって小正準集合の分子動力学シミュレーションを行うことができます。また、各ステップでの更新量(変数dt)を、原子単位で“100”としてい 上で述べたようにこの値は <span class="math notranslate nohighlight">\(2.418 \times 10^{-15}\)</span> sに相当します。</p>
<p>初期速度の与え方</p>
<p>ここまで説明したサンプルの入力を利用すると、原子の初期速度は全て0と設定されます。
原子に初期速度を与える場合、下記のような入力を準備してください。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>structure_evolution{
    method = velocity_verlet
    dt  = 100
    temperature_control{
        thermostat{
            #tag temp
                 300
        }
    }
}
</pre></div>
</div>
<p>ここで、“temp”変数で初期の温度をケルビン単位で設定します。原子の初期速度は、この温度になるように、
かつ正規乱数に従って、全運動量が0になるように設定されます。</p>
<p>原子ごとに異なる初期温度を設定することも可能です。この場合、まず下記のような入力を作成します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>structure_evolution{
    method = velocity_verlet
    dt  = 100
    temperature_control{
        thermostat{!#tag temp
                         300
                         500
                         700
        }
    }
}
</pre></div>
</div>
<p>次にatomsの各原子に、“thermo_group”という変数を設定します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>structure{
    ...
    atom_list{
        atoms{
        !#tag rx ry rz  element mobile weight  thermo_group
   0.1159672611      0.1235205209      0.1215156388    Si   1   1  1
  -0.1329067626     -0.1264216714     -0.1225370484    Si   1   1  2
   0.1273740089      0.6305999369      0.6247606249    Si   1   1  3
            ...
            ...
        }
    }
    ...
}
</pre></div>
</div>
<p>この例では一番目の原子が300Kに、二番目の原子が500Kに、
三番目の原子が700Kになるよう初期速度が設定されます。</p>
</section>
<section id="id52">
<h4><span class="section-number">9.4.4.2. </span>計算結果の例<a class="headerlink" href="#id52" title="この見出しへのパーマリンク"></a></h4>
<p>この計算例の計算結果の内部エネルギー、運動エネルギー、全エネルギーを <a class="reference internal" href="#advanced-md-fig1"><span class="std std-numref">図 9.25</span></a> に示します。</p>
<figure class="align-default" id="advanced-md-fig1">
<a class="reference internal image-reference" href="../_images/image98.svg"><img alt="../_images/image98.svg" src="../_images/image98.svg" width="300pt" /></a>
<figcaption>
<p><span class="caption-number">図 9.25 </span><span class="caption-text">内部エネルギー、運動エネルギー、全エネルギーと時間の関係。</span><a class="headerlink" href="#advanced-md-fig1" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
</section>
</section>
<section id="advanced-nvtmd-section">
<span id="id53"></span><h3><span class="section-number">9.4.5. </span>使用方法：温度一定の分子動力学シミュレーション<a class="headerlink" href="#advanced-nvtmd-section" title="この見出しへのパーマリンク"></a></h3>
<p>温度一定の分子動力学シミュレーションの入力パラメータ例です。</p>
<p>計算例題は、 <code class="code docutils literal notranslate"><span class="pre">samples/dynamics/molecular_dynamics/NVT</span></code> です。</p>
<section id="id54">
<h4><span class="section-number">9.4.5.1. </span>熱浴の設定<a class="headerlink" href="#id54" title="この見出しへのパーマリンク"></a></h4>
<p>structure_evolutionブロックにtemperature_controlブロックを指定します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>structure_evolution{
    method = temperature_control
    dt  = 50.0
    temperature_control{
        thermostat{
            #tag temp  qmass tdamp
                 300   5000 10000
        }
    }
}
</pre></div>
</div>
<p>上記の入力例では、まず“method”変数をtemperature_controlとしています。この変数によって温度制御を行うように指定します。
ついで、“dt”変数を設定しています。これは、時間刻みの指定です。原子単位で入力します。例で示されている50.0という値は、
約1.2fsに相当します。</p>
<p>さらに、temperature_controlブロックで熱浴の設定を行っています。
“thermostat”ブロックで各熱浴のパラメタを設定します。“temp”パラメタによってその熱浴の目的とする温度(ケルビン単位)、
“qmass”パラメターによって熱浴の質量(原子単位)を設定します。“qmass”パラメータによって質量を直接指定するのではなく、“tdamp”パラメーター（時間の単位）によって熱浴の周期を指定し間接的に熱浴の質量を設定することも可能です。“qmass”と“tdamp”が両方設定されている場合、“qmass”が優先されます。また、いずれの指定もない場合50×dtの周期が実現するように熱浴の質量が設定されます。</p>
</section>
<section id="id55">
<h4><span class="section-number">9.4.5.2. </span>熱浴の割り当て<a class="headerlink" href="#id55" title="この見出しへのパーマリンク"></a></h4>
<p>structure ブロックの、atoms
ブロックを設定する必要があります。設定例を以下に記します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>structure{
     ...
    atom_list{
        num_atoms = 8
        cooordinate_system = internal
        atoms{
        !#tag rx ry rz  element mobile weight  thermo_group
   0.1159672611      0.1235205209      0.1215156388    Si   1   1  1
  -0.1329067626     -0.1264216714     -0.1225370484    Si   1   1  1
   0.1273740089      0.6305999369      0.6247606249    Si   1   1  1
  -0.1152089939     -0.6164829779     -0.6221565128    Si   1   1  1
   0.6299472943      0.1341313888      0.6253193197    Si   1   1  1
  -0.6305720382     -0.1290073650     -0.6187967685    Si   1   1  1
   0.6151271805      0.6206113965      0.1333834419    Si   1   1  1
  -0.6276524003     -0.6268549639     -0.1175099372    Si   1   1  1
        }
    }
    ...
}
</pre></div>
</div>
<p>各原子に“thermo_group”パラメータを割り振っています。このパラメータに
熱浴の識別番号を設定します。なお、熱浴の識別番号は熱浴の定義順に割り振られます。また、他の属性値と同様、“#default”
タグを利用することによってデフォルト値を設定することも可能です。ここの例では全ての原子に同じthermo_groupを設定していますが、
各原子が異なる熱浴に関連付けられていても問題ありません。</p>
</section>
<section id="id56">
<h4><span class="section-number">9.4.5.3. </span>熱浴の“段数”の設定 (バージョン2019.01以降)<a class="headerlink" href="#id56" title="この見出しへのパーマリンク"></a></h4>
<p>通常の熱浴をさらに熱浴で制御する、という計算手法がNosé-Hoover
chain法です <a class="reference internal" href="#glenn92" id="id57"><span>[Glenn92]</span></a>
何段にもわたって再帰的に適用することも可能となっています。Nosé-Hoover
chain法を用いることによって、より少ないステップ数で熱浴が平衡状態に至ることなどが期待できます。利用するためには、以下のようにtemperature_controlブロックにおいてnum_chain変数を使います。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>structure_evolution{
    method = temperature_control
    dt  = 50.0
    temperature_control{
      num_chain = 5
      thermostat{
          #tag temp  qmass tdamp
               300   5000 10000
      }
    }
}
</pre></div>
</div>
<p>理論的には各段数における熱浴の質量を別途設定することも可能ですが、最初の熱浴の質量以外結果にほとんど影響を与えないため、のこりの熱浴の質量としてはPHASE/0が最初の熱浴の質量から自動的に算出した値が採用されるようになっています。</p>
<p>num_chainのデフォルト値は1, すなわち通常のNosé-Hoover法です。</p>
</section>
<section id="id58">
<h4><span class="section-number">9.4.5.4. </span>“温度プロファイル”の設定 (バージョン2019.01以降)<a class="headerlink" href="#id58" title="この見出しへのパーマリンク"></a></h4>
<p>シミュレーションの進行とともに入力パラメーターファイルの指定に応じてターゲット温度を変化させる分子動力学シミュレーションを行うことができます。変化のさせ方を“温度プロファイル”と呼びます。温度プロファイル機能を利用するためには、まずtemperature_controlブロックにおいてsw_temperature_profile
=
onとします。さらに、thermostatブロックにおいて温度プロファイルの設定を行います。温度プロファイル機能を利用していない場合thermostatブロックにおいて定義するテーブルの行は一つの熱浴を表しますが、利用している場合はテーブルの行は一つのプロファイルを表すことに注意が必要です。温度プロファイル機能を利用している場合にさらに複数の熱浴を定義するためには、属性値no
(id,
thermo_groupも可)によって切り分けます。具体的には、たとえば下記に示すようになります。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>structure_evolution{
  ...
  ...
  temperature_control{
    sw_temperature_profile = on
    thermostat{
      #tag no tempi tempf till_n tdamp
          1 8000 8000 3000 5000
          1 8000 300 7000 5000
          2 400 500 1000 5000
    }
  }
}
</pre></div>
</div>
<p>上述のように属性値noによって熱浴を指定します。tempi, tempfはそれぞれ初期温度および終温度に対応する属性値です。till_nは、この温度プロファイルが適用されるステップ数です。属性値tdampによって熱浴の緩和時間を指定します。tdampのかわりに属性値qmassを使って熱浴の質量を直接指定することも可能です。以上より、この例ではthermostatテーブルの各行は次のように解釈されます。</p>
<ul class="simple">
<li><p>1行目：1つ目の熱浴の温度を8000Kで3000ステップ適用する。</p></li>
<li><p>2行目：1つ目の熱浴の温度を8000Kから300Kまで7000ステップかけて降温する (プロファイル終了時点で総MDステップ数10000)。以降は300Kのまま進行する。</p></li>
<li><p>3行目：2つ目の熱浴の温度を400Kから500Kまで1000ステップかけて昇温する。以降は500Kのまま進行する。</p></li>
</ul>
<p>なお、最後のプロファイルのtill_n以降は、そのプロファイルのtempfの温度が使い続けられる仕様になっています。</p>
</section>
<section id="section-md-langevin">
<span id="id59"></span><h4><span class="section-number">9.4.5.5. </span>ランジュバン熱浴の設定(バージョン2021.02以降)<a class="headerlink" href="#section-md-langevin" title="この見出しへのパーマリンク"></a></h4>
<p>ランジュバン熱浴の運動方程式は次の様に定義することができます。</p>
<div class="math notranslate nohighlight" id="equation-eq-md-langevin1">
<span class="eqno">(9.11)<a class="headerlink" href="#equation-eq-md-langevin1" title="この数式へのパーマリンク"></a></span>\[\begin{split}\dot{r}_i = p_i/m_i \\ \dot{p}_i = F_i - \gamma_i p_i + \sqrt{\frac{2m_i\gamma_ik_B T}{\Delta t}} R\left(t\right) \\ \left&lt; R\left(t\right) \right&gt; = 0, \left&lt; R\left(t\right) R\left(t^\prime \right)\right&gt; = \delta \left(t-t^\prime \right)\end{split}\]</div>
<p><span class="math notranslate nohighlight">\(\gamma_i\)</span> は時間の逆数の単位を持つ量で、摩擦係数のような役割を果たします。これは、能勢フーバー熱浴の緩和時間（もしくは質量）に対応するものであり、デフォルト値が設定されていますが入力パラメーターファイルを通じて指定することもできます。<span class="math notranslate nohighlight">\(R\left(t\right)\)</span> はランダム力であり、原子に加えることによって最終的には所定の温度へ至るように動作します。
<span class="math notranslate nohighlight">\(\left&lt;R\left(r\right)\right&gt;\)</span> は分散1, 中心0の正規乱数によって評価します。</p>
<p>ランジュバン熱浴を利用するには、たとえば以下のように設定します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>structure_evolution{
  method = velocity_verlet
  temperature_control{
    method = langevin
    thermostat{
      #tag temp tdamp
               300   5000
    }
  }
}
</pre></div>
</div>
<p>structure_evolutionにおいてmethodをvelocity_verletとし、temperature_controlブロックのmethodをlangevinに設定するとランジュバン熱浴を利用することができます。ランジュバン熱浴の摩擦係数 <span class="math notranslate nohighlight">\(\gamma_i\)</span> はこれまでの熱浴の緩和時間指定と同じ方法で行います。すなわち、緩和時間を直接もしくは熱浴の質量を通じて間接的に指定します。
熱浴に属する原子の指定方法などはこれまでの方法と同様です。</p>
<p>ランジュバン熱浴は統計力学を直接適用するような熱浴であり、能勢フーバー法と比較して統計力学的により尤もらしい集団の計算が実現できる場合があります。
例として、ダイヤモンドの結晶を用いてランジュバン熱浴と能勢フーバー熱浴双方で計算を行い、結果を比較してみました。</p>
<p>用いた系はダイアモンド64原子の系です。カットオフエネルギーは25 Rydberg, <span class="math notranslate nohighlight">\(\textbf{k}\)</span> 点サンプリングは <span class="math notranslate nohighlight">\(\Gamma\)</span> 点のみとしました。時間刻みは1 fsとし、緩和時間としてはデフォルト値(時間刻みの50倍)を採用しました。合計1万ステップの分子動力学シミュレーションを実施しました。</p>
<p><a class="reference internal" href="#advanced-langevin-fig1"><span class="std std-numref">図 9.26</span></a> にシミュレーションの結果得られた運動エネルギーの履歴を示しました。この図から明らかなように、ランジュバン熱浴によるシミュレーションではターゲット温度に相当する運動エネルギー（図中の黒い水平線）に
はやい段階で達しています。また、能勢フーバー熱浴の結果と比較すると運動エネルギーの振幅も小さい傾向です。結晶の計算の場合ランダムな作用による減衰が少ないため決定論的な能勢フーバー熱浴を用いると人工的な振動が減衰しにくい傾向がありますが、
ランジュバン熱浴の場合はそもそもがランダム力を付与しているため、「ランダムな作用による減衰」が発生しやすい影響が現れた結果と考えられます。</p>
<figure class="align-default" id="advanced-langevin-fig1">
<img alt="../_images/langevin_image1.svg" src="../_images/langevin_image1.svg" /><figcaption>
<p><span class="caption-number">図 9.26 </span><span class="caption-text">運動エネルギーの履歴。赤：ランジュバン熱浴、緑：能勢フーバー熱浴。</span><a class="headerlink" href="#advanced-langevin-fig1" title="この画像へのパーマリンク"></a></p>
<div class="legend">
<p><a class="reference internal" href="#advanced-langevin-fig2"><span class="std std-numref">図 9.27</span></a> には運動エネルギーの分布を示します。カノニカルアンサンブルの場合、運動エネルギーはマクスウェルボルツマン分布に従うはずです。運動エネルギーのマクスウェルボルツマン分布は以下のように記述することができます。</p>
</div>
</figcaption>
</figure>
<div class="math notranslate nohighlight" id="equation-eq-md-langevin2">
<span class="eqno">(9.12)<a class="headerlink" href="#equation-eq-md-langevin2" title="この数式へのパーマリンク"></a></span>\[f\left(K\right) = \frac{2}{\pi} \frac{1}{\left(k_B T \right)^\frac{3}{2}} \sqrt{K} \exp{\left(-\frac{K}{k_B T}\right)}\]</div>
<p>比較のため、 <a class="reference internal" href="#equation-eq-md-langevin2">(9.12)</a> 式の分布も <a class="reference internal" href="#advanced-langevin-fig2"><span class="std std-numref">図 9.27</span></a> にプロットしました。一見して明らかなように、ランジュバン熱浴の方がマクスウェルボルツマン分布によく従う分布となっています。
これもやはりランダム力を取り入れているがゆえのモードの減衰が要因と考えられます。</p>
<figure class="align-default" id="advanced-langevin-fig2">
<img alt="../_images/langevin_image2.svg" src="../_images/langevin_image2.svg" /><figcaption>
<p><span class="caption-number">図 9.27 </span><span class="caption-text">運動エネルギー分布。赤丸：ランジュバン熱浴、緑丸：能勢フーバー熱浴、黒線：マクスウェルボルツマン分布</span><a class="headerlink" href="#advanced-langevin-fig2" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
</section>
</section>
<section id="section-npt-md">
<span id="id60"></span><h3><span class="section-number">9.4.6. </span>使用方法：温度・圧力一定の分子動力学シミュレーション<a class="headerlink" href="#section-npt-md" title="この見出しへのパーマリンク"></a></h3>
<p>PHASE/0は、 <a class="reference internal" href="#souza97" id="id61"><span>[Souza97]</span></a> , <a class="reference internal" href="#hernandez01" id="id62"><span>[Hernandez01]</span></a> などの文献において解説されている手法によって圧力一定の分子動力学シミュレーションを行うことができます。</p>
<section id="id63">
<h4><span class="section-number">9.4.6.1. </span>入力パラメーターファイルの書き方<a class="headerlink" href="#id63" title="この見出しへのパーマリンク"></a></h4>
<p>まず、温度一定の分子動力学シミュレーションと同様の手続きで入力パラメーターファイルを作成します。通常の温度一定の場合との違いは、圧力も一定であること、また圧力浴の設定が必要なことの2点です。以下に例を示します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>structure_evolution{
  method = temperature_pressure_control
  dt = 50.0
  temperature_control{
    num_thermostat = 1
    set_initial_velocity = on
    !!method = velocity_scaling
    thermostat{
      #tag temp qmass
            300 4000
    }
  }
  pressure_control{
    pressure = 0.0
    mass_baro = 1
    m11 = on
    m22 = on
    m33 = on
    m12 = on
    m13 = on
    m23 = on
    barostat{
      #units gpa
      #tag till_n pressi pressf
      10000 0 2
    }
  }
}
</pre></div>
</div>
<p>設定方法の詳細は、下記の通り。</p>
<ul class="simple">
<li><p>MD手法の選び方: methodにtemperature_pressure_controlもしくはpressure_temperature_controlを指定すると温度－圧力一定の分子動力学シミュレーション、すなわちNPT分子動力学シミュレーションを実行することができます。pressure_controlとすると圧力一定の分子動力学シミュレーション、すなわちNPH分子動力学シミュレーションを実行することができます。</p></li>
<li><p>温度制御の設定: 温度制御は、NVTの場合と同様temperature_controlブロックにおいて行います。ただし、NVTシミュレーションでは複数の熱浴を定義することが可能であるのに対し、NPTシミュレーションの場合に定義できる熱浴は一つのみである点に注意してください。また、method = velocity_scalingと指定することによって速度スケーリングによる温度制御を、method = langevinと指定することによってランジュバン熱浴を利用することもできます。指定がなければNosé-Poincaré熱浴が採用されます。</p></li>
<li><p>圧力制御の設定:圧力制御は、pressure_controlブロックを作成し、その下で設定します。pressureに目的の圧力を指定します。圧力の単位のデフォルト値は原子単位ですが、GPaなどを利用することもできます。mass_baroには熱浴の質量を指定します。デフォルト値は1であり、単位の指定はできません。目安としては、熱浴の周期（単位胞の体積変化の周期）が100 MDステップ相当程度の時間になるように決めるとよいでしょう。</p></li>
<li><p>pressure_controlブロックの下のmethodによって圧力制御の方法を選択することができます。method = volumeとすると単位胞の体積のみが変化し、セルベクトル間の角度は不変になります。method = lattice_vectorとするとセルベクトルを直接制御するようになります。method = metric_tensorとすると「計量テンソル」を介して単位胞を制御します。デフォルト値はmetric_tensorです。</p></li>
<li><p>pressure_controlブロックの下にbarostatブロックを作成し、「圧力プロファイル」の設定を行うことができます。上述の例では10000ステップかけてターゲット圧力が0 GPaから2 GPaに変化します。このブロックがない場合「圧力プロファイル」は有効になりません。</p></li>
<li><p>計量テンソルに対する拘束条件の設定 : m<em>xy</em>パラメーターによって、計量テンソルの変化に対して拘束条件を課すことができます。たとえばm11 = offとすると11成分(<em>a</em>軸・<em>a</em>軸)が変化しなくなり、m12 = onならば12成分(<em>a</em>軸・<em>b</em>軸)および21成分(<em>b</em>軸・<em>a</em>軸)が変化しなくなります。このパラメーターのデフォルト値はすべてonなので、特に指定がなければ計量テンソルのすべての成分が変化します。</p></li>
</ul>
</section>
<section id="id64">
<h4><span class="section-number">9.4.6.2. </span>計算結果<a class="headerlink" href="#id64" title="この見出しへのパーマリンク"></a></h4>
<p>NPTシミュレーション結果で得られる主な出力ファイルは、エネルギーなどの履歴を記録したnfefn.dataファイル、座標データの履歴を記録したnfdynm.dataファイル、計量テンソルの履歴を記録したnfmetric.dataファイル、そして格子定数の履歴を記録したnflatconst.dataファイルである。それぞれについて説明する。</p>
<p>nfefn.dataファイル</p>
<p>エネルギーなどの履歴を記録したファイルであり、構造最適化やNVTのMDシミュレーションの場合も得られます。NPTシミュレーションの場合、以下のような出力が得られます。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>iter_ion, iter_total, etotal, ekina, econst, pressure
 1  13 -31.8045273788 300.0000000000 0.0000000000 0.0209863336 -0.0000504658
 2  25 -31.8045248143 301.4440100456 0.0000586853 0.0211839341 -0.0000573770
 3  37 -31.8043935680 299.1271868912 0.0001085792 0.0214781523 -0.0000574428
 4  49 -31.8041402859 293.2700519011 0.0001476826 0.0218951630 -0.0000570036
 5  61 -31.8037768714 284.3267516440 0.0001733906 0.0224437768 -0.0000560637
 6  73 -31.8033194235 272.9264725662 0.0001832795 0.0231125156 -0.0000546420
 7  85 -31.8027870051 259.8057152864 0.0001752150 0.0238698884 -0.0000527691
 8  97 -31.8022003504 245.7426304561 0.0001475268 0.0246685850 -0.0000504870
 9 109 -31.8015806171 231.5028071591 0.0000992076 0.0270606007 -0.0000478460
10 121 -31.8008921515 217.8018629938 0.0000862100 0.0294678421 -0.0000449028
11 133 -31.8002640917 205.3149756742 0.0000004873 0.0315593847 -0.0000420615
...
...
</pre></div>
</div>
<p>一行が1タイムステップのデータに相当します。1列目が原子（単位胞）の更新回数、2列目がSCF計算の総更新回数、3列目が系のエネルギー（原子単位）、4列目が瞬間的な温度（ケルビン単位）、5列目がハミルトニアン（原子単位）、6列目が原子に働く力の最大値（原子単位）、7列目が瞬間的な圧力です（すべて原子単位）。ハミルトニアンは理想的には保存するはずですが、第一原理計算においてエネルギーに対する歪みテンソルの厳密な微分を求めることは困難なため、保存がよくない傾向にある点に注意してください。</p>
<p>nfdynm.dataファイル</p>
<p>基本的なファイルフォーマットは、通常のnfdynm.dataファイルと同じです。ただし、NPTシミュレーションの場合毎ステップ格子定数が変化するので、格子定数などが記述されるヘッダー部が毎ステップ書き込まれる点に違いがあります。</p>
<p>nfmetric.dataファイル</p>
<p>各ステップにおける計量テンソルが記録されるファイルです。典型的な内容は下記の通り。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>2
105.8775163849 0.0064685429 -0.0017420207
0.0064685429 105.8774556260 0.0027757249
-0.0017420207 0.0027757249 105.8776712432
3
105.8648537936 0.0196786348 -0.0055233812
0.0196786348 105.8644796107 0.0091955626
-0.0055233812 0.0091955626 105.8652454083
4
105.8462013539 0.0389223098 -0.0123434716
0.0389223098 105.8452005929 0.0190717120
-0.0123434716 0.0190717120 105.8468474757
</pre></div>
</div>
<p>まずステップ数を表わす整数値が記録され、ついで3×3のテンソルが記録されます。なお、半ステップずれた数値解法を採用しているため、記録は2ステップ目からとなります。</p>
<p>nflatconst.dataファイル</p>
<p>各ステップにおける格子定数が記録されるファイルです。典型的な内容は下記の通り。なお、紙幅の都合で1行を改行して表示している</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>2 10.2896800915 10.2896771391 10.2896876164 89.9984979129 90.0009426965 89.9964995371 1089.4462540511
3 10.2890647677 10.2890465841 10.2890837983 89.9950232125 90.0029893382 89.9893495841 1089.2504025643
4 10.2881583072 10.2881096705 10.2881897084 89.9896762432 90.0066816443 89.9789308011 1088.9605527024
5 10.2869678503 10.2868710406 10.2870094050 89.9825817981 90.0125180935 89.9656805224 1088.5783846407
6 10.2855038285 10.2853392827 10.2855504459 89.9738915620 90.0209385359 89.9500901373 1088.1067192172
7 10.2837804786 10.2835276570 10.2838245727 89.9637869404 90.0323061920 89.9327006608 1087.5497224800
8 10.2818163114 10.2814547573 10.2818483397 89.9524812878 90.0468878988 89.9140944258 1086.9130916478
9 10.2796344063 10.2791449593 10.2796435437 89.9402204612 90.0648344761 89.8948814720 1086.2041781879
</pre></div>
</div>
<p>一行が1タイムステップのデータに相当します。1列目は単位胞の更新回数、2列目から7列目がそれぞれ格子定数,
最後の8列目が単位胞の体積です。長さの単位はBohr単位、角度の単位は度、体積の単位はBohr<sup>3</sup>です。</p>
</section>
</section>
<section id="id65">
<h3><span class="section-number">9.4.7. </span>分子動力学シミュレーションにまつわるその他の設定<a class="headerlink" href="#id65" title="この見出しへのパーマリンク"></a></h3>
<section id="id66">
<h4><span class="section-number">9.4.7.1. </span>速度スケーリングによる温度制御の分子動力学シミュレーション<a class="headerlink" href="#id66" title="この見出しへのパーマリンク"></a></h4>
<p>Nos<span class="math notranslate nohighlight">\(\acute{e}\)</span>-Hooverの熱浴ではなく、原子の速度を温度が合うようにスケールし直すことによって温度を制御することも可能です。このような計算は、temperature_controlブロックの下のmethod変数をvelocity_scalingとすることによって実現することができます。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>structure_evolution{
  ...
  temperature_control{
    method = velocity_scaling
    ...
  }
}
</pre></div>
</div>
<p>速度は、目的の温度に合うよう毎MDステップスケールされます。</p>
</section>
<section id="id67">
<h4><span class="section-number">9.4.7.2. </span>全運動量がゼロになるよう速度をシフトする方法<a class="headerlink" href="#id67" title="この見出しへのパーマリンク"></a></h4>
<p>分子動力学シミュレーションにおいて理論上全運動量は保存します（ゼロになる）が、実際は数値誤差によりゼロとはならず、系全体が並進してしまう場合があります。これを防ぐには、以下のように変数sw_shift_velocitiesの値をonとし、MD計算中全運動量がゼロとなるようにします。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>structure_evolution{
  ...
  temperature_control{
    ...
    sw_shift_velocities = on
  }
}
</pre></div>
</div>
</section>
<section id="id68">
<h4><span class="section-number">9.4.7.3. </span>原子の初期速度を手動で指定する方法<a class="headerlink" href="#id68" title="この見出しへのパーマリンク"></a></h4>
<p>原子の初期速度は通常ランダムな正規分布が得られ、対応する温度が設定した温度で、全運動量が0になるように自動的に決定されますが、手動で各原子に割り振ることも可能です。このような指定は、原子配置のvx, vy, vz属性値によって行います。また、設定した速度を上書きしてしまわないようtemperature_controlブロックの下においてsw_read_velocities = onを設定する必要があります。たとえば、以下のように設定します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>structure{
     ...
    atom_list{
        atoms{
        !#tag rx ry rz  element mobile thermo_group vx vy vz
            0.11    0.12    0.11    Si   1 1 0.001 0.0014 0.0008
           -0.13   -0.13   -0.14    Si   1 1 -0.001 -0.002 0.0001
            0.12    0.63    0.62    Si   1 1 0.0003 -0.0005 -0.00028
            ...
            ...
        }
    }
    ...
}
...
structure_evolution{
  ...
  temperature_control{
    sw_read_velocities = on
  }
}
</pre></div>
</div>
<p>なお、速度の単位のデフォルト値は原子単位です。</p>
<p>また、この方法で初期速度を指定した場合でも、デフォルトの設定では温度に合うよう、また全運動量が0になるよう速度はシフト・スケールされます。この動作を抑制したい場合、以下の要領で変数set_initial_velocityの値をoffとします。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>structure_evolution{
  ...
  temperature_control{
    sw_read_velocities = on
    set_initial_velocity = off
  }
}
</pre></div>
</div>
</section>
<section id="id69">
<h4><span class="section-number">9.4.7.4. </span>原子を領域に閉じ込める方法 (バージョン2019.01以降)<a class="headerlink" href="#id69" title="この見出しへのパーマリンク"></a></h4>
<p>矩形領域および円筒領域に閉じ込めることができます。このような計算機能は、狭い領域に閉じ込められた系の振る舞いを調べたり、ESM法やdipole補正法などアルゴリズムの都合上真空層が必須である機能において真空層に原子が入ってこられなくする目的で利用することができます。</p>
<p>入力の記述</p>
<p>領域は、structureブロックのregion<em>x</em>ブロックにおいて定義することができます。ここで<em>x</em>は領域の識別番号です。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>structure
  region1{
    region_group = 1
    type = cylinder
    radius = 3.5 angstrom !半径
    cylx = 5 angstrom
    cyly = 5 angstrom ! 円筒の中心位置
    orientation = 3 ! 円筒の向き
    cylzmin = -1000 ! 円筒の下端
    cylzmax = 1000 ! 円筒の上端
    sw_tally = on ! エネルギーを加える
    eps = 0.001 !ポテンシャルの深さ
    sigma = 1.5 !距離のスケール
  }
}
</pre></div>
</div>
<p><em>x</em>は1から始まります。<em>x</em>を2, 3,
…とすることによって任意の数の領域を定義することができます。region<em>x</em>ブロックにおいて以下の変数を設定することによって領域を定義します。</p>
<table class="longtable docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>変数名</p></th>
<th class="head"><p>説明</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>region_group</p></td>
<td><p>“領域のグループ”を整数で指定します。この値が同じ領域はひとかたまりの“グループ”として扱われます。後述の原子配置テーブルの属性値region_groupにこの数値を指定することによって領域グループと原子を紐づけます。デフォルト値はregion<em>x</em>ブロックの<em>x</em>の値です。</p></td>
</tr>
<tr class="row-odd"><td><p>type</p></td>
<td><p>領域の種類を指定します。</p>
<p>cylinder (円筒型)もしくはbox
(直方体型)とします。デフォルト値はboxです。</p>
</td>
</tr>
<tr class="row-even"><td><p>radius</p></td>
<td><p>円筒の半径を指定します。デフォルト値は6.5bohrです。type=cylinderの場合のみ意味のある設定です。</p></td>
</tr>
<tr class="row-odd"><td><p>cylx</p></td>
<td><p>円筒の中心位置の<em>x</em>座標を指定します。デフォルト値はセルの境界です。type=cylinderの場合のみ意味のある設定です。</p></td>
</tr>
<tr class="row-even"><td><p>cyly</p></td>
<td><p>円筒の中心位置の<em>y</em>座標を指定します。デフォルト値はセルの境界です。type=cylinderの場合のみ意味のある設定です。</p></td>
</tr>
<tr class="row-odd"><td><p>orientation</p></td>
<td><p>円筒の向きを指定します。1の場合<em>x</em>方向、2の場合<em>y</em> 方向、3の場合<em>z</em>方向に向きます。デフォルト値は3です。type=cylinderの場合のみ意味のある設定です。</p></td>
</tr>
<tr class="row-even"><td><p>cylzmin</p></td>
<td><p>円筒の長さ方向の下限を指定します。デフォルト値は－10 <sup>10</sup>です。type=cylinderの場合のみ意味のある設定です。</p></td>
</tr>
<tr class="row-odd"><td><p>cylzmax</p></td>
<td><p>円筒の長さ方向の上限を指定します。デフォルト値は10 <sup>10</sup>です。type=cylinderの場合のみ意味のある設定です。</p></td>
</tr>
<tr class="row-even"><td><p>xmin</p></td>
<td><p>直方体の<em>x</em> 方向の下限値を指定します。デフォルト値は－10 <sup>10</sup>です。type=boxの場合のみ意味のある設定です。</p></td>
</tr>
<tr class="row-odd"><td><p>xmax</p></td>
<td><p>直方体の<em>x</em>方向の上限値を指定します。
デフォルト値は10 <sup>10</sup>です。type=boxの場合のみ意味のある設定です。</p></td>
</tr>
<tr class="row-even"><td><p>ymin</p></td>
<td><p>直方体の<em>y</em>
方向の下限値を指定します。デフォルト値は－10<sup>10</sup>です。type=boxの場合のみ意味のある設定です。</p></td>
</tr>
<tr class="row-odd"><td><p>ymax</p></td>
<td><p>直方体の<em>y</em>方向の上限値を指定します。デフォルト値は10<sup>10</sup>です。type=boxの場合のみ意味のある設定です。</p></td>
</tr>
<tr class="row-even"><td><p>zmin</p></td>
<td><p>直方体の<em>z</em>
方向の下限値を指定します。
デフォルト値は－10<sup>10</sup>です。type=boxの場合のみ意味のある設定です。</p></td>
</tr>
<tr class="row-odd"><td><p>zmax</p></td>
<td><p>直方体の<em>z</em>方向の上限値を指定します。
デフォルト値は10<sup>10</sup>です。type=boxの場合のみ意味のある設定です。</p></td>
</tr>
<tr class="row-even"><td><p>sw_tally</p></td>
<td><p>領域に起因するエネルギーを全エネルギーに加える場合この値をonに設定します。</p></td>
</tr>
<tr class="row-odd"><td><p>eps</p></td>
<td><p>ポテンシャル<span class="math notranslate nohighlight">\(\varepsilon\left( \frac{
\sigma}{r} \right)^{12}\)</span>の<span class="math notranslate nohighlight">\(\varepsilon\)</span>の
値をエネルギーの単位で指定します。デフォルト値は1e-3
hartreeです。</p></td>
</tr>
<tr class="row-even"><td><p>sigma</p></td>
<td><p>ポテンシャル<span class="math notranslate nohighlight">\(\varepsilon
\left( \frac{\sigma}{r} \right)^{12}\)</span>の
<span class="math notranslate nohighlight">\(\sigma\)</span> の値を長さの単位で指定します。
デフォルト値は1 bohrです。</p></td>
</tr>
</tbody>
</table>
<p>定義した領域は、そのregion_idを紐づけたい原子のregion_idに指定することによって割り当てることができます。たとえば、以下のように設定します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>structure{
  …
  atom_list{
    coordinate_system = cartesian
    atoms{
      #default mobile=on,thermo_group=1
      #units angstrom
      #tag element rx ry rz region_group
            H 4.231707 4.904619 6.374683 1
            H 5.716594 4.994127 6.011627 1
            O 5.118193 4.883964 6.766158 1
            H 4.167342 5.876768 8.210465 2
            H 5.481543 5.259672 8.697061 2
            O 4.627457 5.590603 9.014168 2
            …
            …
    }
  }
}
</pre></div>
</div>
<p>この例では、1番目、2番目、3番目の原子はregion_group=1のすべての領域に紐づけられ、4番目、5番目、6番目の原子はregion_group=2のすべての領域に紐づけられます。</p>
<p>計算の実行</p>
<p>計算は、通常の分子動力学シミュレーションと同じように実行することができます。入力パラメーターファイルが読み込まれると以下のように読み込んだ領域の情報が報告されます。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>!** region statistics
!** num_regions = 1
!** status for region no 1
!** region type : CYLINDER
!** orientation : 3 (1-&gt;x, 2-&gt;y, 3-&gt;z)
!** radius : 6.6140409725
!** cylx,cyly : 9.4486299607 9.4486299607
!*cylzmin,cylzmax: -1.797693134862316E+308 1.797693134862316E+308
!** sigma, epsilon : 1.0000000000 0.0010000000
!** tally : F
!** n target atoms : 36
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
21 22 23 24 25 26 27 28 29 30 31 32 33 37 38 39
</pre></div>
</div>
<p>特に、n target
atoms以降領域に割り当てられている原子のリストが出力されるので、想定通り領域が設定できているかどうかを確認することができます。</p>
</section>
<section id="section-ion-dynamics-fix-bond">
<span id="id70"></span><h4><span class="section-number">9.4.7.5. </span>水素との結合を凍結する方法 (バージョン2022.01以降)<a class="headerlink" href="#section-ion-dynamics-fix-bond" title="この見出しへのパーマリンク"></a></h4>
<p>水素（H）原子は非常に軽量なため、MD 計算を実行する際に大きく動いて計算が破綻してしまうことがありますが、H 原子そのものが結合を切断・再結合するような反応でない限りは、H 原子と結合している原子との距離を固定しても問題ないケースは多いと考えられます。そこで、H原子と他の原子(X)との距離H-Xを固定して計算することができるようになっています。</p>
<p>結合固定機能を利用するためには、 <code class="docutils literal notranslate"><span class="pre">structure</span></code> ブロックの下に <code class="docutils literal notranslate"><span class="pre">fix_bond</span></code> ブロックを作成し、設定を施します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>structure{
  fix_bond{
    sw_fix_bond = on
  }
}
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">fix_bond</span></code> ブロックにおいては以下のような設定を施すことができます。</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 35.0%" />
<col style="width: 65.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>変数名</p></td>
<td><p>説明</p></td>
</tr>
<tr class="row-even"><td><p>target_element</p></td>
<td><p>結合とみなす対象の元素名を指定します。デフォルト値はH</p></td>
</tr>
<tr class="row-odd"><td><p>target_elementn</p></td>
<td><p>結合とみなす対象のn番目の元素名を指定します。デフォルト値はなく、この指定がない場合はtarget_elementで指定した元素が用いられます。</p></td>
</tr>
<tr class="row-even"><td><p>bond_factor</p></td>
<td><p>2原子が結合しているかどうかを判定するためのファクターです。2つの原子が(原子1の共有結合半径+原子2の共有結合半径)*bond_factor 以内の距離にある場合結合しているとみなされます。デフォルト値は1.2.</p></td>
</tr>
<tr class="row-odd"><td><p>max_iter_fix_bond</p></td>
<td><p>SHAKE法、RATTLE法の繰り返し計算回数の上限値です。デフォルト値は1000.</p></td>
</tr>
<tr class="row-even"><td><p>thres_fix_bond</p></td>
<td><p>SHAKE法、RATTLE法の収束判定条件。デフォルト値は1.e-10.</p></td>
</tr>
</tbody>
</table>
<p>計算を実行すると、検出した結合が以下の要領でログファイルに出力されます。意図した通りの結合が見つかっているかどうか確認することが推奨されます。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>!** number of bonds to be fixed during MD      48
!** bond no        1 assc. atoms        2       1 bond length    2.05521
!** bond no        2 assc. atoms        4       3 bond length    2.05523
!** bond no        3 assc. atoms        6       5 bond length    2.05522
!** bond no        4 assc. atoms        8       7 bond length    2.05521
...
...
</pre></div>
</div>
</section>
</section>
<section id="id71">
<h3><span class="section-number">9.4.8. </span>使用における注意点<a class="headerlink" href="#id71" title="この見出しへのパーマリンク"></a></h3>
<ul>
<li><p>分子動力学シミュレーション機能に特別な制約はありません。ウルトラソフトおよびPAW擬ポテンシャル、並列計算、継続計算に対応しています。
ただし、分子動力学シミュレーションにおいては原子の位置は熱揺らぎによって激しく振動するので、系が厳密な意味での対称性を持つことはありません。したがって、対称性関連の設定は施さないでください。</p></li>
<li><p>原子の質量は、通常の構造最適化においては直接系の性質を左右するものではありませんが、分子動力学シミュレーションの場合は意味のある量です。したがって、本機能を利用する場合は元素の正しい質量を指定する必要があります。PHASEにおける標準の質量の単位は、原子単位です。たとえば、陽子の質量は原子単位で1822.877333
です。</p></li>
<li><p>運動エネルギーはハートリー単位で記述されますが、
運動エネルギーと温度との間には<span class="math notranslate nohighlight">\(E_{\text{kin}} = \frac{3}{2} \times N_{\text{atom}} \times k_{B}T\)</span>
という関係があります。ここで運動エネルギーを<span class="math notranslate nohighlight">\(E_{\text{kin}}\)</span>、原子数を<span class="math notranslate nohighlight">\(N_{\text{atom}}\)</span>、ボルツマン定数を<span class="math notranslate nohighlight">\(k_{B}\)</span>、
瞬間的な温度を<span class="math notranslate nohighlight">\(T\)</span>と記述しました。従って運動エネルギーから系の温度を知りたい場合、まず運動エネルギーを原子数で割り、
<span class="math notranslate nohighlight">\(3.1578 \times 10^{5}\)</span>という値を掛けて(ハートリー単位から<span class="math notranslate nohighlight">\(k_{B}T\)</span>単位への変換)、さらに<span class="math notranslate nohighlight">\(\frac{3}{2}\)</span>で割って下さい。</p></li>
<li><p>原子座標の更新回数は入力で指定した時間刻みの値(structure_evolutionブロック内のdtという変数で指定)を掛けること
によって実時間での経過が分かります。時間の単位は入力で指定することが可能ですが、原子単位系を利用した場合(デフォルト)
<span class="math notranslate nohighlight">\(2.41888 \times 10^{- 17}\)</span>という値を掛ければ「秒」に変換することが可能です。たとえば100
a.u.という時間は2.41888 fsに相当します。</p></li>
<li><p>温度一定の分子動力学シミュレーションにおける、熱浴の質量<span class="math notranslate nohighlight">\(Q\)</span>の値について注意点を挙げます。
小さすぎる<span class="math notranslate nohighlight">\(Q\)</span>を採用すると、系のダイナミックスに熱浴に起因する
人為的なモードが生じてしまい、また場合によっては計算が破綻してしまいます。他方大きすぎる<span class="math notranslate nohighlight">\(Q\)</span>を採用すると、系が熱平衡に達するのに
多くのステップ数を必要とするようになってしまいます。</p>
<p><span class="math notranslate nohighlight">\(Q\)</span>の値は、系の特徴的な振動の周期と熱浴の振動の周期がおおよそ同等か、熱浴の方が長くなるように選ぶとよいとされています。
熱浴の振動の周期と系の振動の周期の間の関係は、大雑把には次の式で評価できます <a class="reference internal" href="#nose91" id="id72"><span>[Nose91]</span></a></p>
<p><span class="math notranslate nohighlight">\(\tau = \frac{2\pi}{\omega} = 2\pi\left( \frac{Q}{2gk_{B}T} \right)^{1/2}\)</span></p>
<p>ここで<span class="math notranslate nohighlight">\(\tau 、\omega\)</span>はそれぞれ系の周期と周波数、<span class="math notranslate nohighlight">\(g\)</span>は系の自由度(3<span class="math notranslate nohighlight">\(\times\)</span>その熱浴に関連付けられている原子の数)、<span class="math notranslate nohighlight">\(k_{B}\)</span>は
ボルツマン定数、<span class="math notranslate nohighlight">\(T\)</span>がその熱浴の温度です。例えば、<span class="math notranslate nohighlight">\(\tau\)</span>を0.05
ps、原子の数を8、温度を300
Kとして上式で<span class="math notranslate nohighlight">\(Q\)</span>の値を見積もると、原子単位でおおよそ4600程度となります。PHASE/0では、<span class="math notranslate nohighlight">\(Q\)</span>の値を直接指定することも、周期を介して間接的に指定することも可能となっています。質量の指定も周期の指定もない場合、周期が時間きざみdtのおおよそ50倍となる<span class="math notranslate nohighlight">\(Q\)</span>の値が採用されます。</p>
</li>
</ul>
<p><strong>参考文献</strong></p>
<div role="list" class="citation-list">
<div class="citation" id="glenn92" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id57">Glenn92</a><span class="fn-bracket">]</span></span>
<p>Glenn J. Martyna and Michael L. Klein, and Mark Tuckerman, “Nosé-Hoover chains: The canonical ensemble via continuous dynamics”, Journal of Chemical Physics <strong>97</strong> 15 (1992).</p>
</div>
<div class="citation" id="souza97" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id61">Souza97</a><span class="fn-bracket">]</span></span>
<p>Ivo Souza and JoséLuís Martins, Phys. Rev. B 55 (1997) pp  8733-8742.</p>
</div>
<div class="citation" id="hernandez01" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id62">Hernandez01</a><span class="fn-bracket">]</span></span>
<p>E. Hernández, Journal of Chemical Physics, 115 (2001) pp.  10282-10290.</p>
</div>
<div class="citation" id="nose91" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id72">Nose91</a><span class="fn-bracket">]</span></span>
<p>S. Nos<span class="math notranslate nohighlight">\(\acute{e}\)</span>、Progress of Theoretical Physics Supplement No 103、1991、pp.1-46.</p>
</div>
</div>
</section>
</section>
<section id="neb">
<span id="section-neb"></span><h2><span class="section-number">9.5. </span>NEB 法<a class="headerlink" href="#neb" title="この見出しへのパーマリンク"></a></h2>
<section id="id73">
<h3><span class="section-number">9.5.1. </span>機能の概要<a class="headerlink" href="#id73" title="この見出しへのパーマリンク"></a></h3>
<p>Nudged Elastic Band (NEB)法 <a class="reference internal" href="#mills94" id="id74"><span>[Mills94]</span></a> およびClimbing Image (CI)
NEB法 <a class="reference internal" href="#henkelman00" id="id75"><span>[Henkelman00]</span></a> は、反応経路における始状態と終状態の間の最小エネルギー経路と鞍点を求める方法です。</p>
<p>NEB法およびCI-NEB法を用いた反応経路計算においては、始状態の原子配置(<span class="math notranslate nohighlight">\({\overrightarrow{R}}_{0}\)</span>)および終状態の原子配置(<span class="math notranslate nohighlight">\({\overrightarrow{R}}_{N}\)</span>)が既知であるとして、始状態と終状態の間の中間状態(<span class="math notranslate nohighlight">\({\overrightarrow{R}}_{i},\ \ i = 2 \sim N - 1\)</span>)の原子配置やエネルギーなどを、隣接する状態(イメージ)間がばねによって結ばれているという拘束条件の下で構造最適化計算を行います。ここで<span class="math notranslate nohighlight">\({\overrightarrow{R}}_{i}\)</span>は、各イメージにおける<span class="math notranslate nohighlight">\(3 M\)</span>次元(<span class="math notranslate nohighlight">\(M\)</span>は原子数)の座標です。NEB法およびCI-NEB法の中間状態における初期原子配置は始状態と終状態から任意に決定することが可能ですが、始状態と終状態をイメージで等分割し決める方法が多くの場合採用されます。</p>
<ul class="simple">
<li><p>NEB法</p></li>
</ul>
<p>通常のNEB法においては、各イメージの作用力は次のように与えられます。</p>
<div class="math notranslate nohighlight" id="equation-advanced-neb-eq1">
<span class="eqno">(9.13)<a class="headerlink" href="#equation-advanced-neb-eq1" title="この数式へのパーマリンク"></a></span>\[{\overrightarrow{F}}_{i} = {\overrightarrow{F}}_{i}^{s}|_{\parallel} - \nabla E\left( {\overrightarrow{R}}_{i} \right)|_{\bot}.\]</div>
<p>ここで、<span class="math notranslate nohighlight">\({\overrightarrow{F}}_{i}^{s}|_{\parallel}\)</span>は隣接するイメージ間のバネによる作用力の接線方向の成分であり、以下のように求められます。</p>
<div class="math notranslate nohighlight" id="equation-advanced-neb-eq2">
<span class="eqno">(9.14)<a class="headerlink" href="#equation-advanced-neb-eq2" title="この数式へのパーマリンク"></a></span>\[{\overrightarrow{F}}_{i}^{s}|_{\parallel} = k\left( \left| {\overrightarrow{R}}_{i + 1} - {\overrightarrow{R}}_{i} \right| - \left| {\overrightarrow{R}}_{i} - {\overrightarrow{R}}_{i - 1} \right| \right) \cdot \widehat{\tau}\widehat{\tau}.\]</div>
<p>ここで<span class="math notranslate nohighlight">\(k\)</span>はバネ定数です。<span class="math notranslate nohighlight">\(\widehat{\tau}\)</span>は接線方向の単位ベクトルであり、次のように計算します。</p>
<div class="math notranslate nohighlight" id="equation-advanced-neb-eq3">
<span class="eqno">(9.15)<a class="headerlink" href="#equation-advanced-neb-eq3" title="この数式へのパーマリンク"></a></span>\[\widehat{\tau} = \frac{{\overrightarrow{R}}_{i} - {\overrightarrow{R}}_{i - 1}}{\left| {\overrightarrow{R}}_{i} - {\overrightarrow{R}}_{i - 1} \right|} + \frac{{\overrightarrow{R}}_{i + 1} - {\overrightarrow{R}}_{i}}{\left| {\overrightarrow{R}}_{i + 1} - {\overrightarrow{R}}_{i} \right|}.\]</div>
<p><a class="reference internal" href="#equation-advanced-neb-eq1">(9.13)</a> 式の<span class="math notranslate nohighlight">\(\nabla E\left( {\overrightarrow{R}}_{i} \right)|_{\bot}\)</span>は、第一原理計算などによって得られる、原子に働く力の接線に垂直な成分であり、以下のように求められます。</p>
<div class="math notranslate nohighlight" id="equation-advanced-neb-eq4">
<span class="eqno">(9.16)<a class="headerlink" href="#equation-advanced-neb-eq4" title="この数式へのパーマリンク"></a></span>\[\nabla E\left( {\overrightarrow{R}}_{i} \right)|_{\bot} = \nabla E\left( {\overrightarrow{R}}_{i} \right) - \nabla E\left( {\overrightarrow{R}}_{i} \right) \cdot \widehat{\tau}\widehat{\tau}.\]</div>
<ul class="simple">
<li><p>Climbing-image (CI) NEB法</p></li>
</ul>
<p>Climbing-image NEB (CI-NEB) 法は、通常のNEB法に対して最もエネルギーの高いイメージにおける作用力の計算方法を改良した方法です。CI-NEB法計算では、通常のNEB法を用いて反応経路計算をある程度進めた後に最も高いエネルギーのイメージ(<span class="math notranslate nohighlight">\({\overrightarrow{R}}_{i,\max}\)</span>)を決定し、<span class="math notranslate nohighlight">\({\overrightarrow{R}}_{i,\max}\)</span>に働く作用力を次のように計算します。</p>
<div class="math notranslate nohighlight">
\[{\overrightarrow{F}}_{i,\max} = - \nabla E\left( {\overrightarrow{R}}_{i,\max} \right) + 2\nabla E\left( {\overrightarrow{R}}_{i,\max} \right)\]</div>
<div class="math notranslate nohighlight" id="equation-advanced-neb-eq5">
<span class="eqno">(9.17)<a class="headerlink" href="#equation-advanced-neb-eq5" title="この数式へのパーマリンク"></a></span>\[= {\overrightarrow{F}}_{i,\max}|_{\bot} - {\overrightarrow{F}}_{i,\max}|_{\parallel}\]</div>
<p>通常のNEB法では遷移状態を正確に見つけることができないのに対し、CI-NEB法は最もエネルギーの高いイメージが収束判定の範囲内で遷移状態にあることに特長があります。</p>
<ul class="simple">
<li><p>バネ定数の計算方法</p></li>
</ul>
<p>最少遷移エネルギーを求める反応経路計算においては、鞍点付近の計算精度を高くすることが好ましいと考えられます。このことから、鞍点付近でイメージの密度を高くし、接線の傾きを高い精度で求める必要があります。特に、反応経路全体と比較してポテンシャル障壁の領域が極めて狭い場合には、ポテンシャル障壁近傍のイメージ密度を高くすることにより高精度の計算を効率よく行うことが可能となります。
最少エネルギー経路において鞍点付近にイメージを密に分布させる方法として、鞍点付近のバネ定数<span class="math notranslate nohighlight">\(k\)</span>を大きくする方法が考えられています。NEB法およびCI-NEB法における作用力は、バネによる作用力とエネルギー計算によって得られた作用力の線形結合で表わさせれるので、イメージ間のバネ定数は異なる値を選択することが可能です。バネ定数の設定方法としては、以下のエネルギーの線形関数が提唱されています。</p>
<div class="math notranslate nohighlight">
\[k = k_{\max} - \Delta\left( \frac{E_{\max} - E_{i}}{E_{\max} - E_{\text{ref}}} \right)\text{    }\left( E_{i} \geq E_{\text{ref}}の場合 \right),\]</div>
<div class="math notranslate nohighlight" id="equation-advanced-neb-eq6">
<span class="eqno">(9.18)<a class="headerlink" href="#equation-advanced-neb-eq6" title="この数式へのパーマリンク"></a></span>\[k = k_{\max} - \Delta\text{k                        }\left( E_{i} &lt; E_{\text{ref}}の場合 \right).\]</div>
<p>ここで、<span class="math notranslate nohighlight">\(k_{\max}\)</span>はバネ定数の最大値、<span class="math notranslate nohighlight">\(\Delta k\)</span>はバネ定数の最大値と最小値の差です。<span class="math notranslate nohighlight">\(E_{i}\)</span>は<span class="math notranslate nohighlight">\(i\)</span>番目のバネで結ばれた2つのイメージのうち高いエネルギーのイメージのエネルギー、<span class="math notranslate nohighlight">\(E_{\max}\)</span>は全イメージ中最も高いエネルギー、<span class="math notranslate nohighlight">\(E_{\text{ref}}\)</span>は始状態と終状態のうち、高い方のエネルギーです。この<span class="math notranslate nohighlight">\(E_{\text{ref}}\)</span>の値の設定によって、反応経路における始状態付近と終状態付近のイメージ密度が等しくなります。</p>
<ul class="simple">
<li><p>バネの垂直成分</p></li>
</ul>
<p>連続するレプリカがなす角度が大きいと計算が安定しない場合があります。このような場合にバネによる作用力の垂直成分を少し加えることによって安定した計算が行えるようになります。この場合、以下の要領で3つのレプリカが成す角度によるペナルティ関数によって垂直成分を加えます。</p>
<div class="math notranslate nohighlight" id="equation-advanced-neb-eq7">
<span class="eqno">(9.19)<a class="headerlink" href="#equation-advanced-neb-eq7" title="この数式へのパーマリンク"></a></span>\[{\overrightarrow{F}}_{i} = {\overrightarrow{F}}_{i}^0 + f\left( \phi \right) \left( {\overrightarrow{F}}_{i}^{s} - {\overrightarrow{F_{i}^{s}}} \cdot \widehat{\tau} \widehat{\tau} \right)\]</div>
<div class="math notranslate nohighlight" id="equation-advanced-neb-eq8">
<span class="eqno">(9.20)<a class="headerlink" href="#equation-advanced-neb-eq8" title="この数式へのパーマリンク"></a></span>\[f\left( \phi \right) = \frac{1}{2} \left( 1 + \cos{\left( \pi \left( \cos{\phi} \right) \right)} \right)\]</div>
<p>ここで <span class="math notranslate nohighlight">\({\overrightarrow{F}}_{i}^0\)</span> がもとのNEB力、 <span class="math notranslate nohighlight">\(\phi\)</span> が3つのレプリカが成す角度です。ペナルティ関数は角度が90°の場合に1, 0°の場合は0になります。</p>
</section>
<section id="id76">
<h3><span class="section-number">9.5.2. </span>入力パラメータ<a class="headerlink" href="#id76" title="この見出しへのパーマリンク"></a></h3>
<section id="id77">
<h4><span class="section-number">9.5.2.1. </span>概要<a class="headerlink" href="#id77" title="この見出しへのパーマリンク"></a></h4>
<p>NEB法に関連する、入力データのタグおよびその説明を以下に示します。</p>
<table class="longtable docutils align-default" id="id196">
<caption><span class="caption-number">表 9.4 </span><span class="caption-text">NEBに関連する入力データ</span><a class="headerlink" href="#id196" title="このテーブルへのパーマリンク"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>第1ブロック</p></th>
<th class="head"><p>第
2第3ブロック</p></th>
<th class="head"><p>タグ識別子</p></th>
<th class="head"><p>説明</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Control</p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>condition</p></td>
<td><p>新規計算か継続計算かを指定initial (新規計算)もしくはcontinuation (継続計算)</p>
<p>通常の計算と違い、automaticは利用不可</p>
</td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>multiple_replica_mode</p></td>
<td><p>NEB計算の実行</p>
<p>ON,OFF</p>
</td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>multiple_replica_max_iteration</p></td>
<td><p>NEB
iteration数</p></td>
</tr>
<tr class="row-even"><td><p>multiple_replica</p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>method</p></td>
<td><p>反応経路計算手法</p>
<p>nudged_elastic_band_method</p>
</td>
</tr>
<tr class="row-even"><td></td>
<td><p>accuracy</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>dt</p></td>
<td><p>NEB計算における原子座標更新の<span class="math notranslate nohighlight">\(\Delta t\)</span></p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>neb_time_integral</p></td>
<td><p>時間積分法</p>
<p>quench,
steepest_descent,cg, fireから選択できる(cg,fireはバージョン2020.01以降)</p>
<p>デフォルト値は、2019.02以前はsteepest_descent,
2020.01以降はfire.</p>
</td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>penalty_function</p></td>
<td><p>ペナルティ関数
<a class="reference internal" href="#equation-advanced-neb-eq8">(9.20)</a>
ON,OFF</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>neb_convergence_condition</p></td>
<td><p>NEB収束判定法(後述)</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>neb_convergence_threshold</p></td>
<td><p>NEB収束判定値</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>constraint</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>ci_neb</p></td>
<td><p>CI-NEB ON, OFF</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>sp_k_init</p></td>
<td><p>バネ定数(初期値)</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>sp_k_min</p></td>
<td><p>バネ定数(最小値)</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>sp_k_max</p></td>
<td><p>バネ定数(最大値)</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>sp_k_variable</p></td>
<td><p>バネ定数の固定、変動</p>
<p>OFF固定、ON変動</p>
</td>
</tr>
<tr class="row-even"><td></td>
<td><p>structure</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>number_of_replicas</p></td>
<td><p>レプリカ数</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>replica</p></td>
<td></td>
<td><p>レプリカ情報</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>endpoint_images</p></td>
<td><p>両端のイメージの指定方法</p>
<p>directin, file</p>
</td>
</tr>
<tr class="row-even"><td></td>
<td><p>atom_list_end0</p></td>
<td></td>
<td><p>両端のイメージの原子リスト</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>atom_list_end1</p></td>
<td></td>
<td><p>両端のイメージの原子リスト</p></td>
</tr>
<tr class="row-even"><td><p>structure</p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>symmetry</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>method</p></td>
<td><p>対称性の与え方</p></td>
</tr>
</tbody>
</table>
<p>NEB法の計算は、以下の指定を行います。</p>
<ul class="simple">
<li><p>NEB法の機能を有効にする</p></li>
<li><p>NEB用の収束判定の設定を行う</p></li>
<li><p>レプリカ列両端のレプリカの座標データを設定する</p></li>
<li><p>レプリカの中間レプリカの座標データを設定する</p></li>
</ul>
<p>各々について、以下に説明をします。</p>
</section>
<section id="id78">
<h4><span class="section-number">9.5.2.2. </span>NEB機能を有効にする<a class="headerlink" href="#id78" title="この見出しへのパーマリンク"></a></h4>
<p>PHASEにNEB法による計算を実行することを伝えるため、以下のようにcontrolブロックの下でmultiple_replica_mode変数をonとします。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>control{
  multiple_replica_mode = on
}
</pre></div>
</div>
</section>
<section id="id79">
<h4><span class="section-number">9.5.2.3. </span>収束判定<a class="headerlink" href="#id79" title="この見出しへのパーマリンク"></a></h4>
<p>収束判定条件は、multiple_replicaブロックの下のaccuracyブロックの変数neb_convergence_conditionで設定します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>multiple_replica{
  accuracy{
    neb_convergence_condition = delta_e
  }
}
</pre></div>
</div>
<p>neb_convergence_conditionには、数値または文字列を指定することができます。次の表に、設定できる条件を示します。</p>
<p>収束判定条件設定のパラメータ</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>数値</p></th>
<th class="head"><p>文字列</p></th>
<th class="head"><p>説明</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>delta_e</p></td>
<td><p>dE <span class="math notranslate nohighlight">\(&lt;\)</span>threshold</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>phase_force</p></td>
<td><p>PHASEの力の最大値<span class="math notranslate nohighlight">\(&lt;\)</span>threshold</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>neb_force</p></td>
<td><p>NEB計算で補正した力の最大値<span class="math notranslate nohighlight">\(&lt;\)</span>threshold</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>force_at_transition_state</p></td>
<td><p>最大エネルギーイメージのPHASEの力の
最大値<span class="math notranslate nohighlight">\(&lt;\)</span>threshold</p></td>
</tr>
<tr class="row-even"><td><p>5</p></td>
<td><p>phase_force_normal</p></td>
<td><p>PHASEの、経路に垂直な成分の力の
最大値<span class="math notranslate nohighlight">\(&lt;\)</span>threshold</p></td>
</tr>
</tbody>
</table>
</section>
<section id="neb-symmetry">
<span id="id80"></span><h4><span class="section-number">9.5.2.4. </span>結晶の対称性指定について<a class="headerlink" href="#neb-symmetry" title="この見出しへのパーマリンク"></a></h4>
<p>バージョン2019.02以前：対称性に自動探索（structure{symmetry{method = automatic}}）を設定すると、両端のレプリカのいずれかあるいは両方に、中間のレプリカよりも高い対称性が見つかった場合に、正常に計算が進まなくなります。マニュアル設定にして、必要ならば生成元を与えることによって、全レプリカの対称性を揃えて下さい。</p>
<p>バージョン2020.01以降：対称性に自動探索（structure{symmetry{method = automatic}}）を設定すると、始状態、終状態を含むすべてのレプリカに共通する対称性のみが適用されるように動作します。</p>
</section>
<section id="id81">
<h4><span class="section-number">9.5.2.5. </span>両端のレプリカの指定：入力で直接指定する方法<a class="headerlink" href="#id81" title="この見出しへのパーマリンク"></a></h4>
<p>両端のレプリカの原子座標を入力において直接指定するには、以下のような記述を行います。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>multiple_replica{
    ....
    ....
    structure{
        ....
        ....
        endpoint_images = directin
        atom_list_end0{
            coordinate_system = cartesian ! {internal
            atoms{
            #units angstrom
            #tag element rx ry rz
            Si    0.000000000000      0.000000000000      0.000000000000
            Si    2.751721694800      2.751721694800      0.000000000000
            ....
            ....
            }
        }
        atom_list_end1{
            coordinate_system = cartesian ! {internal
            atoms{
            #units angstrom
            #tag element rx  ry  rz
            Si    0.000000000000      0.000000000000      0.000000000000
            Si    2.751721694800      2.751721694800      0.000000000000
            ....
            ....
            }
        }
        ....
        ....
    }
    ....
    ....
</pre></div>
</div>
<p>変数endpoint_imagesにdirectinという文字列を指定し, さらに
atom_list_end0ブロックに始状態の、atom_list_end1に終状態のレプリカの座標値を通常のPHASEのatom_listブロックにおける指定と同じように指定します。</p>
</section>
<section id="advanced-neb-endpoint-from-dynm">
<span id="id82"></span><h4><span class="section-number">9.5.2.6. </span>両端のレプリカの指定：両端のレプリカの原子座標をファイルから指定する方法 (バージョン2020.01以降)<a class="headerlink" href="#advanced-neb-endpoint-from-dynm" title="この見出しへのパーマリンク"></a></h4>
<p>まず、multiple_replicaブロックのstructureブロックにおいて以下のような設定を施します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>multiple_replica{
  structure{
    number_of_replicas = 6
    endpoint_images = file
    frame_end0 = 0
    frame_end1 = 1
  }
}
</pre></div>
</div>
<p>number_of_repliasによって中間レプリカの数を指定します。始状態と終状態は、endpoint_images = fileとするとnfdynm.dataファイルから読み込むことができます。frame_end0,
frame_end1でnfdynm.data中のフレーム番号を指定します。フレーム番号は1始まりであり、0以下の数値を指定すると最後のフレームを採用するようになります。frame_end0,
frame_end1のデフォルト値は-1です。</p>
<p>つぎに、file_names.dataファイルにおいて以下のように目的のnfdynm.dataファイルを指定します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&amp;fnames
...

/
&amp;nebfiles
F_IMAGE(0) = ‘end0/nfdynm.data’
F_IMAGE(-1) = ‘end1/nfdynm.data’
/
</pre></div>
</div>
<p>nebfilesセクションにおいてファイル名を指定します。識別子F_IMAGE(0)によって始状態の、F_IMAGE(-1)によって終状態のnfdynm.dataファイルを指定します。この例ではend0ディレクトリーの下のnfdynm.dataファイルが始状態、end1ディレクトリーの下のnfdynm.dataファイルが終状態に対応します。</p>
</section>
<section id="advanced-neb-legacy-endpoint-from-file">
<span id="id83"></span><h4><span class="section-number">9.5.2.7. </span>両端のレプリカの指定：両端のレプリカの原子座標をファイルから指定する方法 (2019.02以前)<a class="headerlink" href="#advanced-neb-legacy-endpoint-from-file" title="この見出しへのパーマリンク"></a></h4>
<p>両端のイメージの原子座標をファイルで指定する場合は、入力データのendpoint_imagesの値をfileとし、file_names.dataにイメージのファイル名を設定します。
その際、file_names.dataファイル中ではF_IMAGE(-1)およびF_IMAGE(0)というファイルポインターを利用します。以下は、入力データとfile_names.dataの記述例です。</p>
<p>入力データの記述例</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>multiple_replica{
    ...
    ...
    structure{
        endpoint_images = file
    }
    ...
    ...
}
</pre></div>
</div>
<p>file_names.dataファイルの記述例</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&amp;fnames
...
...
/
&amp;nebfiles
F_IMAGE(0)  = &#39;./endpoint0.data&#39;
F_IMAGE(-1) = &#39;./endpoint1.data&#39;
...
...
/
</pre></div>
</div>
<p>また、原子座標データファイル(上記の例ではendpoint0.dataやendpoint1.dataというファイル名)は、次のような形式で記述します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>coordinate_system=cartesian
#units angstrom
Si      0.000000000000      0.000000000000      0.000000000000
Si      2.751721694800      2.751721694800      0.000000000000
Si      1.375860847400      1.375860847400      1.375860847400
Si      4.127582542200      4.127582542200      1.375860847400
Si      0.000000000000      2.751721694800      2.751721694800
Si      2.751721694800      0.000000000000      2.751721694800
Si      1.375860847400      4.127582542200      4.127582542200
Si      4.127582542200      1.375860847400      4.127582542200
Si      0.000000000000      0.000000000000      5.503443389600
Si      2.751721694800      2.751721694800      5.503443389600
Si      1.375860847400      1.375860847400      6.879304237000
H       1.644706293661      1.095414892118     11.000000000000
H       1.095414929519      1.644706317263     11.000000000000
</pre></div>
</div>
</section>
<section id="proportional">
<h4><span class="section-number">9.5.2.8. </span>中間レプリカの指定：中間レプリカの原子座標を両端の原子座標の線形補間で指定する方法(proportional)<a class="headerlink" href="#proportional" title="この見出しへのパーマリンク"></a></h4>
<p>中間レプリカの原子座標を両端の原子座標の線形補間で指定する場合は、replicaタグ内のhowtogive_coordinatesをproportinalとします。入力データの記述例を以下に示します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>multiple_replica{
  structure{
    number_of_replicas = 6
    replicas{
      #tag replica_number howtogive_coordinates end0 end1
                  1 proportional 0 -1 ! 0: end0, -1:end1
                  2 proportional 0 -1
                  3 proportional 0 -1
                  4 proportional 0 -1
                  5 proportional 0 -1
                  6 proportional 0 -1
    }
  }
}
</pre></div>
</div>
<p>これがデフォルトの振る舞いなので、すべての中間レプリカを線形補間で作成する場合replicasブロックは不要です。</p>
</section>
<section id="file">
<h4><span class="section-number">9.5.2.9. </span>中間レプリカの指定：中間レプリカの原子座標をファイルから指定する方法(file)<a class="headerlink" href="#file" title="この見出しへのパーマリンク"></a></h4>
<p>中間イメージをファイルで指定する場合は、replicaタグ内のhowtogive_coordinatesをfileとし、対応する原子座標ファイルはfile_names.dataファイルで指定します。
入力データとfile_names.dataファイルの記述例を以下に示します。</p>
<p>入力データの記述例</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>multiple_replica{
    ...
    ...
    structure{
        number_of_replicas = 3
        replicas{
             #tag replica_number  howtogive_coordinates   end0  end1
                1            file              0      -1 ! 0: end0, -1:end1
                2            file              0      -1
                3            file              0      -1
        }
    }
}
</pre></div>
</div>
<p>file_names.dataの記述例</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&amp;fnames
...
...
/
&amp;nebfiles
F_IMAGE(0)  = &#39;../end0/nfdynm.data&#39;
F_IMAGE(-1) = &#39;../end1/nfdynm.data&#39;
F_IMAGE(1)  = &#39;./image1.data&#39;
F_IMAGE(2)  = &#39;./image2.data&#39;
F_IMAGE(3)  = &#39;./image3.data&#39;
/
</pre></div>
</div>
<p>原子座標データを指定するファイルの書式は <a class="reference internal" href="#advanced-neb-legacy-endpoint-from-file"><span class="std std-ref">両端のレプリカの指定：両端のレプリカの原子座標をファイルから指定する方法 (2019.02以前)</span></a> の形式と同じです。</p>
</section>
<section id="id84">
<h4><span class="section-number">9.5.2.10. </span>NEB関連ファイルの指定<a class="headerlink" href="#id84" title="この見出しへのパーマリンク"></a></h4>
<p>NEB関連のファイルは、file_names.dataで設定します。次のように記述します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&amp;fnames
F_INP=&#39;./nfinp.data&#39;
F_POT(1)=&#39;./Si_ggapbe_nc_01.pp&#39;
...
...
/
&amp;nebfiles
F_IMAGE(0)  = &#39;../end0/nfdynm.data&#39;
F_IMAGE(-1) = &#39;../end1/nfdynm.data&#39;
F_NEB_OUT   = &#39;./output_neb&#39;
F_NEB_ENF   = &#39;./nfnebenf.data&#39;
F_NEB_DYNM  = &#39;./nfnebdynm.data&#39;
/
</pre></div>
</div>
<p>ファイル読み込みのnamelistとして、&amp;nebfilesを利用している点にご注意ください。</p>
<p>&amp;nebfilesで利用できるファイルポインターを、次の表に示します。</p>
<table class="longtable docutils align-default" id="id197">
<caption><span class="caption-number">表 9.5 </span><span class="caption-text">NEBで利用できるファイルポインター</span><a class="headerlink" href="#id197" title="このテーブルへのパーマリンク"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>ファイル名変数</p></th>
<th class="head"><p>Unit番号</p></th>
<th class="head"><p>デフォルト値</p></th>
<th class="head"><p>備考</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>F_IMAGE(-1:99)</p></td>
<td><p>201</p></td>
<td><p>./endpoint0.data (F_IMAGE(0))</p>
<p>./endpoint1.data (F_IMAGE(1))</p>
</td>
<td><p>イメージの原子座標</p></td>
</tr>
<tr class="row-odd"><td><p>F_NEB_STOP</p></td>
<td><p>202</p></td>
<td><p>./nfnebstop.data</p></td>
<td><p>NEBステップ終了用ファイル</p></td>
</tr>
<tr class="row-even"><td><p>F_NEB_OUT</p></td>
<td><p>203</p></td>
<td><p>./output_neb</p></td>
<td><p>NEB計算 ログ出力</p></td>
</tr>
<tr class="row-odd"><td><p>F_NEB_CNTN</p></td>
<td><p>204</p></td>
<td><p>./neb_continue.data</p></td>
<td><p>NEB継続計算用ファイル</p></td>
</tr>
<tr class="row-even"><td><p>F_NEB_ENF</p></td>
<td><p>205</p></td>
<td><p>./nfnebenf.data</p></td>
<td><p>エネルギー、力出力ファイル</p></td>
</tr>
<tr class="row-odd"><td><p>F_NEB_DYNM</p></td>
<td><p>206</p></td>
<td><p>./nfnebdynm.data</p></td>
<td><p>原子座標出力ファイル</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="advanced-neb-from-2020">
<span id="id85"></span><h3><span class="section-number">9.5.3. </span>入力パラメーター指定（バージョン2020.01以降）<a class="headerlink" href="#advanced-neb-from-2020" title="この見出しへのパーマリンク"></a></h3>
<p>NEB法は、2020.01以降のバージョンにおいて入力形式の簡略化と機能拡張がほどこされています（バージョン2019.02以前の指定方法も一部をのぞき利用できます）。具体的には以下の通り。</p>
<ul class="simple">
<li><p>最適化手法の拡充：従来から利用できた最急降下法とquench法に加え、fire法とcg法が使えるようになりました。新しいデフォルトの最適化手法はfire法です。</p></li>
<li><p>CI-NEB切り替え：CI-NEB法はNEB法の初期の段階で適用すると破綻してしまう場合があるので、通常のNEB法をしばらく実施してからCI-NEBに遷移する、という使い方が一般的です。このような使い方は、これまではいったん計算を終了し、継続計算のタイミングで行うというやり方でしか実現できませんでした。バージョン2020.01以降、ある閾値を満たした場合に遷移するという方法も利用できるようになりました。NEB法ではエネルギーやNEB力など複数の収束判定条件を利用できるようになっていますが、CI-NEBの切り替えの判定条件はNEB自体の判定条件と同じです。閾値はユーザーが指定することができますが、デフォルト値は通常のNEBの収束判定条件から動的に決まります。</p></li>
<li><p>対称性：始状態、終状態には存在しても中間レプリカには存在しない対称性がある場合があり、2019.02以前のバージョンでは中間レプリカが対称性チェックを満たせず、異常終了してしまいます。そこで、2020.01以降は始状態・終状態ふくめすべてのレプリカに共通する対称性のみ考慮するという動作に改良されました。中間レプリカが対称性を持つことはあまりないですが、表面モデルにおける反転対称性などは持つ場合があります。</p></li>
<li><p>nfdynm.dataファイルからの座標値の読み込み：始状態・終状態をnfdynm.dataファイルから読み込めるようになりました（これに伴い、旧型式の座標データは廃止されました）ただしこの方法を用いる場合始状態・終状態両方とも適用されます。いずれかのみを選択的に従来の方法で指定することはできません。またnfdynm.dataファイルの座標履歴を反応座標に見立てて読み込むこともできるようになっています。</p></li>
<li><p>必須設定の削減：2019.02以前のバージョンにおいては、原子配置を三カ所で定義する必要がありました。2020.01以降のバージョンにおいては、始状態・終状態の原子座標のデフォルト値を通常の座標指定のそれになっています。そのため、通常の原子配置指定は始状態があらわに指定されているならば終状態に、終状態があらわに指定されているならば始状態に対応するようになっています（ただしnfdynm.dataファイルから読み込む場合は始状態・終状態いずれもnfdynm.dataファイルから読み込まれるため、その限りではありません）また、以前のバージョンでは初期中間レプリカの作成方法の指定は必須設定でしたが、2020.01以降は“始状態と終状態の間の線形補間”によって中間レプリカを作成する場合をデフォルト値とし、この場合の指定は非必須となりました。</p></li>
</ul>
<section id="id86">
<h4><span class="section-number">9.5.3.1. </span>NEB法の精度などの設定<a class="headerlink" href="#id86" title="この見出しへのパーマリンク"></a></h4>
<p>NEBの精度などの設定をmultiple_replicaブロックのaccuracyブロックにおいて行うことができます。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>multiple_replica{
  accuracy{
    neb_time_integral = fire
    neb_convergence_condition = 3
    neb_convergence_threshold = 1.0e-3
    dt = 100 au_time
  }
}
</pre></div>
</div>
<p>neb_time_integralによってNEB法が利用する最適化手法を選択します。steepest_descent,
quench, cg,
fireから選択できます。デフォルト値はfireです。fireがうまく行かない場合、cgやquench法が推奨されます。neb_convergence_conditionでNEBの収束判定条件を設定します。1がエネルギー差、2が系の原子間力、3がNEB力、4が遷移状態の原子間力、5が系の経路に垂直な原子間力です。デフォルト値は1です。
dtによって時間刻みを設定します。この設定はneb_time_integralがsteepest_descent, quench, fireの場合に意味を持ちます。</p>
<p>neb_convergence_thresholdで閾値を設定します。これは単位を指定することはできないので、原子単位で指定します。そのデフォルト値はneb_convergence_conditionが1の場合は10<sup>-6</sup>
hartree, それ以外の場合は10<sup>-3</sup> hartree/bohrです。</p>
<p>FIRE法を利用する場合、パラメーターの詳細を設定することも可能となっています。その設定は、multiple_replicaブロックではなくstructure_evolutionブロックの下のfireブロックにおいて行います。その詳細は <a class="reference internal" href="../basics/basics.html#basics-fire-section"><span class="std std-ref">FIRE法の詳細設定（バージョン2020.01以降）</span></a> を参照してください。</p>
</section>
<section id="nfdynm-data">
<h4><span class="section-number">9.5.3.2. </span>始状態・終状態としてnfdynm.dataファイルを利用する方法<a class="headerlink" href="#nfdynm-data" title="この見出しへのパーマリンク"></a></h4>
<p>始状態・終状態の指定にnfdynm.dataファイルを利用する方法は、<a class="reference internal" href="#advanced-neb-endpoint-from-dynm"><span class="std std-ref">両端のレプリカの指定：両端のレプリカの原子座標をファイルから指定する方法 (バージョン2020.01以降)</span></a> において説明した通りです。</p>
</section>
<section id="ci-neb">
<h4><span class="section-number">9.5.3.3. </span>CI-NEBの切り替え<a class="headerlink" href="#ci-neb" title="この見出しへのパーマリンク"></a></h4>
<p>CI-NEB法は以下の要領で設定します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>multiple_replica{
  constraint{
    ci_neb = on
    ci_thres = 1e-2
    ci_index = 0
  }
}
</pre></div>
</div>
<p>multiple_replicaブロックの下のconstraintブロックにおいてCI-NEBの設定を行います。ci_neb=onとするとCI-NEBが有効になります。ci_thresで指定した値よりも収束判定条件として採用している量が小さい場合に通常のNEBからCI-NEBに切り替わります。この値のデフォルト値は、通常の収束判定条件の2倍です。CI-NEBに切り替わっていない場合通常の収束判定は無視されるので、CI-NEBに切り替わる前に誤って収束したとみなされることはありません。ci_indexに2から中間レプリカ数までの値を指定すると、エネルギーが最も高いレプリカではなくci_indexに対応するレプリカがCI-NEBのターゲットとなります。</p>
</section>
<section id="id87">
<h4><span class="section-number">9.5.3.4. </span>nfdynm.dataファイルを反応経路に見立てて初期レプリカ列にする方法<a class="headerlink" href="#id87" title="この見出しへのパーマリンク"></a></h4>
<p>nfdynm.dataファイルを反応経路に見立てて初期レプリカ列として採用することができます。この機能には、nfnebdynm.dataというファイルにNEB計算中のnfdynm.dataファイルの履歴が記録されるので、任意の反応経路を抽出し、NEBの初期経路にする、といった使い方が考えられます。途中から破綻してしまった計算をうまく行っていた段階まで戻って最初から計算したい場合や、何らかの事情でリスタート計算に必要なデータが出力されなかった場合に最後の反応経路を初期レプリカ列に採用したい場合などに利用できます。</p>
<p>この機能を利用するためには、まずは以下の設定を入力パラメーターファイルで行います。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>multiple_replica{
  structure{
    sw_path_from_dynm = on
  }
}
</pre></div>
</div>
<p>さらに、file_names.dataにおいて以下の指定を行います。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&amp;fnames
...
 /
&amp;nebfiles
F_PATH = ‘foo/nfdynm.data’
/
</pre></div>
</div>
<p>nebfilesセクションのF_PATH識別子で対象のnfdynm.dataファイルを指定します。なお、number_of_replicas+2
(+2は始状態・終状態の分)とnfdynm.dataファイルのフレーム数が一致している必要がある点には注意が必要です。</p>
</section>
<section id="id88">
<h4><span class="section-number">9.5.3.5. </span>始状態と終状態のエネルギーを指定する方法<a class="headerlink" href="#id88" title="この見出しへのパーマリンク"></a></h4>
<p>始状態と終状態のエネルギー計算は、デフォルトの振る舞いとしてはNEBステップ1回目に限り実行されます。しかし多くの場合このエネルギーは既知のため不要です。そこで、入力において指定することによってこのエネルギー計算を回避することができるようになっています。以下のように記述します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>multiple_replica{
  structure{
    end0_energy = -120.1 hartree
    end1_energy = -120.3 hartree
  }
}
</pre></div>
</div>
<p>end0_energyに始状態の、end1_energyに終状態のエネルギーを指定します。</p>
</section>
</section>
<section id="id89">
<h3><span class="section-number">9.5.4. </span>計算の実行方法<a class="headerlink" href="#id89" title="この見出しへのパーマリンク"></a></h3>
<p>NEBは「レプリカ並列」に対応しています。以下のように起動します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>% mpirun -n NP phase ne=NE nk=NK nr=NR
</pre></div>
</div>
<p>ここで、NPはMPIプロセスの数、NRは並列で計算するレプリカの数、NE, NKはPHASEと同様バンドおよび<span class="math notranslate nohighlight">\(\mathbf{k}\)</span>点並列の数です。ただし、NP = NR x NE x NK (三次元版の場合さらに x NG)という関係が成立している必要があります。</p>
</section>
<section id="id90">
<span id="id91"></span><h3><span class="section-number">9.5.5. </span>計算結果の出力<a class="headerlink" href="#id90" title="この見出しへのパーマリンク"></a></h3>
<p>NEBシミュレーションを実行すると、通常のPHASEの計算と比較して多くのファイルが得られます。
まず、ログファイル(output000)や継続計算に利用されるファイル(continue.dataファイルなど)は
すべてレプリカ毎に出力されます。識別のため、それぞれのファイルの末尾に“_rxxx”という文字列がたされます。
さらにNEB固有の以下のファイルが得られます。</p>
<ul class="simple">
<li><p>output_neb_pxxx</p></li>
</ul>
<p>NEB計算のログファイルです。xxxにはMPIプロセスの番号が割り振られます。NEB計算に関するログが出力されます。</p>
<ul class="simple">
<li><p>nfnebenf.data</p></li>
</ul>
<p>NEB計算のエネルギーやNEB力などが記録されたファイルです。以下のような形式で出力されます。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>#step   image  image_distance  energy   force_org  force_neb  force_normal
   1    1    0.0000000000E+00   -0.4399458479E+02    0.1112676571E-01    0.1112676571E-01    0.0000000000E+00
   1    2    0.1323772380E+01   -0.4397221867E+02    0.5212041989E-01    0.4899393390E-01    0.4899393390E-01
   1    3    0.2640972887E+01   -0.4393533860E+02    0.5368141337E-01    0.5023308254E-01    0.5023308254E-01
   1    4    0.3958252743E+01   -0.4389613534E+02    0.4830449879E-01    0.4474348402E-01    0.4474348402E-01
   1    5    0.5277489255E+01   -0.4389237657E+02    0.4486782793E-01    0.4486782793E-01    0.4486782793E-01
   1    6    0.6594794555E+01   -0.4396965451E+02    0.8881334200E-01    0.8881334200E-01    0.8881334200E-01
   1    7    0.7911999993E+01   -0.4404244254E+02    0.5849229655E-01    0.5849229655E-01    0.5849229655E-01
   1    8    0.9229437211E+01   -0.4405831588E+02    0.2414216682E-01    0.2414216682E-01    0.0000000000E+00
   2    1    0.0000000000E+00   -0.4399458479E+02    0.1112676571E-01    0.1112676571E-01    0.0000000000E+00
   2    2    0.1356841287E+01   -0.4398451885E+02    0.4270600251E-01    0.4018848625E-01    0.4018734489E-01
   2    3    0.2677587331E+01   -0.4394948430E+02    0.5479419750E-01    0.5096369018E-01    0.5096445426E-01
   2    4    0.4004269114E+01   -0.4390739111E+02    0.5004508819E-01    0.4463448973E-01    0.4464878761E-01
   2    5    0.5328036512E+01   -0.4389409127E+02    0.4291037894E-01    0.4291037894E-01    0.4291037894E-01
   2    6    0.6642907129E+01   -0.4397034020E+02    0.8879366098E-01    0.8879366098E-01    0.8879366098E-01
   2    7    0.7959713712E+01   -0.4404290631E+02    0.5713917408E-01    0.5713917408E-01    0.5713917408E-01
   2    8    0.9278358213E+01   -0.4405831588E+02    0.2414216682E-01    0.2414216682E-01    0.0000000000E+00
   3    1    0.0000000000E+00   -0.4399458479E+02    0.1112676571E-01    0.1112676571E-01    0.0000000000E+00
   3    2    0.1356624500E+01   -0.4399408010E+02    0.1114085905E-01    0.1114085905E-01    0.1114085905E-01
   3    3    0.2730952540E+01   -0.4397302719E+02    0.5096325231E-01    0.4680553493E-01    0.4683808222E-01
   3    4    0.4090362450E+01   -0.4392669466E+02    0.5272530274E-01    0.4351975945E-01    0.4355359239E-01
   3    5    0.5418808773E+01   -0.4389735067E+02    0.3886543373E-01    0.3886543373E-01    0.3886543373E-01
   3    6    0.6726370673E+01   -0.4397144829E+02    0.8809362538E-01    0.8809362538E-01    0.8809362538E-01
   3    7    0.8041492838E+01   -0.4404354368E+02    0.5543086596E-01    0.5543086596E-01    0.5543086596E-01
                                                        .......
</pre></div>
</div>
<p>各行に1つのレプリカに関するエネルギーや力の情報が出力されます。1列目がNEBステップ数、2列目がレプリカのID,
3列目が0番目のレプリカからの“距離”,
4列目がレプリカのエネルギー、5列目がレプリカに働く力の最大値、6列目がNEB力の最大値、7列目がレプリカに働く力の最大値を経路に射影した力（NEB力の計算に利用される力）の最大値に対応します。</p>
<ul class="simple">
<li><p>nfnebdynm.data</p></li>
</ul>
<p>座標データの履歴が記録されます。通常のPHASEの計算で得られるnfdynm.dataファイルと比較すると簡略化された形式で出力されます。具体的には以下のような形式で出力されます。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>#step  image  atom  cps
   0    1    1        0.0000000000        0.0000000000        0.0000000000
   0    1    2        5.2000000098        5.2000000098        0.0000000000
   0    1    3        2.6000000049        2.6000000049        2.6000000049
   0    1    4        7.8000000147        7.8000000147        2.6000000049
   0    1    5        0.0000000000        5.2000000098        5.2000000098
   0    1    6        5.2000000098        0.0000000000        5.2000000098
   0    1    7        2.6000000049        7.8000000147        7.8000000147
   0    1    8        7.8000000147        2.6000000049        7.8000000147
   0    1    9        0.0000000000        0.0000000000       10.4000000197
   0    1   10        5.2000000098        5.2000000098       10.4000000197
   0    1   11        2.6000000049        2.6000000049       13.0000000246
   0    1   12        3.1080442326        2.0700339938       20.7869859136
   0    1   13        2.0700340645        3.1080442772       20.7869859136
   0    2    1        0.0000000000        0.0000000000        0.0000000000
   0    2    2        5.2000000098        5.2000000098        0.0000000000
   0    2    3        2.6000000049        2.6000000049        2.6000000049
   0    2    4        7.8000000147        7.8000000147        2.6000000049
   0    2    5        0.0000000000        5.2000000098        5.2000000098
   0    2    6        5.2000000098        0.0000000000        5.2000000098
   0    2    7        2.6000000049        7.8000000147        7.8000000147
   0    2    8        7.8000000147        2.6000000049        7.8000000147
   0    2    9        0.0000000000        0.0000000000       10.4000000197
   0    2   10        5.2000000098        5.2000000098       10.4000000197
   0    2   11        2.6000000049        2.6000000049       13.0000000246
   0    2   12        3.2652054480        1.9060914168       19.8836995566
   0    2   13        1.9060915098        3.2652055024       19.8836994729
</pre></div>
</div>
<p>各行が、あるNEBステップ・あるレプリカ・ある原子の座標データに対応します。1列目がNEBステップ、2列目がレプリカのID,
3列目がレプリカ内における原子のID, 4, 5,
6列目が原子座標です。座標は、ボーア単位、カルテシアン座標で出力されます。</p>
<p>nfefn.dataファイルとnfdynm.dataファイルは通常のPHASEの計算においてはそれぞれエネルギーおよび座標値の履歴が記録されるファイルですが、
NEB計算の場合は最新のレプリカ列のエネルギーおよび座標データが記録されたファイルです。nfefn.dataファイルにはnfnebenfに記録されたデータの最後の
NEBステップのデータが記録されます。nfdynm.dataファイルは、PHASEの通常の形式で記録されますが、通常の計算では構造最適化や分子動力学シミュレーションの
履歴となるところがレプリカ列になります。</p>
</section>
<section id="id92">
<h3><span class="section-number">9.5.6. </span>計算例：シリコン表面に水素分子が解離吸着する反応<a class="headerlink" href="#id92" title="この見出しへのパーマリンク"></a></h3>
<p>シリコン表面に水素分子が解離吸着する反応の例題の入力ファイルは、 <code class="code docutils literal notranslate"><span class="pre">samples/dynamics/neb/Si_H2</span></code> 以下にあります。</p>
<p>ここで紹介する例題は、シリコン表面に水素分子が解離吸着する反応をシミュレートします。始状態は表面と表面から十分離れた場所にある水素分子から成る系、始状態は表面のシリコン原子に水素分子が解離し、吸着した系です。始状態と終状態の構造をそれぞれ <a class="reference internal" href="#advanced-neb-initial-state"><span class="std std-numref">図 9.28</span></a> と <a class="reference internal" href="#advanced-neb-final-state"><span class="std std-numref">図 9.29</span></a> に示します。</p>
<p>ただし、計算機能を説明する例題として、以下の点を簡略化しています。</p>
<ul class="simple">
<li><p>対称性が高い経路を通ると仮定して、対称性を利用しています。（<a class="reference internal" href="#neb-symmetry"><span class="std std-ref">結晶の対称性指定について</span></a> 参照）</p></li>
<li><p>全ての基板原子は、バルク位置に固定されています。</p></li>
</ul>
<figure class="align-default" id="advanced-neb-initial-state">
<img alt="../_images/image186.png" src="../_images/image186.png" />
<figcaption>
<p><span class="caption-number">図 9.28 </span><span class="caption-text">本例題の始状態</span><a class="headerlink" href="#advanced-neb-initial-state" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
<figure class="align-default" id="advanced-neb-final-state">
<img alt="../_images/image187.png" src="../_images/image187.png" />
<figcaption>
<p><span class="caption-number">図 9.29 </span><span class="caption-text">本例題の終状態</span><a class="headerlink" href="#advanced-neb-final-state" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
<section id="id93">
<h4><span class="section-number">9.5.6.1. </span>入力ファイル<a class="headerlink" href="#id93" title="この見出しへのパーマリンク"></a></h4>
<p>controlブロックにおいて、全体的な計算条件の指定を行います。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Control{
    condition = initial   ! {initial|continuation|automatic}
    cpumax = 1 day ! {sec|min|hour|day}
    max_iteration = 10000000
    multiple_replica_mode = ON
    multiple_replica_max_iteration = 2000
}
</pre></div>
</div>
<p>multiple_replica_modeにONを指定することにより、NEBの計算が実行されます。また、NEBの繰り返し計算の上限回数をmultiple_replica_max_iteration
変数によって2000としています。</p>
<p>multiple_replicaブロックの下のstructureブロックにおいてレプリカの指定を実行しています。
以下のようになります。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>multiple_replica{
    ....
    structure{
        number_of_replicas = 6
        replicas{
            #tag replica_number  howtogive_coordinates   end0  end1
            1            proportional              0      -1 ! 0: end0, -1:end1
            2            proportional              0      -1
            3            proportional              0      -1
            4            proportional              0      -1
            5            proportional              0      -1
            6            proportional              0      -1
        }
        endpoint_images = directin ! {no or nothing | file | directin}
        howtogive_coordinates = from_endpoint_images
        atom_list_end0{
            coordinate_system = cartesian ! {internal|cartesian}
            atoms{
            #units angstrom
            #tag element rx ry rz
            Si    0.000000000000      0.000000000000      0.000000000000
            ...
            ...
            }
        }
        atom_list_end1{
            coordinate_system = cartesian ! {internal|cartesian}
            atoms{
            #units angstrom
            #tag element rx  ry  rz
            Si    0.000000000000      0.000000000000      0.000000000000
            ...
            ...
            }
        }
    }
    ....
}
</pre></div>
</div>
<p>number_of_replicasに6と指定していますが、この指定によってレプリカ数を合計6としています。
replicasブロックにおいて実際にどのようにレプリカの座標を作るかを指定しています。この例では、
すべて始状態・終状態の線形補完によって作る、という設定になります。
atom_list_end0およびatom_list_end1ブロックには始状態・終状態の座標値を指定しています。
この指定は、前記の通り通常のPHASEの座標指定と変わるところはありません。</p>
<p>multiple_replicaブロックの下のaccuracyブロックにおいて収束判定条件などの設定を行っています。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>multiple_replica{
     ...
     accuracy{
              dt = 40 au_time
              neb_time_integral = quench
              neb_convergence_condition = 3
              neb_convergence_threshold = 5.0e-04
     }
}
</pre></div>
</div>
<p>dtによって時間刻みを40 au_timeに設定しています。neb_time_integralによって最適化手法としてquench法を採用しています。neb_convergence_conditionで収束判定の方法を指定しています。3はNEB力の最大値によって収束判定を行うことを意味します。neb_convergence_thresholdで収束判定の閾値を5e-04としています。この値の単位はneb_convergence_conditionの設定によって変わることに注意が必要です。今の場合は力なのでhartree/bohr単位です。</p>
</section>
<section id="id94">
<h4><span class="section-number">9.5.6.2. </span>計算結果<a class="headerlink" href="#id94" title="この見出しへのパーマリンク"></a></h4>
<p>本例題を実行すると得られる結果を紹介します。</p>
<p><a class="reference internal" href="#advanced-neb-nebforce-history"><span class="std std-numref">図 9.30</span></a> に、本例題を実行すると得られる、NEBの繰り返し計算とNEB力の最大値の関係を示します。はじめのうちは大きな
力が働いていますが、計算が進行するにつれて小さくなっていき、41回の繰り返し計算の後収束判定を満たして計算が終了しています。</p>
<p><a class="reference internal" href="#advanced-neb-replica-energies"><span class="std std-numref">図 9.31</span></a> に、本例題を実行すると得られる各イメージとエネルギーの関係を示します。
この図より、遷移状態は4番目のレプリカであり、始状態から見ると障壁エネルギーが約1.08
eVであることが分かります。</p>
<figure class="align-default" id="advanced-neb-nebforce-history">
<a class="reference internal image-reference" href="../_images/image188.svg"><img alt="../_images/image188.svg" src="../_images/image188.svg" width="480px" /></a>
<figcaption>
<p><span class="caption-number">図 9.30 </span><span class="caption-text">NEB力の履歴</span><a class="headerlink" href="#advanced-neb-nebforce-history" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
<figure class="align-default" id="advanced-neb-replica-energies">
<a class="reference internal image-reference" href="../_images/image189.svg"><img alt="../_images/image189.svg" src="../_images/image189.svg" width="480px" /></a>
<figcaption>
<p><span class="caption-number">図 9.31 </span><span class="caption-text">最終的に得られる反応経路と各レプリカのエネルギーの関係</span><a class="headerlink" href="#advanced-neb-replica-energies" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
<p><a class="reference internal" href="#advanced-neb-ts"><span class="std std-numref">図 9.32</span></a> に、遷移状態における原子配置を示します。この図から明らかなように、本例題では「水素分子が解離、そして吸着する」直前の構造が遷移状態です。</p>
<figure class="align-default" id="advanced-neb-ts">
<img alt="../_images/image190.png" src="../_images/image190.png" />
<figcaption>
<p><span class="caption-number">図 9.32 </span><span class="caption-text">遷移状態における原子配置</span><a class="headerlink" href="#advanced-neb-ts" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
</section>
</section>
<section id="id95">
<h3><span class="section-number">9.5.7. </span>バージョン2020.01以降の機能を活用した計算例<a class="headerlink" href="#id95" title="この見出しへのパーマリンク"></a></h3>
<p>バージョン2020.01以降新たに機能が加わっています。本節では白金(111)面における酸素原子の拡散を例に、これらの機能を活用して作成した入力と計算例を紹介します。</p>
<section id="id96">
<h4><span class="section-number">9.5.7.1. </span>問題<a class="headerlink" href="#id96" title="この見出しへのパーマリンク"></a></h4>
<p>Pt(111)面のfcc hollowサイトからhcp hollowサイトへ拡散する過程をNEB法で解析します。
サンプルデータは <code class="code docutils literal notranslate"><span class="pre">samples/dynamics/neb/Pt111</span></code> 以下のサブディレクトリーにあります。面心立方格子の(111)面のhollowサイトには、二層下に原子が存在するサイト(通称fccサイト)と存在しないサイト(通称hcpサイト)が存在し、いずれも安定に原子が吸着できるサイトです。本例題では、酸素原子がPt(111)面のfcc
hollowサイトからhcp
hollowサイトへ拡散する過程をNEB法で解析します。fccが始状態(fccサイトに酸素原子が吸着した状態)の最適化計算を行ったディレクトリー、hcpが終状態(hcpサイトに酸素原子が吸着した状態)の最適化計算を行ったディレクトリー、fcc_hcpがfccサイトからhcpサイトへ酸素原子が拡散するNEB計算の入力ファイルが置かれたディレクトリーです。</p>
<p>始状態および終状態は <a class="reference internal" href="#advanced-neb-pt111"><span class="std std-numref">図 9.33</span></a> に示す通りです。NEB最適化手法は、比較のためFIRE法、CG法、quench法を採用しました。いずれの方法を使っても結果はほぼ同じものが得られることは確認できています。収束判定条件は、最大NEB力1×10<sup>-3</sup> hartree/bohrとしました。また、CI-NEB法を有効にし、切り替えの閾値はデフォルト値を採用しました。</p>
<figure class="align-default" id="advanced-neb-pt111">
<img alt="../_images/Pt111_O.svg" src="../_images/Pt111_O.svg" /><figcaption>
<p><span class="caption-number">図 9.33 </span><span class="caption-text">本例題の始状態（左図）と終状態（右）</span><a class="headerlink" href="#advanced-neb-pt111" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
</section>
<section id="id97">
<span id="id98"></span><h4><span class="section-number">9.5.7.2. </span>入力ファイル<a class="headerlink" href="#id97" title="この見出しへのパーマリンク"></a></h4>
<p>controlブロックにおいて、全体的な計算条件の指定を行います。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Control{
    condition = initial   ! {initial|continuation|automatic}
    cpumax = 1 day ! {sec|min|hour|day}
    max_iteration = 10000000
    multiple_replica_mode = ON
}
</pre></div>
</div>
<p>multiple_replica_modeにONを指定することにより、NEBの計算が実行されます。また、NEBの繰り返し計算の上限回数をmultiple_replica_max_iteration
変数によって2000としています。</p>
<p>multiple_replicaブロックの下のaccuracyブロックにおいてNEBの最適化の方法や収束判定条件を指定します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>multiple_replica{
  ...
  accuracy{
     neb_time_integral = fire
     neb_convergence_condition = 3
     neb_convergence_threshold = 1.0e-03
  }
}
</pre></div>
</div>
<p>multiple_replicaブロックの下のstructureブロックにおいてレプリカの指定を実行しています。
以下のようになります。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>multiple_replica{
     ....
  structure{
    number_of_replicas = 5
    endpoint_images = file
    end0_energy = -1308.2190366480
    end1_energy = -1308.2355763153
  }
}
</pre></div>
</div>
<p>number_of_replicasに5と指定していますが、この指定によって中間レプリカ数を合計5としています。
endpoint_images =
fileとし、nfdynm.dataファイルから始状態と終状態を読み込むことを指定しています。frameに関する情報は設定していないため、デフォルトの振る舞い（最後のフレーム）が採用されます。end0_energyとend1_energyにそれぞれ始状態と終状態のエネルギーが指定されています。この指定により、NEB
iterationの1回目に限り実施される始状態と終状態のエネルギー計算を省略することができます。</p>
<p>multiple_replicaブロックの下のconstraintブロックにおいて、CI-NEBを有効にすることができます。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>multiple_replica{
  constraint{
    ci_neb = on
  }
}
</pre></div>
</div>
<p>ci_nebがonと設定されていても、まずは通常のNEBが実行されます。収束判定条件が閾値以下になったあかつきにCI-NEBが有効になります。閾値のデフォルト値は、収束判定条件の値の2倍です。</p>
<p>最後に、file_names.dataファイルにおいて始状態と終状態のnfdynm.dataファイルの位置を指定します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>...

&amp;nebfiles
F_IMAGE(0) = &#39;../fcc/nfdynm.data&#39;
F_IMAGE(-1) = &#39;../hcp/nfdynm.data&#39;
/
</pre></div>
</div>
<p>&amp;nebfilesセクションにおいてNEB法で利用する始状態と終状態の読み込み先のnfdynm.dataファイルを指定します。ファイルポインターF_IMAGE(0)で始状態の、F_IMAGE(-1)で終状態の座標データファイルを指定します。この例では、1階層上のfccというディレクトリーの下のnfdynm.dataファイルを始状態、1階層上のhcpというディレクトリーの下のnfdynm.dataファイルを終状態として利用することになります。</p>
</section>
<section id="id99">
<h4><span class="section-number">9.5.7.3. </span>計算結果<a class="headerlink" href="#id99" title="この見出しへのパーマリンク"></a></h4>
<p>NEB力の履歴および得られた反応経路のエネルギ－を <a class="reference internal" href="#advanced-neb-pt111-result"><span class="std std-numref">図 9.34</span></a> に示しました。CG法、FIRE法はそれぞれ20回および32回のNEBステップで収束解を得ることができましたが、quench法は100回以上NEBを行っても収束判定条件を満たすことはできませんでした。</p>
<figure class="align-default" id="advanced-neb-pt111-result">
<img alt="../_images/image195.svg" src="../_images/image195.svg" /><figcaption>
<p><span class="caption-number">図 9.34 </span><span class="caption-text">NEB力の履歴（左）と反応座標とエネルギーの関係（右）</span><a class="headerlink" href="#advanced-neb-pt111-result" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
</section>
</section>
<section id="id100">
<span id="id101"></span><h3><span class="section-number">9.5.8. </span>使用における注意点<a class="headerlink" href="#id100" title="この見出しへのパーマリンク"></a></h3>
<ul class="simple">
<li><p>レプリカ並列</p></li>
</ul>
<p>NEB法は「レプリカ並列」に対応しています。レプリカ並列機能を使用するためには、引数に通常の
ne=NE nk=NKに加え、並列したいレプリカ数をNRとするとnr=NRを加えます。
MPIプロセス数はNE x NK x NRと等しい必要があります。
たとえば、以下のようなコマンドになります。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>% mpirun -n N phase ne=NE nk=NK nr=NR
</pre></div>
</div>
<ul class="simple">
<li><p>計算の停止と継続計算</p></li>
</ul>
<p>NEB法は計算の停止と継続計算に対応していますが、通常の計算とは異なる手続きが必要です。</p>
<ul class="simple">
<li><p>計算のストップ</p></li>
</ul>
<p>入力データのmulti_replica_max_iteration、またはnfnebstop.dataに記述されたNEBのiteration数でNEB計算は終了します。また、各イメージの電子状態計算において、入力データのmax_iteration,
cpumax,
nfstop.dataファイルの設定によっても計算は終了します。いずれの場合でも、停止した箇所からリスタートすることが可能です。</p>
<p>計算ストップ時における通常のPHASEとの相違点を挙げます。PHASEでは、nfstop.dataファイルによって終了した場合、nfstop.dataファイルは空ファイルとなります。他方NEB計算では、あるイメージをnfstop.dataによって終了した場合、nfstop.dataはただちには空ファイルとはならず、ほかのイメージの計算を行います。NEB計算終了処理においてはじめてnfstop.dataファイルを空ファイルとします。</p>
<ul class="simple">
<li><p>計算のリスタート</p></li>
</ul>
<p>PHASEと同様、入力データにおいて、conditionの値をcontinuationとすることによってリスタート計算を行います。
NEB法利用時は、automaticとしても継続計算になりません。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Control{
    condition = continuation
    ...
    ...
}
</pre></div>
</div>
<p>リスタート時に利用するファイルは下記のファイルです。</p>
<p>・NEB計算: neb_continue.data</p>
<p>・電子状態計算: 各レプリカのPHASE用リスタートファイル;</p>
<p>neb_continue.data, continue.data_r*, continue_bin.data_r*, zaj.data_r*,
nfchgt.data_r*</p>
<p><strong>参考文献</strong></p>
<div role="list" class="citation-list">
<div class="citation" id="mills94" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id74">Mills94</a><span class="fn-bracket">]</span></span>
<p>G. Mills and H. Jónsson, ``Quantum and Thermal Effects in H<sub>2</sub> Dissociative Adsorption: Evaluation of Free Energy Barriers in Multidimensional Quantum Systems'' Phys. Rev. Lett.  <strong>72</strong> (1994) p. 1124.</p>
</div>
<div class="citation" id="henkelman00" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id75">Henkelman00</a><span class="fn-bracket">]</span></span>
<p>G. Henkelman, B. P. Uberuaga and H. Jónsson, ``A climbing image nudged elastic band method for finding saddle points and minimum energy paths'' J. Chem. Phys. <strong>113</strong> (2000) p. 9901.</p>
</div>
</div>
</section>
</section>
<section id="dimer">
<span id="section-dimer-method"></span><h2><span class="section-number">9.6. </span>Dimer 法<a class="headerlink" href="#dimer" title="この見出しへのパーマリンク"></a></h2>
<section id="id102">
<h3><span class="section-number">9.6.1. </span>機能の概要<a class="headerlink" href="#id102" title="この見出しへのパーマリンク"></a></h3>
<p>Dimer法 <a class="reference internal" href="#henkelman99" id="id103"><span>[Henkelman99]</span></a> とは、2つのレプリカが作るdimerを回転・並進させながらポテンシャルエネルギー表面の鞍点を探索する計算手法です。</p>
<p>Dimer法では、ある中心の座標 <span class="math notranslate nohighlight">\(R\)</span> から距離 <span class="math notranslate nohighlight">\(\Delta R\)</span> はなれた二つのレプリカの座標でdimerを構成します。Dimerの方向の単位ベクトルを <span class="math notranslate nohighlight">\(N\)</span> とすると、二つのレプリカの座標 <span class="math notranslate nohighlight">\(R_1, R_2\)</span> は以下のように記述することができます。</p>
<div class="math notranslate nohighlight" id="equation-advanced-dimer-eq1">
<span class="eqno">(9.21)<a class="headerlink" href="#equation-advanced-dimer-eq1" title="この数式へのパーマリンク"></a></span>\[\begin{split}R_1 = R+\Delta R N \\ R_2 = R - \Delta R N\end{split}\]</div>
<p>レプリカ1, 2のエネルギーと原子間力をそれぞれ <span class="math notranslate nohighlight">\(E_1 , F_1 , E_2 , F_2\)</span> と記述し、さらにdimerの中心のエネルギーと原子間力をそれぞれ <span class="math notranslate nohighlight">\(E_0 , F_R\)</span> dimerそのもののエネルギーは <span class="math notranslate nohighlight">\(E = E_1+E_2\)</span> , <span class="math notranslate nohighlight">\(F_R\)</span>
は単純に <span class="math notranslate nohighlight">\(\frac{1}{2} \left( F_1 + F_2 \right)\)</span> とします。Dimerの向きの曲率は次のように近似することができます。</p>
<div class="math notranslate nohighlight" id="equation-advanced-dimer-eq2">
<span class="eqno">(9.22)<a class="headerlink" href="#equation-advanced-dimer-eq2" title="この数式へのパーマリンク"></a></span>\[C = \frac{\left(F_1-F_2\right) \cdot N}{2\Delta R} = \frac{E-2E_0}{\Delta R^2}\]</div>
<p><a class="reference internal" href="#equation-advanced-dimer-eq2">(9.22)</a> 式より <span class="math notranslate nohighlight">\(E_0\)</span> は次のように計算することができます。</p>
<div class="math notranslate nohighlight" id="equation-advanced-dimer-eq3">
<span class="eqno">(9.23)<a class="headerlink" href="#equation-advanced-dimer-eq3" title="この数式へのパーマリンク"></a></span>\[E_0 = \frac{E}{2} + \frac{\Delta R}{4} \left( F_1-F_2 \right) \cdot N\]</div>
<p>Dimerの回転は、「回転力」 <span class="math notranslate nohighlight">\(F^\perp = F_1^\perp - F_2^\perp\)</span> にそって行われます。<span class="math notranslate nohighlight">\(F^\perp\)</span> に水平な単位ベクトルを <span class="math notranslate nohighlight">\(\Theta\)</span> とすると、レプリカ1, 2に対する回転操作は次のように記述することができます。</p>
<div class="math notranslate nohighlight" id="equation-advanced-dimer-eq4">
<span class="eqno">(9.24)<a class="headerlink" href="#equation-advanced-dimer-eq4" title="この数式へのパーマリンク"></a></span>\[R_{1/2}^\ast = R \pm{\left( N \cos{\theta} + \Theta \sin{\theta} \right)\Delta R}\]</div>
<p>最適な回転角 <span class="math notranslate nohighlight">\(\theta\)</span> はまず微小な角度 <span class="math notranslate nohighlight">\(d \theta\)</span> によるトライアル回転によって得られた原子間力から決めます。<span class="math notranslate nohighlight">\(d \theta\)</span> 回転した結果得られた
レプリカ1, 2の原子間力 <span class="math notranslate nohighlight">\(F_1^\ast, F_2^\ast\)</span> また <span class="math notranslate nohighlight">\(F^\ast = F_1^\ast - F_2^\ast\)</span> を定義し、さらに <span class="math notranslate nohighlight">\(F=F^\perp \cdot \Theta\)</span> と <span class="math notranslate nohighlight">\(F\)</span> の数値微分 <span class="math notranslate nohighlight">\(F^\prime \neq \frac{F^\ast \cdot \Theta^\ast - F \cdot \Theta}{d\theta}\)</span> を用いると最適な回転角 <span class="math notranslate nohighlight">\(\Delta \theta\)</span> は以下のように求められます。</p>
<div class="math notranslate nohighlight" id="equation-advanced-dimer-eq5">
<span class="eqno">(9.25)<a class="headerlink" href="#equation-advanced-dimer-eq5" title="この数式へのパーマリンク"></a></span>\[\Delta \theta = - \frac{1}{2} \arctan{\frac{2F}{F^\prime}}\]</div>
<p>このように決まった <span class="math notranslate nohighlight">\(\Delta \theta\)</span> と <a class="reference internal" href="#equation-advanced-dimer-eq4">(9.24)</a> 式を用いてdimerに回転を施します。</p>
<p>Dimerを回転したあと鞍点に向かってdimerを並進します。並進は、以下のような原子間力を用いて行います。</p>
<div class="math notranslate nohighlight" id="equation-advanced-dimer-eq6">
<span class="eqno">(9.26)<a class="headerlink" href="#equation-advanced-dimer-eq6" title="この数式へのパーマリンク"></a></span>\[\begin{split}F^\perp =
 \begin{cases}
   -F^\parallel &amp; C&gt;0 \\
   F-2F^\parallel &amp; C&lt;0&gt;
 \end{cases}\end{split}\]</div>
<p>並進はquenched MDによって行います。トライアル回転後と <a class="reference internal" href="#equation-advanced-dimer-eq4">(9.24)</a>, <a class="reference internal" href="#equation-advanced-dimer-eq5">(9.25)</a> による回転後にレプリカのエネルギー、原子間力の計算を行うので、1回のdimer iterationにつき4回のSCF計算を実施します。</p>
</section>
<section id="id104">
<h3><span class="section-number">9.6.2. </span>入力パラメータ<a class="headerlink" href="#id104" title="この見出しへのパーマリンク"></a></h3>
<p>Dimer法を有効にするためには、以下のような設定を施します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Control{
    condition = initial   ! {initial|continuation|automatic}
    cpumax = 1 day ! {sec|min|hour|day}
    max_iteration = 10000000
    multiple_replica_mode = ON
    multiple_replica_method = dimer
    multiple_replica_max_iteration = 2000
}
</pre></div>
</div>
<p>NEBと同じように、controlブロックにおいてmultiple_replica_mode = onとします。さらに、multiple_replica_method = dimerを指定するとdimer法が用いられるようになります。multiple_replica_max_iterationの意味はNEBの場合と同様です。</p>
<p>Dimer法の詳細設定もNEBと同じようにmultiple_replicaブロックにおいて行います。以下のような設定を施すことができます。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>multiple_replica{
    accuracy{
        dt = 20 au_time
        dimer_convergence_threshold = 5.0e-04
    }
    dimer{
         delta_r = 0.01 angstrom
        delta_theta = 0.001
    }
    structure{
        endpoint_images = directin ! {no or nothing | file | directin}
        howtogive_coordinates = from_endpoint_images
        atom_list_end0{
            coordinate_system = cartesian ! {internal|cartesian}
            atoms{
            #tag element rx ry rz
      Si    0.000000000    0.000000000    0.000000000
      Si    5.200000010    5.200000010    0.000000000
      ...
           }
       }
       atom_list_end1{
                coordinate_system = cartesian ! {internal|cartesian}
           atoms{
           #tag element rx  ry  rz
      Si    0.000000000    0.000000000    0.000000000
      Si    5.200000010    5.200000010    0.000000000
      ...
      ...
           }
       }
    }
}
</pre></div>
</div>
<p>multiple_replicaのaccuracyブロックにおいてdimer法の精度に関わる設定を行うことができます。dtでquench法の時間刻みを指定することができます。dimer_convergence_thresholdによって収束判定条件を設定することができます。
dimerブロックのdelta_r, delta_thetaによってそれぞれ <span class="math notranslate nohighlight">\(\Delta R, d\theta\)</span> の値を設定することができます。<span class="math notranslate nohighlight">\(\Delta R\)</span> のデフォルト値は0.01 Å <span class="math notranslate nohighlight">\(d\theta\)</span> のデフォルト値は0.001 radianです。初期dimerはNEBの始点・終点と同じ方法
で指定した2つのレプリカをもとに作成されます。すなわち、NEBの始点に相当する座標を <span class="math notranslate nohighlight">\(R_1\)</span> 終点に相当する座標を <span class="math notranslate nohighlight">\(R_2\)</span> とすると、<span class="math notranslate nohighlight">\(\frac{\left(R_1+R_2\right)}{2}\)</span> がダイマー中心、<span class="math notranslate nohighlight">\(\frac{\left(R_1-R_2\right)}{\left|R_1-R_2\right|}\)</span> がベクトル <span class="math notranslate nohighlight">\(N\)</span> に相当します。</p>
</section>
<section id="id105">
<h3><span class="section-number">9.6.3. </span>計算の実行方法<a class="headerlink" href="#id105" title="この見出しへのパーマリンク"></a></h3>
<p>NEB法と同様dimer法は「レプリカ並列」に対応しています。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>% mpirun -n NP phase ne=NE nk=NK nr=2
</pre></div>
</div>
<p>ただしNEB法と違いレプリカ数は常に2なので、レプリカ並列の最大並列数は2です。</p>
</section>
<section id="id106">
<h3><span class="section-number">9.6.4. </span>出力ファイル<a class="headerlink" href="#id106" title="この見出しへのパーマリンク"></a></h3>
<p>結果はnfefn.dataおよびnfdynm.dataファイルに記録されます。nfefn.dataファイルの内容は、典型的には下記のようになります。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>1      -43.925344990434660        0.0353683091
2      -43.926190890438960        0.0336994667
3      -43.927411726085005        0.0330083334
...
...
</pre></div>
</div>
<p>1カラム目がdimer iterationの回数、2カラム目がダイマー中心のエネルギー、3カラム目が並進力です。nfdynm.dataファイルには、通常のnfdynm.dataファイルと同じ形式でダイマー中心の座標データがdimer iterationごとに出力されます。</p>
</section>
<section id="si">
<h3><span class="section-number">9.6.5. </span>計算例1: Si上の水素分子解離<a class="headerlink" href="#si" title="この見出しへのパーマリンク"></a></h3>
<p>NEB法の例題にも付属するSi上での水素分子解離の過程をdimer法によって解析します。入力データは <code class="code docutils literal notranslate"><span class="pre">samples/dynamics/dimer/h-Si</span></code> 以下にあります。
用いた初期ダイマーはNEBで得られたレプリカ列のうち遷移状態の前後2つのレプリカを抽出して作成しました。その他Dimer法に関わる計算条件は以下の通り。</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>設定値</p></td>
<td><p>値</p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(\Delta R\)</span></p></td>
<td><p>0.01</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(d \theta\)</span></p></td>
<td><p>0.001 radian</p></td>
</tr>
<tr class="row-even"><td><p>収束判定条件</p></td>
<td><p>5e-4</p></td>
</tr>
</tbody>
</table>
<p>Dimer法のエネルギーおよび最大並進力を <a class="reference internal" href="#dimer-si-image1"><span class="std std-numref">図 9.35</span></a> に示します。もともと遷移状態に近いところから計算を始めているため、比較的スムーズな収束が得られています。</p>
<figure class="align-default" id="dimer-si-image1">
<img alt="../_images/dimer_si_image1.svg" src="../_images/dimer_si_image1.svg" /><figcaption>
<p><span class="caption-number">図 9.35 </span><span class="caption-text">Dimer法の履歴</span><a class="headerlink" href="#dimer-si-image1" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
<p><a class="reference internal" href="#dimer-table1"><span class="std std-numref">表 9.6</span></a> に得られた遷移状態をCI-NEB法の結果を比較しました。表中のzとは水素分子のz座標のことです。
Dimer法とCI-NEB法の結果はほぼ一致しました。zの値が異なりますが、これはこの問題がzに対して鈍感であるからと考えられます。</p>
<table class="docutils align-default" id="dimer-table1">
<caption><span class="caption-number">表 9.6 </span><span class="caption-text">CI-NEB法との比較</span><a class="headerlink" href="#dimer-table1" title="このテーブルへのパーマリンク"></a></caption>
<tbody>
<tr class="row-odd"><td></td>
<td><p>CI-NEB</p></td>
<td><p>dimer</p></td>
</tr>
<tr class="row-even"><td><p>energy (Ha)</p></td>
<td><p>-43.9380</p></td>
<td><p>-43.9381</p></td>
</tr>
<tr class="row-odd"><td><p>z (Bohr)</p></td>
<td><p>16.711</p></td>
<td><p>16.748</p></td>
</tr>
</tbody>
</table>
</section>
<section id="pt">
<h3><span class="section-number">9.6.6. </span>計算例2: Ptにおける酸素原子の拡散<a class="headerlink" href="#pt" title="この見出しへのパーマリンク"></a></h3>
<p>NEB法の例題にも付属するPt(111)面における酸素原子拡散の問題をdimer法で計算してみます。入力データは <code class="code docutils literal notranslate"><span class="pre">samples/dynamics/dymer/Pt111</span></code> 以下にあります。
初期ダイマーはNEBの始状態・終状態をもとに作成しました。その他のdimer法の条件はSi上の水素分子の場合と全く同様です。</p>
<figure class="align-default" id="dimer-pt-image1">
<img alt="../_images/dimer_pt_image1.svg" src="../_images/dimer_pt_image1.svg" /><figcaption>
<p><span class="caption-number">図 9.36 </span><span class="caption-text">Dimer法の履歴</span><a class="headerlink" href="#dimer-pt-image1" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
<p><a class="reference internal" href="#dimer-table2"><span class="std std-numref">表 9.7</span></a> に得られた遷移状態をCI-NEB法の結果を比較しました。表中のx, y, zは酸素原子のx, y, z座標です。完全に一致するわけではありませんが、CI-NEB法との差は0.01 bohr程度で両者はよく一致しています。</p>
<table class="docutils align-default" id="dimer-table2">
<caption><span class="caption-number">表 9.7 </span><span class="caption-text">CI-NEB法との比較</span><a class="headerlink" href="#dimer-table2" title="このテーブルへのパーマリンク"></a></caption>
<tbody>
<tr class="row-odd"><td></td>
<td><p>CI-NEB</p></td>
<td><p>dimer</p></td>
</tr>
<tr class="row-even"><td><p>energy (Ha)</p></td>
<td><p>-1308.214122</p></td>
<td><p>-1308.214122</p></td>
</tr>
<tr class="row-odd"><td><p>x (Bohr)</p></td>
<td><p>20.19726</p></td>
<td><p>20.21692</p></td>
</tr>
<tr class="row-even"><td><p>y (Bohr)</p></td>
<td><p>11.66089</p></td>
<td><p>11.67224</p></td>
</tr>
<tr class="row-odd"><td><p>z (Bohr)</p></td>
<td><p>12.64020</p></td>
<td><p>12.63675</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id107">
<h3><span class="section-number">9.6.7. </span>制限事項<a class="headerlink" href="#id107" title="この見出しへのパーマリンク"></a></h3>
<p>Dimer法は継続計算に対応していません。また、途中で打ち切られることも想定していないため、計算時間の上限に達したりするなど打ち切りの条件を満たした際の動作は不定です。</p>
<blockquote>
<div><p><strong>参考文献</strong></p>
</div></blockquote>
<div role="list" class="citation-list">
<div class="citation" id="henkelman99" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id103">Henkelman99</a><span class="fn-bracket">]</span></span>
<p>Graeme Henkelman and Hannes Jónsson “A dimer method for finding saddle points on high dimensional potential surfaces using only first derivatives”, JOURNAL OF CHEMICAL PHYSICS 111 7010-7022 (1999).</p>
</div>
</div>
</section>
</section>
<section id="blue-moon">
<span id="section-constraints-bluemoon"></span><h2><span class="section-number">9.7. </span>拘束条件付きダイナミクスとBlue Moon 法による自由エネルギー解析<a class="headerlink" href="#blue-moon" title="この見出しへのパーマリンク"></a></h2>
<section id="id108">
<h3><span class="section-number">9.7.1. </span>機能の概要<a class="headerlink" href="#id108" title="この見出しへのパーマリンク"></a></h3>
<p>化学反応経路を探索する手法として、ボンド長やボンド角などの化学反応を特徴づける
「反応座標」を導入し、想定した反応経路上でその値を逐次変化させながら
反応座標を拘束した構造最適化や分子動力学シミュレーションを実施する、という手法が
あります。単純な構造最適化の場合絶対零度における反応経路が得られ、有限温度の
分子動力学シミュレーションを実施すると自由エネルギー差が得られます。ここでは、
PHASEを利用して拘束条件付きダイナミクスを追跡する方法を説明します。</p>
</section>
<section id="id109">
<h3><span class="section-number">9.7.2. </span>入力パラメータ<a class="headerlink" href="#id109" title="この見出しへのパーマリンク"></a></h3>
<section id="id110">
<h4><span class="section-number">9.7.2.1. </span>タグ一覧<a class="headerlink" href="#id110" title="この見出しへのパーマリンク"></a></h4>
<p>本機能と関連あるタグの一覧を表に示します。</p>
<table class="longtable docutils align-default" id="id198">
<caption><span class="caption-number">表 9.8 </span><span class="caption-text">拘束条件付きダイナミクスに関連のあるタグの一覧</span><a class="headerlink" href="#id198" title="このテーブルへのパーマリンク"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>第1
ブロック識別子</p></th>
<th class="head"><p>第2、第3ブロ
ック識別子</p></th>
<th class="head"><p>タグ識別子</p></th>
<th class="head"><p>説明</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>control</p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>driver</p></td>
<td><p>ダイナミクスの種類を選択する変数。</p>
<p>拘束条件付きダイナミクスの場合constraintsを指定する。</p>
</td>
</tr>
<tr class="row-even"><td><p>structure</p></td>
<td></td>
<td></td>
<td><p>原子座標データの指定を行うブロック</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>constrainablexx</p></td>
<td></td>
<td><p>拘束条件を定義するブロック。</p>
<p>xxには拘束条件を識別するための整数を1はじまりで指定</p>
</td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>type</p></td>
<td><p>拘束条件の“種類”の指定。</p>
<p>bond_length,
bond_angle,
dihedral_angle
bond_length_diff,
bond_angle_diff,
dist
ance_from_pos,
plane,
center_of_mass,
coordination_number,
distance_from_ref</p>
</td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>atomx</p></td>
<td><p>拘束条件が関わる原子を指定する。xは整数で、たとえばtype
=
bond_length
の場合2原子が拘束に関わるのでatom1とatom2で指定する。</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>mobile</p></td>
<td><p>拘束条件が“可動か否か”を指定する。on
とすると可動、</p>
<p>offとすると不動。デフォルト値はoff</p>
</td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>monitor</p></td>
<td><p>指定の拘束条件を“監視”するかどうかを指定する真偽値。</p>
<p>デフォルト値はoff</p>
</td>
</tr>
<tr class="row-even"><td></td>
<td><p>reaction_coordinate</p></td>
<td></td>
<td><p>指定の拘束条件が“反応座標”としたい場合に作成するブロック。</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>sw_reaction_coordinate</p></td>
<td><p>onの場合反応座標とみなされる。</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>init_value</p></td>
<td><p>反応経路の初期値を対応する単位で指定。</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>final_value</p></td>
<td><p>反応経路の最終値を対応する単位で指定。</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>increment</p></td>
<td><p>final_value,
init_valueの刻み幅を指定。</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>plane</p></td>
<td></td>
<td><p>面内拘束における面の法線ベクトルを指定するブロック</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>normx,normy,normz</p></td>
<td><p>法線ベクトルのx,y,z成分</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>distance_from_pos</p></td>
<td></td>
<td><p>場所の指定を行うブロック</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>posx,posy,posz</p></td>
<td><p>指定したい場所のx,y,z成分</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>coordination_number</p></td>
<td></td>
<td><p>配位数指定を行うブロック</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>kappa_inv</p></td>
<td><p>配位数定義式の<span class="math notranslate nohighlight">\(\kappa\)</span>
の逆数を長さの単位で指定</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>kappa</p></td>
<td><p>配位数定義式の<span class="math notranslate nohighlight">\(\kappa\)</span>
1/bohr単位で指定</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>rcut</p></td>
<td><p>配位数定義式の<span class="math notranslate nohighlight">\(r_c\)</span>
の値を長さの単位で指定</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>center_of_mass</p></td>
<td></td>
<td><p>重心を変化させる方向を指定するブロック</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>directionx</p></td>
<td><p>指定したい方向のx成分</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>directiony</p></td>
<td><p>指定したい方向のy成分</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>directionz</p></td>
<td><p>指定したい方向のz成分</p></td>
</tr>
<tr class="row-odd"><td><p>structure_evolution</p></td>
<td></td>
<td></td>
<td><p>原子ダイナミクスの設定を行うブロック</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>method</p></td>
<td><p>原子ダイナミクスの方法を指定する。</p>
<p>拘束条件付きダイナミクスの場合</p>
<p>quench,damp,
velocity_verlet
temperature_control</p>
<p>のみ利用可能。</p>
</td>
</tr>
</tbody>
</table>
</section>
<section id="driver">
<h4><span class="section-number">9.7.2.2. </span>driver変数の設定<a class="headerlink" href="#driver" title="この見出しへのパーマリンク"></a></h4>
<p>拘束条件付きダイナミクスを実行するには、まず以下の要領でconditionブロックの下でdriver変数を指定します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>condition{
  ...
  driver=constraints
  ...
}
</pre></div>
</div>
</section>
<section id="id111">
<h4><span class="section-number">9.7.2.3. </span>拘束条件の設定<a class="headerlink" href="#id111" title="この見出しへのパーマリンク"></a></h4>
<p>拘束条件を設定するには以下のようにstructureブロックの下にconstrainablexxブロックを作成します。ここでxxは整数です。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>structure{
    ...
    ...
    constrainable1{
       type=bond_length
       atom1=1
       atom2=2
       mobile = off
       monitor = off
       reaction_coordinate{
          sw_reaction_coordinate=on
          init_value = 2.4 angstrom
          increment  = 0.1 angstrom
          final_value = 8.0 angstrom
       }
       plane{
           normx=1
           normy=0
           normz=0
       }
       coordination_number{
           kappa = 5.0
           rc     = 2.0 angstrom
       }
    }
    ...
    ...
}
</pre></div>
</div>
<p>拘束条件はいくつでも指定可能ですが、たとえばconstrainable1,
constrainable2,
constrainable4という3つのconstrainablexxブロックが存在する場合、constrainable4ブロックは入力解釈の対象にはなりません。また、互いに相いれない拘束条件を定義してしまうと、拘束条件を課すための収束計算が破たんしてしまう場合がありますので注意が必要です。
constrainablexxブロックの下では、以下の変数/ブロックを指定することができます。</p>
<table class="longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p>type変数</p></td>
<td></td>
<td><p>拘束条件の“種類”を指定します。以下のいずれかの値をとります。</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>bond_length</p></td>
<td><p>2原子間</p>
<p>の距離を拘束します。</p>
</td>
</tr>
<tr class="row-odd"><td></td>
<td><p>bond_angle</p></td>
<td><p>3原子の成す角度を拘束します。</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>dihedral_angle</p></td>
<td><p>4原子の2面角を拘束します。</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>bond_length_diff</p></td>
<td><p>2原子間の距離の差を拘束します。</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>bond_angle_diff</p></td>
<td><p>3原子が成す角度の差を拘束します。</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>distance_from_pos</p></td>
<td><p>指定の場所からの距離を拘束します。</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>plane</p></td>
<td><p>面内に指定の原子を拘束します。</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>center_of_mass</p></td>
<td><p>指定の原子群の重心を拘束します。</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>coordination_number</p></td>
<td><p>配位数を拘束します。配位数の決め方は後述します。</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>distance_from_ref</p></td>
<td><p>参照構造から距離を拘束します。</p></td>
</tr>
<tr class="row-even"><td><p>atomx 変数</p></td>
<td></td>
<td><p>指定の拘束条件が関わる原子を指定します。xは数字であり、たとえば2原子間の距離の場合は2つの原子が拘束に関わるので、atom1とatom2に対応する原子の番号を指定します。typeがcoordination_numberの場合、配位数を計算する中心の原子の番号を指定します。</p></td>
</tr>
<tr class="row-odd"><td><p>mobile 変数</p></td>
<td></td>
<td><p>指定の拘束条件が“可動か否か”を指定するためのスイッチです。offとすると拘束され、onとすると拘束はされません。デフォルト値はoffです。</p></td>
</tr>
<tr class="row-even"><td><p>monitor 変数</p></td>
<td></td>
<td><p>指定の拘束条件を“監視”（値を算出し、ログファイルに出力）するか否かを指定するスイッチです。デフォルト値はoffです。</p></td>
</tr>
<tr class="row-odd"><td><p>reaction_coordinate
ブロック</p></td>
<td></td>
<td><p>指定の拘束条件が、“反応座標(逐次値を変化させられる)”である場合に作成するブロックです。以下の変数を指定することができます。</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>sw_reaction_coordinate</p></td>
<td><p>onの際、反応座標とみなされます。</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>init_value</p></td>
<td><p>反応経路の初期値を、対応する単位で指定します。指定がない場合、入力の原子配置から求められる値が採用されます。この値と、入力の原子配置から求められる値が異なる場合、入力の原子配置が修正されたのちに計算が実行されます。このため、一回目の(拘束力も含む)原子に働く力の最大値が見掛け上非常に大きな値となることがありますが、これは正常な振る舞いです。</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>final_value</p></td>
<td><p>反応経路の最終値を対応する単位で指定します。</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>increment</p></td>
<td><p>final_valueとinit_valueの間の刻み幅を指定します。</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>反応座標を逐次変化させる場合,以下のケースは特殊であるので注意が必要です.</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>typeがplaneの場合</p></td>
<td><p>この場合、変化するのは面の原点です.原点の座標値は、指定の法線ベクトルと原子の座標値からプログラムが自動的に決めますが、反応座標の変化としては、法線ベクトルの方向に原点が変化する、という振る舞いになります。init_value,
final_value,
incrementは、この原点の移動量を指定してください。なお、この場合のinit_valueのデフォルト値は0ですが、通常明示的に指定する必要はないはずです。</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>typeが
center_of_massの場合</p></td>
<td><p>この場合、重心を、指定の方向に移動させます。init_value,
final_value,
incrementは、この移動量を指定してください。なお、この場合のinit_valueのデフォルト値は0ですが、通常明示的に指定する必要はないはずです。</p></td>
</tr>
<tr class="row-odd"><td><p>planeブロック</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td></td>
<td><p>normx</p></td>
<td><p>法線ベクトルの<span class="math notranslate nohighlight">\(x\)</span>座標。</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>normy</p></td>
<td><p>法線ベクトルの<span class="math notranslate nohighlight">\(y\)</span>座標。</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>normz</p></td>
<td><p>法線ベクトルの<span class="math notranslate nohighlight">\(z\)</span>座標。</p></td>
</tr>
<tr class="row-odd"><td><p>distance_from_posブロック</p></td>
<td></td>
<td><p>typeとしてdistance_from_posを採用する場合の、場所の指定を行うブロックです。次の変数を指定することができます。</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>posx</p></td>
<td><p>指定したい場所の、<span class="math notranslate nohighlight">\(x\)</span> 座標を長さの単位で指定します。</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>posy</p></td>
<td><p>指定したい場所の、<span class="math notranslate nohighlight">\(y\)</span> 座標を長さの単位で指定します。</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>posz</p></td>
<td><p>指定したい場所の、<span class="math notranslate nohighlight">\(z\)</span> 座標を長さの単位で指定します。</p></td>
</tr>
<tr class="row-odd"><td><p>coordination_numberブロック</p></td>
<td></td>
<td><p>配位数拘束の定義式における<span class="math notranslate nohighlight">\(\kappa,r_c\)</span>
の値の設定を行うブロックです。次の変数を指定することができます。</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>kappa_inv</p></td>
<td><p><span class="math notranslate nohighlight">\(\kappa\)</span>の値を、長さの単位で指定します。</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>kappa</p></td>
<td><p><span class="math notranslate nohighlight">\(\kappa\)</span> の値を、1/bohr単位で指定します。kappa_invよりも優先されます。</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>rcut</p></td>
<td><p><span class="math notranslate nohighlight">\(r_c\)</span>の値を、長さの単位で指定します。</p></td>
</tr>
<tr class="row-odd"><td><p>center_of_massブロック</p></td>
<td></td>
<td><p>typeとしてcenter_of_massを採用し、かつ反応座標を変化させる場合、「変化させる方向」をここで指定します。</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>directionx</p></td>
<td><p>変化させる方向の<span class="math notranslate nohighlight">\(x\)</span>
座標を指定します。</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>directiony</p></td>
<td><p>変化させる方向の<span class="math notranslate nohighlight">\(y\)</span>
座標を指定します。</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>directionz</p></td>
<td><p>変化させる方向の<span class="math notranslate nohighlight">\(z\)</span>
座標を指定します。</p></td>
</tr>
<tr class="row-odd"><td><p>reference_structure</p></td>
<td></td>
<td><p>参照構造を指定する
ブロック</p></td>
</tr>
</tbody>
</table>
<p><strong>配位数の決め方</strong></p>
<p>type = coordination_numberの場合、配位数を拘束します。ここで <span class="math notranslate nohighlight">\(j\)</span> 番目の原子の配位数は以下の式によって評価します。</p>
<div class="math notranslate nohighlight">
\[\begin{split}\sigma = \sum_{i \neq j} S\left( \left| \mathbf{r}_i - \mathbf{r}_j \right| \right), \\ S\left(r\right) = \frac{1}{\exp \left[ \kappa \left(r-r_c\right)\right]}.\end{split}\]</div>
<p><span class="math notranslate nohighlight">\(\kappa, r_c\)</span> はパラメーターであり、first coordination shellでほどよく0に近づくように決定します。</p>
<p><strong>参照構造からの距離を拘束する方法（バージョン2023.01以降）</strong></p>
<p>参照構造からの距離を拘束することができます。この拘束条件を用いることによって、たとえば始状態を入力に指定し、終状態を参照構造とし、少しずつ近づけていくというシミュレーションを実行することができます。この機能を用いるにはtype変数にdistance_from_refを指定し、さらにreference_structureブロックに参照構造を指定します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>structure{
    constrainable1{
      type = distance_from_ref
      reaction_coordinate{
        sw_reaction_coordinate = on
        final_value = 0.1 bohr
        increment = -0.2 bohr
      }
      reference_structure{
        coordinate_system = internal
        atoms{
        #tag    no rx    ry    rz
              1 0.2943425771929825 0.4469155567738791 0.4539110432261209
              9 0.45301117987329437 0.44621817768031197 0.2955079284113061
        }
      }
    }
  }
</pre></div>
</div>
<p>reference_structureの下のcoordinate_systemによって座標をデカルト座標で記述するか(cartesian)フラクショナル座標で記述するか(internal)を指定します。coordinate_systemのデフォルト値はinternalです。atomsブロックにおいて参照構造の座標を記述します。通常の座標の記述と違い、元素の指定は不要です（あっても無視されます）。noというカラムを設けると一部の原子のみ対象とすることができます。上述の例ではnoが1および9で、これは1番目の原子と9番目の原子のみ指定を行っていることになります。このように設定すると1番目と9番目の原子以外は等価な構造であるとみなされます。noカラムが存在しない場合はすべての原子をもとの座標データと同じ順序で記述する必要があります。</p>
<p><strong>重心間の距離・角度・二面角を拘束する方法 (バージョン2023.01以降)</strong></p>
<p>重心間の距離/角度/二面角を拘束することができます。この拘束条件を用いる場合type変数には通常通りbond_length, bond_angle, dihedral_angleを設定します。さらにatom1, atom2などの変数をブロックに変更し、対象となる原子群を設定します。たとえば以下のように設定します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>constrainable1{
  type = bond_length
  atom1{
    #tag no
    1,2,4,5,13,34
  }
  atom2{
    #tag no
    7,8,9,10,12,36
  }
}
</pre></div>
</div>
<p>通常の原子間の距離/角度/二面角の場合atom1 = 1 atom2 = 2 … という具合に原子の番号を直接指定しますが、原子群を指定する場合はatom1, atom2, … をブロックとし、表形式データを作成します。表形式データはnoという属性値一つだけを持ち、原子群を構成する原子の番号を指定します。原子群の場合はatom_group1, atom_group2, … などと指定することもできますが二つのスタイルを混在させる場合末尾の数値はユニークである必要があります。すなわち、atom1, atom_group2, …などと指定します。上述の例で示しているように、一行に一原子を指定するスタイルだけでなくカンマで区切るスタイルも利用することができます。通常通り1行に1つの番号を指定することもできます。</p>
</section>
<section id="id112">
<h4><span class="section-number">9.7.2.4. </span>ダイナミクスのアルゴリズムの指定<a class="headerlink" href="#id112" title="この見出しへのパーマリンク"></a></h4>
<p>拘束条件の指定の次は、採用するダイナミクスのアルゴリズムを指定します。通常のPHASEの入力と同様、structure_evolutionブロックの下で行います。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>structure_evolution{
    method=quench
    dt=40
    ...
}
</pre></div>
</div>
<p>ここで、methodとしてはquench, damp, velocity_verlet,
temperature_controlを利用することができます。拘束条件を課している場合、gdiis,
cgなどには現バージョンでは未対応なのでご注意ください。また、dampはdamped
molecular
dynamics法による構造最適化を実施する場合に指定します。この手法は、多くの場合単純なquenched
MDよりは大きな時間刻み(dt)を採用することができ、速く収束させることのできる手法です。</p>
</section>
<section id="id113">
<h4><span class="section-number">9.7.2.5. </span>反応座標を変化させる指定<a class="headerlink" href="#id113" title="この見出しへのパーマリンク"></a></h4>
<p>次に、反応座標の変化の指定方法について説明します。</p>
<ul class="simple">
<li><p>反応座標を逐次変化させる方法</p></li>
</ul>
<p>反応座標を逐次変化させる場合、constrainablexブロックの下にreaction_coordinateブロックを作成し、設定を行います。たとえば以下のように設定します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>structure{
    ....
    ....
    constrainable1{
      type = bond_length
      atom1 = 1
      atom2 = 2
      reaction_coordinate{
        sw_reaction_coordinate = on
        init_value = 2.5 bohr
        final_value = 3.5 bohr
        increment = 0.1 bohr
      }
    }
</pre></div>
</div>
<p>sw_reaction_coordinate = on と設定すると反応座標を変化させます。変化のタイミングは、拘束条件付き最適化の場合処理中の拘束条件において収束が達成できたあと、拘束条件つき分子動力学シミュレーションの場合指定のステップ数を経たあとになります。init_valueは拘束条件の初期値です。指定がない場合入力座標から計算される値がそのまま採用されます。final_valueには最終的に到達する値を指定します。incrementにはinit_valueとfinal_valueの間の刻み幅を指定します。</p>
<ul class="simple">
<li><p>複数の反応座標を逐次変化させる方法</p></li>
</ul>
<p>複数の反応座標を逐次変化させる場合のプログラムの振る舞いを説明します。たとえば以下のように入力で指定した場合について説明します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>structure{
    ....
    ....
    constrainable1{
      mobile = off
      monitor = on
      type = dihedral_angle
      atom1 = 2
      atom2 = 4
      atom3 = 3
      atom4 = 1
      reaction_coordinate{
        sw_reaction_coordinate = on
        init_value = -179 degree
        final_value = -1 degree
        increment = 5 degree
      }
    }
    constrainable2{
      type=bond_length
      monitor=on
      atom1=3
      atom2=4
      reaction_coordinate{
        sw_reaction_coordinate=on
        init_value = 1.2 angstrom
        final_value = 1.6 angstrom
        increment = 0.05 angstrom
      }
    }
    ....
    ....
}
</pre></div>
</div>
<p>まず、constrainable1ブロックにおいて2面角を-179°から-1°まで5°刻みで変化させるように指定しています。
さらに、constrainable2ブロックにおいてはボンド長を1.2 Åから1.6 Åまで0.05
Å刻みで変化させるように指定をしています。このような入力を記述した場合、
まずボンド長を1.2
Åに固定した状態で2面角を-179°から-1°まで変化させて計算が実行されます。-1°の計算が終了したら、次はボンド長を1.25
Åに変化させ、今度は-1°から-179°まで2面角を変化させる計算を実行します。このような変化のさせ方を採用することによって、隣り合う反応座標の組の間で原子配置が
極端に変化することを防いでいます。</p>
<p>以上のような方針で検討する反応座標が決まりますので、合計すると検討する反応座標の数は反応座標<span class="math notranslate nohighlight">\(\alpha\)</span>において検討する反応座標の数を<span class="math notranslate nohighlight">\(n_{\alpha}\)</span>とすると<span class="math notranslate nohighlight">\(\prod_{\alpha}^{}n_{\alpha}\)</span>となります。これよりもきめ細やかに反応座標の組を指定するには、次に説明する「反応座標の変化の仕方をファイルを介して指定する」機能を利用します。</p>
<ul class="simple">
<li><p>ファイルから反応座標の変化の仕方を指定する方法</p></li>
</ul>
<p>拘束条件の変化のさせ方は上述のreaction_coordinateブロックにおいて指定しますが、この方法の場合は等間隔の指定です。特に前述の、複数の反応座標を変化させる計算においては、反応座標<span class="math notranslate nohighlight">\(\alpha\)</span>において検討する反応座標の数を<span class="math notranslate nohighlight">\(n_{\alpha}\)</span>とすると<span class="math notranslate nohighlight">\(\prod_{\alpha}^{}n_{\alpha}\)</span>個の反応座標を検討することになり、計算時間が膨大になることがあります。このような制限が問題となる場合に、「反応座標（の組）」をファイルから指定することが可能となっています。</p>
<p>まず、検討したい拘束条件をconstrainablexxブロックにおいて通常通り指定します。次に、structureブロックの下に以下の変数を定義します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>structure{
  ....
  reac_coord_generation = via_file
  ....
}
</pre></div>
</div>
<p>最後に、作業ディレクトリーにreac_coords.dataというファイル名のファイルを作成し、次のような内容を記述します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span> 1       -1.9373154697        2.2676711906
 2       -1.7627825445        2.2676711906
 3       -1.5882496193        2.2676711906
 4       -1.4137166941        2.2676711906
 5       -1.2391837689        2.2676711906
 6       -1.0646508437        2.2676711906
 7       -0.8901179185        2.2676711906
 8       -0.7155849933        2.2676711906
 9       -0.7155849933        2.3621574902
10       -0.8901179185        2.3621574902
11       -1.0646508437        2.3621574902
12       -1.2391837689        2.3621574902
13       -1.4137166941        2.3621574902
14       -1.5882496193        2.3621574902
15       -1.7627825445        2.3621574902
16       -1.9373154697        2.3621574902
17       -1.9373154697        2.4566437898
18       -1.7627825445        2.4566437898
19       -1.5882496193        2.4566437898
20       -1.4137166941        2.4566437898
21       -1.2391837689        2.4566437898
22       -1.0646508437        2.4566437898
23       -0.8901179185        2.4566437898
24       -0.7155849933        2.4566437898
          ......
          ......
          ......
</pre></div>
</div>
<p>各行が1つの反応座標の組に相当します。行の1列目にはその反応座標の組を識別するための番号を整数で入力します。2列目以降は、定義した拘束条件の順番で反応座標の値を入力します。
この例では2種類の反応座標を検討していることになります。1つ目の反応座標の組では1番目の拘束条件として“-1.9373154697”という値、2番目の拘束条件として“2.26711906”という値を
指定することになります。単位は、PHASEのデフォルトの単位を利用して指定するようにしてください。長さならばbohr単位,
角度ならradian単位です。</p>
</section>
</section>
<section id="id114">
<h3><span class="section-number">9.7.3. </span>計算の実行方法<a class="headerlink" href="#id114" title="この見出しへのパーマリンク"></a></h3>
<p>拘束条件付きダイナミクスは、「反応座標を逐次変化させて計算する」ケースにおいては原子配置に対する並列計算に対応しています。PHASEを以下のように起動してください。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>% mpirun -np NP phase ne=NE nk=NK nr=NR
</pre></div>
</div>
<p>ここで、NPがMPIプロセス数、NEがバンド並列数、NKが<span class="math notranslate nohighlight">\(\mathbf{k}\)</span>点並列数、NRが原子配置並列数であり、NP = NE x NK x NRという関係が成立している必要があります。
この機能を利用する場合、継続計算の処理がプログラム内で若干変化するので、継続計算間でnrを指定したりしなかったりするとエラーとなる点にご注意ください。
nrは1でも構わないので、原子配置並列を継続計算のあるタイミングで無効にする場合、NRを1とすれば目的の動作を達成することができます。</p>
</section>
<section id="id115">
<h3><span class="section-number">9.7.4. </span>計算結果の出力<a class="headerlink" href="#id115" title="この見出しへのパーマリンク"></a></h3>
<p>出力ファイルは、「反応座標を逐次変化させる」機能を利用していない場合は通常のPHASEの出力と
同様です。すなわち、file_names.dataファイルにおいてF_ENF識別子によって指定される
ファイルに各ステップにおけるエネルギーや原子に働く力の最大値が、F_DYNM識別子によって
指定されるファイルに各ステップにおける原子配置や各原子に働く力が出力されます。
ただし、「原子に働く力の最大値」は、拘束条件を課すために必要な「拘束力」も含む点に
注意が必要です。</p>
<p>他方、「反応座標を逐次変化させる」計算を実行している場合、次のようなファイル群が出力されます(ここで、F_ENF識別子によって指定されるファイルのファイル名をnfefn.data,
F_DYNM識別子によって指定されるファイルのファイル名をnfdynm.dataとします)。</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>ファイル名</p></th>
<th class="head"><p>説明</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>nfefn.data.reacxx</p></td>
<td><p>xx番目の反応座標の、各ステップにおけるエネルギーおよび原子に働く力の最大値のデータが出力されます。</p></td>
</tr>
<tr class="row-odd"><td><p>nfefn.data.converged</p>
<p>(構造最適化の場合のみ)</p>
</td>
<td><p>各反応座標において、反応座標の値そのものと、収束したエネルギーおよび原子に働く力の最大値が出力されます。反応座標とエネルギーの関係をプロットすることによって、「反応経路」と「エネルギー」の関係を解析することができます。</p></td>
</tr>
<tr class="row-even"><td><p>nfdynm.data.reacxx</p></td>
<td><p>xx番目の反応座標の、各ステップにおける原子配置や原子に働く力が出力されます。</p></td>
</tr>
<tr class="row-odd"><td><p>nfdynm.data.converged</p>
<p>(構造最適化の場合のみ)</p>
</td>
<td><p>各反応座標において、構造最適化が収束した後の原子配置が出力されます。</p></td>
</tr>
<tr class="row-even"><td><p>nfbluemoon.data.reacxx</p>
<p>(分子動
力学シミュレーションの場合のみ)</p>
</td>
<td><p>xx番目の反応座標の、自由エネルギー差を算出するために必要なラグランジュの未定乗数の値が記録されます。</p></td>
</tr>
</tbody>
</table>
<p>さらに、継続計算ファイルや波動関数・電荷密度ファイルなどは反応座標ごとに出力されます。</p>
</section>
<section id="id116">
<h3><span class="section-number">9.7.5. </span>Blue Moon法による自由エネルギーの計算<a class="headerlink" href="#id116" title="この見出しへのパーマリンク"></a></h3>
<section id="id117">
<h4><span class="section-number">9.7.5.1. </span>機能の概要<a class="headerlink" href="#id117" title="この見出しへのパーマリンク"></a></h4>
<p>拘束条件付きの分子動力学シミュレーションが発生する統計集合(blue moon
ensemble)のデータを利用すると、検討した反応座標の経路上における自由エネルギーの変化を算出することができます <a class="reference internal" href="#sprik98" id="id118"><span>[Sprik98]</span></a> 。</p>
<p>反応座標が<span class="math notranslate nohighlight">\(\xi_{1}\)</span>から<span class="math notranslate nohighlight">\(\xi_{2}\)</span>へ変化する場合の自由エネルギー差は、次のように計算することが可能です。</p>
<div class="math notranslate nohighlight" id="equation-advanced-bm-eq1">
<span class="eqno">(9.27)<a class="headerlink" href="#equation-advanced-bm-eq1" title="この数式へのパーマリンク"></a></span>\[W\left( \xi_{1} \right) - W\left( \xi_{2}) \right) = \int_{\xi_{2}}^{\xi_{1}}d\xi\frac{\partial W}{\partial\xi}.\]</div>
<p>ここで自由エネルギーの反応座標微分、<span class="math notranslate nohighlight">\(\left\langle \frac{\partial W}{\partial\xi} \right\rangle_{\xi}\)</span>はmean
forceと呼ばれる物理量であり、ハミルトニアンの反応座標微分と次のような関係があります。</p>
<div class="math notranslate nohighlight" id="equation-advanced-bm-eq2">
<span class="eqno">(9.28)<a class="headerlink" href="#equation-advanced-bm-eq2" title="この数式へのパーマリンク"></a></span>\[\frac{\partial W}{\partial\xi} = \left\langle \frac{\partial H}{\partial\xi} \right\rangle_{\xi}^{\text{cond}}.\]</div>
<p>ここで<span class="math notranslate nohighlight">\(\left\langle \cdots \right\rangle^{\text{cond}}\)</span>とは「条件付き統計平均」です。拘束条件付き分子動力学シミュレーションの統計平均と条件付き統計平均は単純には結びつきませんが、拘束条件付き分子動力学を遂行する際に計算するラグランジュの未定乗数<span class="math notranslate nohighlight">\(\lambda\)</span>を利用して以下のように計算することができます。</p>
<div class="math notranslate nohighlight" id="equation-advanced-bm-eq3">
<span class="eqno">(9.29)<a class="headerlink" href="#equation-advanced-bm-eq3" title="この数式へのパーマリンク"></a></span>\[\frac{\partial W}{\partial\xi} = - \frac{\left\langle \left| \Xi \right|^{- 1/2}\lambda \right\rangle}{\left\langle \left| \Xi \right|^{- 1/2} \right\rangle}\]</div>
<div class="math notranslate nohighlight">
\[\Xi = \sum_{i}^{}\frac{1}{m_{i}}\frac{\partial\xi}{\partial{\overrightarrow{r}}_{i}}\frac{\partial\xi}{\partial{\overrightarrow{r}}_{i}}\]</div>
<p>上式には、厳密にはより複雑な補正項がつきますが、実用上は問題ないとされています。</p>
<p>PHASEによる拘束条件付き分子動力学シミュレーションの結果から自由エネルギー差を計算するには,
PHASEパッケージに付属しているbluemoonプログラムを利用します。</p>
<p>現バージョンでは、bluemoonプログラムは反応座標が1つの場合のみに対応しています。</p>
</section>
<section id="bluemoon">
<h4><span class="section-number">9.7.5.2. </span>bluemoonプログラムのコンパイル<a class="headerlink" href="#bluemoon" title="この見出しへのパーマリンク"></a></h4>
<p>bluemoonプログラムのソースコードは、PHASEインストールディレクトリーのsrc_bmディレクトリーに納められています。bluemoonプログラムはFortran90コンパイラーとCコンパイラーを必要とします。Fortran90コンパイラーを環境変数F90に、Cコンパイラーを環境変数CCに設定し、makeコマンドを発行すればコンパイルすることができます。以下はお使いのシステムがbashで、Fortranコンパイラーのコマンドがf90、Cコンパイラーのコマンドがccの場合の例です。</p>
<pre class="literal-block">% cd phase0_2024.01
% cd src_bm
% export F90=f90
% export CC=cc
% make
% make install</pre>
<p>環境変数F90とCCの指定がない場合、gfortranとgccがデフォルト値として利用されます。
コンパイルが終了すると、bluemoonという名前の小さなプログラムが作成されます。 % make installとすると &quot;phase0_2024.01/bin&quot; ディレクトリーの下にbluemoonを移すことができます。</p>
</section>
<section id="id119">
<h4><span class="section-number">9.7.5.3. </span>bluemoonプログラムの入力パラメータ<a class="headerlink" href="#id119" title="この見出しへのパーマリンク"></a></h4>
<p>bluemoonプログラムの入力ファイルは、PHASEのそれと同等です。nfinp.dataファイルにthermodynamic_integrationブロックを作成し、計算条件を入力します。たとえば以下のようになります。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>thermodynamic_integration{
  nsteps=2000
  nequib=1000
  istart_reac_coords=1
  nreac_coords=14
  nsample=10
  smooth=off
  basedir=.
}
</pre></div>
</div>
<p>thermodynamic_integrationブロックでは以下の指定を行うことができます。</p>
<table class="longtable docutils align-default" id="id199">
<caption><span class="caption-number">表 9.9 </span><span class="caption-text">拘束条件付きダイナミクスに関連のあるタグの一覧</span><a class="headerlink" href="#id199" title="このテーブルへのパーマリンク"></a></caption>
<tbody>
<tr class="row-odd"><td><p>nsteps</p></td>
<td><p>各反応座標における分子動力学シミュレーションの総ステップ数を指定します。デフォルト値は2000ですが、実施した計算に合わせて変更してください。</p></td>
</tr>
<tr class="row-even"><td><p>nequib</p></td>
<td><p>nstepsの内、平衡化のため捨てるステップ数を指定します。nstepsよりも小さく、熱平衡に至ったと考えられる値を指定してください。</p></td>
</tr>
<tr class="row-odd"><td><p>istart_reac_coords</p></td>
<td><p>最初に検討する反応座標のIDを入力します。デフォルト値は1です。</p></td>
</tr>
<tr class="row-even"><td><p>nreac_coords</p></td>
<td><p>最後に検討する反応座標の数を指定します。</p></td>
</tr>
<tr class="row-odd"><td><p>nsample</p></td>
<td><p>統計誤差を見積もる場合に</p>
<p>シミュレーションを何分割するかを指定します。</p>
</td>
</tr>
<tr class="row-even"><td><p>smooth</p></td>
<td><p>onとすると、三次のスプライン関数によって計算結果を滑らかにします。</p></td>
</tr>
<tr class="row-odd"><td><p>basedir</p></td>
<td><p>結果を出力するディレクトリーを指定します。デフォルト値はカレントディレクトリーです。</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id120">
<h4><span class="section-number">9.7.5.4. </span>bluemoonプログラムの実行方法<a class="headerlink" href="#id120" title="この見出しへのパーマリンク"></a></h4>
<p>以上のような入力を作成したら、次のようにbluemoonを走らせます。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>% bluemoon inputfile
</pre></div>
</div>
<p>引数で指定するinputfileは入力ファイルのファイル名です。指定がない場合、nfinp.dataという文字列が採用されます。</p>
</section>
<section id="id121">
<h4><span class="section-number">9.7.5.5. </span>計算結果の出力<a class="headerlink" href="#id121" title="この見出しへのパーマリンク"></a></h4>
<p>計算が終了すると、次のファイルが作成されます。</p>
<ul class="simple">
<li><p>potential_of_mean_force.data</p></li>
</ul>
<p>自由エネルギーの計算結果が出力されます。以下のような形式で出力されます。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>#value, potetial of mean force in Hartree, eV, kcal/mol, kJ/mol
2.4566437898 -0.0215821952 0.0003443042 -0.5872816633 0.0093689992 -13.5430301648 0.2160541460 -56.6640534911 0.9039707906
2.2676711910 -0.0224669448 0.0003796767 -0.6113569350 0.0103315334 -14.0982188431 0.2382507016 -58.9869635475 0.9968412043
2.0786985910 -0.0226882285 0.0004435350 -0.6173783747 0.0120692073 -14.2370764737 0.2783223931 -59.5679440305 1.1645012069
                                                ............
                                                ............
                                                ............
</pre></div>
</div>
<p>各行が1つの反応座標のデータに相当します。1列目が反応座標の値、2列目、3列目がハートリー単位、4列目、5列目が電子ボルト単位、6行目と7行目がkcal/mol単位、8行目と9行目がkJ/mol単位での自由エネルギーとその統計誤差の結果に対応します。</p>
<ul class="simple">
<li><p>mean_force_raw.data</p></li>
</ul>
<p>検討した反応座標から得られるmean
forceの計算結果が出力されます。次のような形式で出力されます。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>2.4566437898        0.0066082098        0.0188118786
2.2676711910        0.0034758686        0.0099291734
2.0786985910       -0.0009537509        0.0028573953
1.8897259920       -0.0074922663        0.0213420952
1.7007533930       -0.0098143395        0.0279585555
1.5117807940       -0.0157974842        0.0449758051
1.3228081950       -0.0161451965        0.0459534340
                    ............
                    ............
                    ............
</pre></div>
</div>
<p>potential_of_mean_force.dataファイルと同様に、各行が1つの反応座標のデータに相当します。1列目が反応座標の値、2列目がmean
forceの値(単位：hartree/対応する反応座標の単位)、3列目が統計誤差に相当します。</p>
<ul class="simple">
<li><p>mean_force_smoothed.data</p></li>
</ul>
<p>三次のスプライン関数によって自由エネルギー計算を滑らかにする場合mean
forceを滑らかにしたあとに <a class="reference internal" href="#equation-advanced-bm-eq1">(9.27)</a> 式の積分を実施しますが、その滑らかにしたmean
forceの計算結果が出力されます。
そのデータ形式は、mean_force_raw.dataファイルから統計誤差の列を除いたものになります。</p>
</section>
</section>
<section id="h2o2h2s2">
<h3><span class="section-number">9.7.6. </span>計算例：H<sub>2</sub>O<sub>2</sub>およびH<sub>2</sub>S<sub>2</sub>分子の回転障壁の解析<a class="headerlink" href="#h2o2h2s2" title="この見出しへのパーマリンク"></a></h3>
<p>拘束条件付き構造最適化計算の例として、H<sub>2</sub>O<sub>2</sub>およびH<sub>2</sub>S<sub>2</sub>分子の回転障壁の解析例を紹介します。
H<sub>2</sub>O<sub>2</sub>, H<sub>2</sub>S<sub>2</sub>は <a class="reference internal" href="#advanced-constraint-h2o2-h2s2"><span class="std std-numref">図 9.37</span></a> で示す分子構造を有する単純な分子です。HOOH
(HSSH)が成す2面角の回転ポテンシャルは、H原子同士の相互作用とH原子とO(S)原子の孤立原子対との相互作用が競合し、W型ポテンシャルになることが知られています。2面角を拘束した構造最適化を複数の2面角において実施することにより、このような振る舞いが得られるかどうかを確認します。</p>
<figure class="align-default" id="advanced-constraint-h2o2-h2s2">
<img alt="../_images/image199.png" src="../_images/image199.png" />
<figcaption>
<p><span class="caption-number">図 9.37 </span><span class="caption-text">H<sub>2</sub>O<sub>2</sub>およびH<sub>2</sub>S<sub>2</sub>分子の分子構造</span><a class="headerlink" href="#advanced-constraint-h2o2-h2s2" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
<p>この例題の入力ファイルは、 <code class="code docutils literal notranslate"><span class="pre">samples/dynamics/constraints</span></code> ディレクトリー以下、 <code class="code docutils literal notranslate"><span class="pre">H2O2</span></code> および <code class="code docutils literal notranslate"><span class="pre">H2S2</span></code> ディレクトリーにあります。まず、structureブロックの下には以下の記述があります。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>structure{
    constrainable1{
      type = dihedral_angle
      atom1 = 2
      atom2 = 4
      atom3 = 3
      atom4 = 1
      reaction_coordinate{
        sw_reaction_coordinate = on
        init_value = 9 degree
        final_value = 179 degree
        increment = 10 degree
      }
    }
    ...
    ...
}
</pre></div>
</div>
<p>constrainable1ブロックを作成し、その下で拘束条件の指定を行っています。この例題では拘束条件は
一つのみ課しますが、互いに相いれる拘束条件であるならばいくつでも定義することが可能です。
今は2面角の拘束を実施するので、type変数としてはdihedral_angleを指定しています。
また、2面角を定義するために必要な4つの原子の番号をatom1からatom4変数によって指定しています。
さらに、reaction_coordinateブロックを作成し、この拘束条件を逐次変化させる指定を行います。
sw_reaction_coordinateをon, init_valueとfinal_valueをそれぞれ9 degreeと179 degree, incrementを10 degreeとしていますが、このような指定によって、9°から179°まで、10°刻みで 2面角を変化させて構造最適化を行います。</p>
<p><a class="reference internal" href="#advanced-constraint-h2o2-h2s2-result"><span class="std std-numref">図 9.38</span></a> に、2面角と最適化の結果得られたエネルギーの関係を示します。<a class="reference internal" href="#advanced-constraint-h2o2-h2s2-result"><span class="std std-numref">図 9.38</span></a> には、実験結果 <a class="reference internal" href="#pelz93" id="id122"><span>[Pelz93]</span></a> も併せて実線で表示しています。一見して明らかなように、計算結果と実験結果はよい一致が得られています（おおよそ1 kcal/mol程度の違い）。</p>
<p>H<sub>2</sub>O<sub>2</sub>とH<sub>2</sub>S<sub>2</sub>の大きな違いは2点あります。1点目は、安定な2面角の値です。H<sub>2</sub>O<sub>2</sub>は4面体の角度である109.5°に近い値が安定であるのに対し、H<sub>2</sub>S<sub>2</sub>は90°付近が安定な2面角です。2点目はtrans障壁エネルギ( <a class="reference internal" href="#advanced-constraint-h2o2-h2s2-result"><span class="std std-numref">図 9.38</span></a> では180°付近の障壁エネルギー）の高さです。H<sub>2</sub>O<sub>2</sub>と比較すると、H<sub>2</sub>S<sub>2</sub>のtrans障壁ははるかに大きく、実験的には約6倍の値が得られています。いずれの点も本計算によって再現されており、妥当な結果が得られているものと考えられます。</p>
<figure class="align-default" id="advanced-constraint-h2o2-h2s2-result">
<img alt="../_images/image200.svg" src="../_images/image200.svg" /><figcaption>
<p><span class="caption-number">図 9.38 </span><span class="caption-text">H<sub>2</sub>O<sub>2</sub>およびH<sub>2</sub>S<sub>2</sub>分子の2面角とエネルギーの関係</span><a class="headerlink" href="#advanced-constraint-h2o2-h2s2-result" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
</section>
<section id="id123">
<h3><span class="section-number">9.7.7. </span>使用における注意点<a class="headerlink" href="#id123" title="この見出しへのパーマリンク"></a></h3>
<p>拘束条件付きダイナミクスは、全ての擬ポテンシャルと組み合わせて利用することができます。継続計算にも対応しています。また、反応座標に対する並列を実行することができます。
反応座標に対して並列計算を行う場合、NEB法の場合と同様以下のようなコマンドを利用します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>% mpirun -n NP phase ne=NE nk=NK nr=NR
</pre></div>
</div>
<p><strong>参考文献</strong></p>
<div role="list" class="citation-list">
<div class="citation" id="sprik98" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id118">Sprik98</a><span class="fn-bracket">]</span></span>
<p>Michiel Sprik and Giovanni Ciccotti, Journal of Chemical Physics <strong>109</strong> (1998) p. 7737.</p>
</div>
<div class="citation" id="pelz93" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id122">Pelz93</a><span class="fn-bracket">]</span></span>
<p>G. Pelz, K. Yamada, and G. Winnewisser, Journal of Molecular Spectroscopy <strong>159</strong>, (1993) p. 507.</p>
</div>
</div>
</section>
</section>
<section id="meta-dynamics">
<span id="section-meta-dynamics"></span><h2><span class="section-number">9.8. </span>Meta-dynamics 法<a class="headerlink" href="#meta-dynamics" title="この見出しへのパーマリンク"></a></h2>
<section id="id124">
<h3><span class="section-number">9.8.1. </span>機能の概要<a class="headerlink" href="#id124" title="この見出しへのパーマリンク"></a></h3>
<p>Meta-dynamics法 <a class="reference internal" href="#laio02" id="id125"><span>[Laio02]</span></a> , <a class="reference internal" href="#iannuzzi03" id="id126"><span>[Iannuzzi03]</span></a> は、化学反応などの障壁エネルギーの存在する過程を効率よく解析するための手法です。Meta-dynamics法においては、<span class="math notranslate nohighlight">\(S_{\alpha}\left( r \right)\)</span> という“集団変数”を導入します。ここでいう集団変数とは、具体的には対象とする系の原子座標から定義可能な反応座標（ボンド長やボンド角などの内部座標や配位数など）を複数集めたものです。各集団変数には、仮想的な“粒子”が割り当てられるます。この、“仮想的な粒子の運動”のことをMeta-dynamicsとよびます。Meta-dynamicsのアルゴリズムをうまく設計することによって、効率よく（検討している集団変数が作る）自由エネルギー表面を探索することができると考えられます。ここでは、PHASEに実装されたMeta-dynamics法の利用方法を説明します。</p>
<p>Meta-dynamics法では、計算の履歴に依存するバイアスポテンシャル<span class="math notranslate nohighlight">\(V\left( t,s \right)\)</span>をある間隔（通常数十から数百MDステップ）で足しこんでいきます。このような方針を採用することによって、自由エネルギー空間において一度訪れた点に訪れづらくする効果が発揮されます。十分長い時間シミュレーションを行うと<span class="math notranslate nohighlight">\(V\left( t,s \right)\)</span>が自由エネルギー空間を埋め尽くしてしまい、反応は自由に起こることができるようになります。この状態に至る<span class="math notranslate nohighlight">\(V\left( t,s \right)\)</span>（に-1を掛けた量）がすなわち自由エネルギーであるとみなすことができます。</p>
<p>Meta-dynamics法によるシミュレーションの模式的な様子を <a class="reference internal" href="#advanced-mtd-schematic"><span class="std std-numref">図 9.39</span></a> に示します。この図では、まずシミュレーションは1の数字が割り当てられた谷から始まります。2のバイアスを足し、さらに3のバイアスを足すと新しい局所極小（図中で最も左側の谷）に至ります。さらに4, 5, 6とバイアスポテンシャルを足すともっともエネルギーの低い谷（図中で最も右側の谷）へ至ることができます。最後に7のバイアスを足し、さらに8のバイアスポテンシャルまで足すと、系は集団変数の空間を自由に行き来できるようになります。この時点でのバイアスポテンシャルに-1を掛けると、それは自由エネルギーと見做すことができることが分かります。</p>
<figure class="align-default" id="advanced-mtd-schematic">
<img alt="../_images/image201.png" src="../_images/image201.png" />
<figcaption>
<p><span class="caption-number">図 9.39 </span><span class="caption-text">Meta-dynamicsシミュレーションの模式図</span><a class="headerlink" href="#advanced-mtd-schematic" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
<p>Meta-dynamics法の特徴として、反応座標と関連付けられた複数の動力学変数の動力学を追跡する点が挙げられます。この考え方を導入することによって、複数の反応座標を検討することが容易となり、また動力学変数自身が“もっともらしい”反応経路を探索してくれる効果が期待できます。また、blue moon法の場合複数の反応座標を取り扱うことは（原理上は可能ではありますが）難しいのに対し、meta dynamics法においては比較的容易です。したがって、反応座標が複数ある場合や、反応経路が自明でない場合などにおいて有効な方法であると考えられます。バイアスポテンシャル導入の方針の違いにより、自由エネルギー表面を粗く、すばやく探索することも、きめ細かく、精度よく探索することも可能です。
Meta-dynamics法シミュレーションは、あらかじめ決められた間隔でバイアスポテンシャルを足しながら進行していきます。この際にバイアスポテンシャルを構築するには、時刻0から現在までのデータをすべて利用して和を取る必要があるので、Meta-dynamics法は<span class="math notranslate nohighlight">\(O\left( t^{2} \right)\)</span> の計算手法となります（ただし、第一原理計算で利用するかぎりこの点が制約になることはないでしょう）。</p>
<p>Meta-dynamics法のハミルトニアンは、具体的には、次のように記述されます。</p>
<div class="math notranslate nohighlight">
\[H_{\text{meta}} = H_{\text{MD}} + \sum_{\alpha}^{}\frac{1}{2}\mu_{\alpha}{\dot{s}}_{\alpha}^{2} + \sum_{\alpha}^{}\frac{1}{2}k_{\alpha}\left( S_{\alpha}\left( \mathbf{r} \right) - s_{\alpha} \right)^{2} + V\left( t,s \right),\]</div>
<div class="math notranslate nohighlight">
\[V\left( t,s \right) = \sum_{t_{i} &lt; t}^{}w{\exp\ }\left\lbrack - \sum_{\alpha}^{}\frac{\left( s_{\alpha}\left( t \right) - s\left( t_{i} \right) \right)^{2}}{2\Delta s_{\alpha}^{2}} \right\rbrack\]</div>
<p>ここで、<span class="math notranslate nohighlight">\(\alpha\)</span>は集団変数に含まれる各変数を識別する変数、<span class="math notranslate nohighlight">\(\mu_{\alpha}\)</span>と<span class="math notranslate nohighlight">\(s_{\alpha}\)</span>はそれぞれ仮想的な粒子の質量と座標、<span class="math notranslate nohighlight">\(S_{\alpha}\left( \mathbf{r} \right)\)</span>は対象としているシステムから定義される「集団変数」、<span class="math notranslate nohighlight">\(k_{\alpha}\)</span>は仮想的な粒子の座標と集団変数を結びつける「ばね定数」、<span class="math notranslate nohighlight">\(V\left( t,s \right)\)</span>がバイアスポテンシャルです。足しこんでいったバイアスポテンシャルを記録しておくと、そこから自由エネルギーを見積もることも可能です。このようなハミルトニアンから得られる動力学は、次のようにまとめることができます。</p>
<ul class="simple">
<li><p>系は、集団変数を通して仮想的な粒子の座標値に緩く拘束される。</p></li>
<li><p>仮想的な粒子の座標は、バイアスポテンシャルの効果によって、すでに訪れた点には再訪づらい。</p></li>
</ul>
<p>仮想的な粒子の座標の運動と系の運動の特徴的なタイムスケールが異なれば（仮想的な粒子の方が長いタイムスケールであれば）、系の運動は仮想的な粒子の運動の影響をそれほどは受けないので局所的には正しく系の運動を追跡し、かつゆるやかに集団変数の張る空間を探索することが可能となります。仮想的な粒子の質量は、上記の原理より集団変数の固有振動モードが系よりも遅くなるように設定します。</p>
<p>Meta-dynamics法は、仮想粒子の動力学を追跡するのではなく、系に直接バイアスポテンシャルを足しこんでいくことによって実現する手法もあります <a class="reference internal" href="#laio05" id="id127"><span>[Laio05]</span></a> 。このような方針を採用すると、仮想的な粒子の質量やそれと集団変数を結びつけるばね定数の定義が不要となり、よりシンプルに実行することが可能となります。</p>
</section>
<section id="id128">
<h3><span class="section-number">9.8.2. </span>入力パラメータ<a class="headerlink" href="#id128" title="この見出しへのパーマリンク"></a></h3>
<p>本機能と関連あるタグの一覧を次の表に示します。</p>
<p>メタダイナミクスに関連のあるタグの一覧</p>
<table class="longtable docutils align-default" id="id200">
<caption><span class="caption-number">表 9.10 </span><span class="caption-text">拘束条件付きダイナミクスに関連のあるタグの一覧</span><a class="headerlink" href="#id200" title="このテーブルへのパーマリンク"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>第1
ブロック識別子</p></th>
<th class="head"><p>第2、第3ブロ
ック識別子</p></th>
<th class="head"><p>タグ識別子</p></th>
<th class="head"><p>説明</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>control</p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>driver</p></td>
<td><p>ダイナミクスの種類を選択する変数。</p>
<p>拘束条件付きダイナミクスの場合meta_dynamicsを指定する。</p>
</td>
</tr>
<tr class="row-even"><td><p>meta_dynamics</p></td>
<td></td>
<td></td>
<td><p>メタダイナミクスの設定を行うブロック</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>meta_dynamics_type</p></td>
<td><p>メタダイナミクスの“種類”の指定</p>
<p>bias_and_fictitious,bias_only,</p>
<p>bias_generationのいずれか</p>
<p>デフォルト値はbias_only.</p>
</td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>max_bias_update</p></td>
<td><p>最大バイアス更新回数を指定する。</p>
<p>デフォルト値は-1(負の数値の場合、この条件では停止しないことを意味する).</p>
</td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>extensive_output</p></td>
<td><p>onとすると通常は不要な出力も得られる</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>output_per_rank</p></td>
<td><p>onとするとレプリカ並列時に各ランクごとに出力が得られる</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>collective_variable</p></td>
<td></td>
<td><p>集団変数の指定を行うブロック。</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>type</p></td>
<td><p>集団変数の“種類”の指定。拘束条件付きダイナミクスと同じ。</p>
<p>bond_length,
bond_angle,
dihedral_angle</p>
<p>bond_length_diff,
bond_angle_diff,
distance_from_pos,</p>
<p>plane,
center_of_mass,
coordination_numbe</p>
</td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>atomx</p></td>
<td><p>拘束条件が関わる原子を指定する。xは整数で、たとえばtype =
bond_lengthの場合2原子が拘束に関わるのでatom1とatom2で指定する。</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>k</p></td>
<td><p>仮想粒子のバネ定数を指定する</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>delta_s</p></td>
<td><p>バイアスポテンシャルの幅、<span class="math notranslate nohighlight">\(\Delta
s\)</span>を指定する</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>smin</p></td>
<td><p>バイアスポテンシャル出力の最小値を指定</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>smax</p></td>
<td><p>バイアスポテンシャル出力の最大値を指定</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>ds</p></td>
<td><p>バイアスポテンシャル出力の刻み幅を指定</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>control_velocity</p></td>
<td><p>onにした場合、仮想粒子の速度を制御する</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>mass_thermo</p></td>
<td><p>仮想粒子の速度を制御する場合の熱浴の質量</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>target_KE</p></td>
<td><p>仮想粒子の速度を制御する場合のターゲット運動エネルギー</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>plane</p></td>
<td></td>
<td><p>面内拘束における面の法線ベクトルを指定するブロック</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>normx,normy,normz</p></td>
<td><p>法線ベクトルのx,y,z成分</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>distance_from_pos</p></td>
<td></td>
<td><p>場所の指定を行うブロック</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>posx,posy,posz</p></td>
<td><p>指定したい場所のx,y,z成分</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>coordination_number</p></td>
<td></td>
<td><p>配位数指定を行うブロック</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>kappa_inv</p></td>
<td><p>配位数定義式のの逆数を長さの単位で指定</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>kappa</p></td>
<td><p>配位数定義式の<span class="math notranslate nohighlight">\(\kappa\)</span>
を1/bohr単位で指定</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>rcut</p></td>
<td><p>配位数定義式の<span class="math notranslate nohighlight">\(r_c\)</span>
の値を長さの単位で指定</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>center_of_mass</p></td>
<td></td>
<td><p>重心を変化させる方向を指定するブロック</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>directionx</p></td>
<td><p>指定したい方向のx成分</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>directiony</p></td>
<td><p>指定したい方向のy成分</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>directionz</p></td>
<td><p>指定したい方向のz成分</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>bias_potential</p></td>
<td></td>
<td><p>バイアスポテンシャルの設定を行うブロック</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>height</p></td>
<td><p>一度に足すバイアスポテンシャルの高さを</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td></td>
<td><p>エネルギーの単位で指定</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>update_frequency</p></td>
<td><p>バイアスポテンシャルを足す頻度を指定</p>
<p>たとえば10とすると、10MDステップに1回バイアスポテンシャルが更新される。</p>
<p>デフォルト値は20。</p>
</td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>output_frequency</p></td>
<td><p>meta_dynamics_typeがbias_generationの場合に、バイアスポテンシャル構築を何回に1回行うかを指定する。</p>
<p>デフォルト値は10</p>
</td>
</tr>
<tr class="row-odd"><td></td>
<td><p>continuation_strategy</p></td>
<td></td>
<td><p>レプリカ並列計算時における継続計算の方針を設定する。</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>randomize_velocity</p></td>
<td><p>onとすると速度は継続せず乱数で決まるようになる</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>scale_velocity</p></td>
<td><p>onとすると継続時下記のvelocity_scaling_factorに応じて速度がスケールされる。</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>velocity_
scaling_factor</p></td>
<td><p>読み込んだ速度をスケールする値。デフォルト値は1</p></td>
</tr>
<tr class="row-odd"><td></td>
<td></td>
<td><p>configuration_from_input</p></td>
<td><p>onとすると、継続計算ファイルではなく入力ファイルから座標データを読み込む。デフォルト値はoff</p></td>
</tr>
</tbody>
</table>
<p>Meta-dynamics法の入力パラメータの指定について説明します。</p>
<p>Meta-dynamics法の計算は、以下の指定を行います。</p>
<ul class="simple">
<li><p>Meta-dynamics法を有効に指定する</p></li>
<li><p>Meta-dynamicsの振る舞いを指定する（ダイナミクス追跡モード、バイアスポテンシャル更新回数、出力形式など）</p></li>
<li><p>温度一定のMDシミュレーションの設定を行う</p></li>
<li><p>集団変数の定義を行う（集団変数に含める反応座標の情報を集団変数の数だけ定義）</p></li>
<li><p>バイアスポテンシャルの設定を行う（バイアスポテンシャルの高さ、幅、更新頻度など）</p></li>
<li><p>レプリカ並列計算を実行する場合、その設定。</p></li>
<li><p>Meta-dynamics法を有効に指定する</p></li>
</ul>
<p>Meta-dynamics法の機能を有効にするには、controlブロックにおいて以下の指定を行います</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>control{
    driver = meta_dynamics
}
</pre></div>
</div>
<p>この指定により、PHASEの通常の原子ダイナミクスコードではなく、Meta-dynamics計算用のメイン・プログラムが呼ばれます。</p>
<ul class="simple">
<li><p>Meta-dynamicsの振る舞いの設定</p></li>
</ul>
<p>Meta-dynamicsの全体的な振る舞いの設定方法を説明します。この設定は、入力ファイルの最上位にmeta_dynamicsブロックを作成し、さらに以下のような変数・ブロックを定義することによって行います。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>meta_dynamics{
  meta_dynamics_type = bias_only
  max_bias_update = -1
  extensive_output=on
  output_per_rank=on
  output_cvar_every_step=off
  continuation_strategy{
    randomize_velocity=on
    scale_velocity=off
    velocity_scaling_factor=0.7
    configuration_from_input=off
    ...
    ...
  }
</pre></div>
</div>
<p>meta_dynamicsブロックでは、以下の変数/ブロックの設定を行うことができます。</p>
<table class="longtable docutils align-default" id="id201">
<caption><span class="caption-number">表 9.11 </span><span class="caption-text">拘束条件付きダイナミクスに関連のあるタグの一覧</span><a class="headerlink" href="#id201" title="このテーブルへのパーマリンク"></a></caption>
<tbody>
<tr class="row-odd"><td><p>meta_dynamics_type変数</p></td>
<td></td>
<td><p>bias_and_fictitious,
bias_only,
bias_generationのいずれかを指定します。</p>
<p>bias_and_fictitiousとすると仮想粒子の動力学を考慮したメタダイナミクスを、bias_onlyとするとバイアスポテンシャルのみを有効にしたメタダイナミクスを実行することができます。bias_generationとした場合Metadynamicsは実行されず、作業ディレクトリーに存在するファイルからバイアスポテンシャルの構築および出力のみが実行されます。</p>
</td>
</tr>
<tr class="row-even"><td><p>max_bias_update変数</p></td>
<td></td>
<td><p>最大何回バイアスポテンシャルを更新するかを指定します。負の値を指定すると、バイアスポテンシャルの更新回数では計算は停止しません。これがデフォルトの振る舞いです。</p></td>
</tr>
<tr class="row-odd"><td><p>output_per_rank変数</p></td>
<td></td>
<td><p>onとすると、レプリカ並列計算実行時に出力が各ランクごとに得られます。</p></td>
</tr>
<tr class="row-even"><td><p>extensive_output変数</p></td>
<td></td>
<td><p>onとすると、仮想粒子の速度や仮想粒子に働く力など、通常は不要な出力も得られます</p></td>
</tr>
<tr class="row-odd"><td><p>continuation_strategyブロック</p></td>
<td></td>
<td><p>レプリカ並列計算実行時における継続計算の方針の設定を行います。レプリカ並列計算時には、並列数を変化させた場合に以前の計算を厳密に再現することはできないので、ここでどのような方針で継続するのか決定する必要があります。このブロックでは、以下の設定を行うことができます。</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>randomize_velocity</p></td>
<td><p>onとすると、継続計算実行時に速度を継続せず、乱数で割り振ります。デフォルト値はoff。</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>scale_velocity</p></td>
<td><p>onとすると、読みこんだ速度をつぎに説明するvelocity_scaling_factorの値に応じてスケールします。デフォルト値はoff。</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>velocity_scaling_factor</p></td>
<td><p>読み込んだ速度にここで指定した値をかけます。デフォルト値は1。</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>configuration_from_inpu</p></td>
<td><p>onとすると、継続計算ファイルではなく入力ファイルから座標データを読み込む。デフォルト値はoff。</p></td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><p>集団変数の定義</p></li>
</ul>
<p>集団変数とは、“反応座標”を複数まとめたものです。この指定は、meta_dynamicsブロック以下において行います。典型的な例は下記の通りです。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>meta_dynamics{
  ....
  ....
  collective_variable{
    mass=1000
    k=100
    delta_s = 0.08
    control_velocity=on
    mass_thermo = 50
    target_KE = 0.1
  }
  collective_variable1{
     type=bond_length
     atom1=5
     atom2=4
     delta_s=0.05 angstrom
     smin=1 angstrom
     smax=5 angstrom
     ds = 0.1 angstrom
   }
  ....
  ....
}
</pre></div>
</div>
<p>まず、meta_dynamicsブロックの下にcollective_variableブロックを作成します。collective_variableブロックには全集団変数に共通の設定を行います。後に説明する集団変数個別の設定に記述がない項目のみここでの設定が反映されます。</p>
<p>次に、集団変数を定義したい数だけcollective_variable<em>xx</em>ブロックにおいて定義します。ここで<em>xx</em>は集団変数のIDです。任意の数の集団変数を定義することが可能ですが、1から連続的に変化する整数を指定する必要があります。たとえば、collective_variable1,
collective_variable2,
collective_variable4の3つのcollective_variable<em>xx</em>ブロックがあった場合、collective_variable1とcollective_variable2のみ解釈されます。</p>
<p>collective_variableおよびcollective_variable<em>xx</em>ブロックは、拘束条件付きダイナミクスの設定の際に設定する拘束条件と同様の変数を定義することが可能となっています。具体的には、以下の変数を定義することが可能です。</p>
<table class="longtable docutils align-default" id="id202">
<caption><span class="caption-number">表 9.12 </span><span class="caption-text">拘束条件付きダイナミクスに関連のあるタグの一覧</span><a class="headerlink" href="#id202" title="このテーブルへのパーマリンク"></a></caption>
<tbody>
<tr class="row-odd"><td><p>type 変数</p></td>
<td></td>
<td><p>集団変数の“種類”を指定します。</p>
<p>以下のいずれかの値をとります。</p>
</td>
</tr>
<tr class="row-even"><td></td>
<td><p>bond_length</p></td>
<td><p>2原子間の距離を集団変数とします。</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>bond_angle</p></td>
<td><p>3原子の成すボンド角を集団変数とします。</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>dihedral_angle</p></td>
<td><p>4原子の2面角を集団変数とします。</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>bond_length_diff</p></td>
<td><p>2原子間の距離の差を集団変数とします。</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>plane</p></td>
<td><p>ある原子の指定の面内での位置集団変数とします。</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>center_of_mass</p></td>
<td><p>指定の原子群の重心を位置集団変数とします。</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>coordination_number</p></td>
<td><p>配位数を位置集団変数とします。</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>distance_from_pos</p></td>
<td><p>ある場所からの距離を集団変数とします。</p></td>
</tr>
<tr class="row-even"><td><p>atomx 変数</p></td>
<td></td>
<td><p>指定の集団変数が関わる原子を指定します。xは数字であり、たとえば2原子間の距離の場合は2つの原子が拘束に関わるので、atom1とatom2に対応する原子の番号を指定します。typeがcoordination_numberの場合、配位数を計算する中心の原子の番号を指定します。</p></td>
</tr>
<tr class="row-odd"><td><p>planeブロック</p></td>
<td></td>
<td><p>面内拘束の場合の、拘束したい面の法線ベクトルを指定するためのブロックです。次の変数を指定することができます。</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>normx</p></td>
<td><p>法線ベクトルのx座標。</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>normy</p></td>
<td><p>法線ベクトルのy座標。</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>normz</p></td>
<td><p>法線ベクトルのz座標。</p></td>
</tr>
<tr class="row-odd"><td><p>coordin
ation_numberブロック</p></td>
<td></td>
<td><p>配位数の設定</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>kappa_inv</p></td>
<td><p><span class="math notranslate nohighlight">\(1/\kappa\)</span> の値を、長さの単位で指定します。</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>kappa</p></td>
<td><p><span class="math notranslate nohighlight">\(\kappa\)</span>の値を、1/bohr単位で指定します。kappa_invよりも優先されます。</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>rcut</p></td>
<td><p><span class="math notranslate nohighlight">\(r_c\)</span>の値を長さの単位で指定します。</p></td>
</tr>
<tr class="row-odd"><td><p>mass変数</p></td>
<td></td>
<td><p>仮想粒子の質量を指定します。meta_dynamics_typeがbias_and_fictitiousの場合のみ意味のある指定です。</p></td>
</tr>
<tr class="row-even"><td><p>k変数</p></td>
<td></td>
<td><p>仮想粒子と集団変数の結びつきを決める、バネ定数を指定します。meta_dynamics_typeがbias_and_fictitiousの場合のみ意味のある指定です。</p></td>
</tr>
<tr class="row-odd"><td><p>delta_s変数</p></td>
<td></td>
<td><p><span class="math notranslate nohighlight">\(\delta
s_{\alpha}\)</span> の値を指定します。</p></td>
</tr>
<tr class="row-even"><td><p>smin変数</p></td>
<td></td>
<td><p>バイアスポテンシャル出力の際の最小値を指定します。</p></td>
</tr>
<tr class="row-odd"><td><p>smax変数</p></td>
<td></td>
<td><p>バイアスポテンシャル出力の際の最大値を指定します。</p></td>
</tr>
<tr class="row-even"><td><p>ds変数</p></td>
<td></td>
<td><p>バイアスポテンシャル出力の際の刻み幅を指定します。</p></td>
</tr>
<tr class="row-odd"><td><p>control_velocity変数</p></td>
<td></td>
<td><p>onにした場合、仮想粒子のダイナミクスを追跡する際に熱浴を付与することによってその速度を制御します。meta_dynamics_typeがbias_and_fictitiousの場合のみ意味のある指定です。</p></td>
</tr>
<tr class="row-even"><td><p>mass_thermo変数</p></td>
<td></td>
<td><p>control_velocityがonの場合の、熱浴の質量を指定します。</p></td>
</tr>
<tr class="row-odd"><td><p>target_KE変数</p></td>
<td></td>
<td><p>control_velocityがonの場合の、目的とする仮想粒子の温度を指定する。</p></td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><p>バイアスポテンシャルの設定</p></li>
</ul>
<p>バイアスポテンシャルの設定は、meta_dynamicsブロックの下にbias_potentialブロックを作成して行います。以下に典型的な例を示します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>bias_potential{
  height = 0.02 eV
  update_frequency=20
  output_frequency=100
}
</pre></div>
</div>
<p>bias_potentialブロックにおいて定義可能な変数は下記の通りです。</p>
<table class="longtable docutils align-default" id="id203">
<caption><span class="caption-number">表 9.13 </span><span class="caption-text">拘束条件付きダイナミクスに関連のあるタグの一覧</span><a class="headerlink" href="#id203" title="このテーブルへのパーマリンク"></a></caption>
<tbody>
<tr class="row-odd"><td><p>height変数</p></td>
<td><p>一度に足すバイアスポテンシャルの高さをエネルギーの単位で指定します。</p>
<p>一度に足すバイアスポテンシャルの幅は、各集団変数固有の量であるのでbias_potentialブロックではなく集団変数固有の設定を行うcollective_variable<em>xx</em>ブロック以下で行います。</p>
</td>
</tr>
<tr class="row-even"><td><p>output_frequency変数</p></td>
<td><p>meta_dynamics_typeがbias_generationの場合のみ意味のある指定です。何回に1回バイアスポテンシャルを出力するかを指定します。</p></td>
</tr>
<tr class="row-odd"><td><p>update_frequency</p></td>
<td><p>バイアスポテンシャルの更新頻度を指定します。デフォルト値は20です。</p></td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><p>レプリカ並列計算の設定</p></li>
</ul>
<p>初期速度を変化させる</p>
<p>特に指定がない場合、初期座標はすべてのレプリカで共通で、初期速度の乱数のみ異なる、という条件で計算がなされます。位相空間上異なる点から始めるので、座標が同じでも各レプリカはいずれ異なる軌跡をとるようになります。ただし、当然のことながら最初のうちは（座標値は）ほぼ同じ軌跡となります。</p>
<p>初期の座標値をランクごとに明示的に指定する</p>
<p>入力ファイルにおいて、レプリカごとに異なる座標データを指定することも可能です。この設定は、atomsxxブロック（ここでxxはMPIランクの数字）を作成し、そこで座標値を設定することによって行います。たとえば、ランク0が担当するレプリカとランク1が担当するレプリカにそれぞれ異なる座標値を与えるには、次のような記述を行います。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>structure{
    atom_list{
        ....
        atoms0{
            #units angstrom
            #default weight = 1, element = Si, mobile = 1
            #tag element rx ry rz mobile weight
            C 5.0157363043        5.6563796505        5.8043454319 1 1
            C 4.7499007526        4.2727134018        5.7364572058 1 1
            ...
            ...
        }
        atoms1{
            #units angstrom
            #default weight = 1, element = Si, mobile = 1
            #tag element rx ry rz mobile weight
            C       4.5897384578    5.5998560107    5.7723226564 1 1
            C       5.1658344359    4.3217914066    5.6857269157 1 1
            ...
            ...
        }
    }
}
</pre></div>
</div>
</section>
<section id="id129">
<h3><span class="section-number">9.8.3. </span>計算の実行方法<a class="headerlink" href="#id129" title="この見出しへのパーマリンク"></a></h3>
<p>Meta-dynamics法を実行するには、通常のPHASEによる計算と同様に以下のコマンドを発行します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>mpirun -n NP phase ne=NE nk=NK nr=NR
</pre></div>
</div>
<p>ここでNPはMPIプロセス数、NEはバンド並列数、NKはk点並列数、NRはレプリカ並列数です。NP=NE×NK×NRという関係が成立している必要があります。ne,
nk, nrはいずれも省略可能（デフォルト値は1
すべて無指定の場合NE=NP）です。</p>
<p>通常Meta
dynamics実行時に得られるバイアスポテンシャルの出力は「直近に得られたバイアスポテンシャル」のみですが、バイアスポテンシャルをポスト処理的に計算し、それを出力させることもできます。この機能を利用するには、入力ファイルのmeta_dynamicsブロックのmeta_dynamics_type変数にbias_generationという文字列を指定します。この時、meta_dynamicsブロックの下のbias_potentialブロックにおいて定義される、bias_output_frequency変数に指定された回数に1回出力を行います。たとえば、bias_output_frequencyが10,
バイアスの総更新回数が100だった場合、10回目、20回目、30回目、...
100回目の更新時のバイアスポテンシャルがそれぞれ独立したファイルに出力されます。そのファイル名は、“bias_potential.dataxx”となります。ここでxxが対応する更新回数です。この設定を行ったあと、Meta-dynamics解析を行ったディレクトリーにおいてPHASEを実行します。ファイルを読み込みバイアスポテンシャルを構築するのみなので、通常並列で実行する必要はありません。</p>
</section>
<section id="id130">
<h3><span class="section-number">9.8.4. </span>計算結果の出力<a class="headerlink" href="#id130" title="この見出しへのパーマリンク"></a></h3>
<p>Meta dynamicsシミュレーションを行う場合、標準よりも多くのファイルが出力されます。以下に、各々について簡単に説明します。</p>
<ul class="simple">
<li><p>curr_bias_potential.dataファイル</p></li>
</ul>
<p>“現在の”バイアスポテンシャルが記録されたファイルです。次のような形式で出力されます。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>1.2000000000       -3.1400000000        0.0000000000
1.3000000000       -3.1400000000        0.0000000000
1.4000000000       -3.1400000000        0.0000000000
1.5000000000       -3.1400000000        0.0000000000
1.6000000000       -3.1400000000        0.0000000000
1.7000000000       -3.1400000000        0.0000000000
                     ....
                     ....

1.2000000000       -3.0400000000        0.0000000000
1.3000000000       -3.0400000000        0.0000000000
1.4000000000       -3.0400000000        0.0000000000
1.5000000000       -3.0400000000        0.0000000000
1.6000000000       -3.0400000000        0.0000000000
1.7000000000       -3.0400000000        0.0000000000
                     ....
                     ....
</pre></div>
</div>
<p>各行が“集団変数の組”に相当します。定義している数だけ集団変数が記録されたあと、その“集団変数の組”におけるバイアスポテンシャルの値が出力されます。</p>
<ul class="simple">
<li><p>bias_potential.dataxxファイル</p></li>
</ul>
<p>バイアスポテンシャルを作成するのみのモードを利用した場合に得られる、更新回数に応じたバイアスポテンシャルのデータが出力されるファイルです。ファイル名のxxがバイアスポテンシャル更新回数に相当します。そのファイル形式は、curr_bias_potential.dataと同様です。</p>
<ul class="simple">
<li><p>nfdynm.data_at_biasファイル</p></li>
</ul>
<p>バイアスポテンシャル更新時における座標データが出力されるファイルです。PHASEの標準座標データ出力形式である、F_DYNM形式で出力されます。</p>
<ul class="simple">
<li><p>nfefn.data_at_biasファイル</p></li>
</ul>
<p>バイアスポテンシャル更新時におけるエネルギーの値が出力されるファイルです。PHASEの標準的なエネルギーデータ出力形である、F_ENF形式で出力されます。</p>
<ul class="simple">
<li><p>collective_variables.dataファイル</p></li>
</ul>
<p>バイアスポテンシャル更新時における集団変数の値が出力されるファイルです。次のような形式で出力されます。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span> 2        1.6399047278        0.0906233310
 3        1.6933783940        0.2327954221
 4        1.6487636847        0.0655806009
 5        1.7510381463       -0.1403803460
 6        1.7880912692       -0.2122517967
 7        1.7558411086       -0.2557274737
 8        1.7939362867       -0.0296094373
 9        1.7595919709        0.1959354384
10        1.7773637731        0.3761827029
11        1.7657919080        0.3998392061
12        1.7604309483       -0.0107912799
13        1.6218441177       -0.3366407543
                   ....
                   ....
</pre></div>
</div>
<p>各行がバイアスポテンシャル更新のタイミングに対応します。一列目がバイアスポテンシャルの更新回数であり、二列目以降定義順に対応する集団変数の値が出力されます。</p>
<ul class="simple">
<li><p>bias_potential_parameters.dataファイル</p></li>
</ul>
<p>バイアスポテンシャルのパラメーターが出力されるファイルです。継続計算のタイミングでこのパラメーターを変化させた場合、それ以前のパラメーターの値が分からないとバイアスポテンシャルの構築ができないことから必要なファイルです。次のような形式で出力されます。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>2        0.0200000000        0.1000000000        0.1000000000
3        0.0200000000        0.1000000000        0.1000000000
4        0.0200000000        0.1000000000        0.1000000000
5        0.0200000000        0.1000000000        0.1000000000
                  ....
                  ....
</pre></div>
</div>
<p>各行がバイアスポテンシャル更新のタイミングに対応します。一列目がバイアスポテンシャル更新回数であり、二列目が(23)式における<span class="math notranslate nohighlight">\(w\)</span>の値、3列以降が各集団変数の(23)式における<span class="math notranslate nohighlight">\(\delta s_{\alpha}\)</span>の値です。</p>
</section>
<section id="id131">
<h3><span class="section-number">9.8.5. </span>計算例：炭化水素のエネルギー表面<a class="headerlink" href="#id131" title="この見出しへのパーマリンク"></a></h3>
<section id="id132">
<h4><span class="section-number">9.8.5.1. </span>概要<a class="headerlink" href="#id132" title="この見出しへのパーマリンク"></a></h4>
<p>Meta dynamics法を利用した例として、炭化水素のエネルギー表面を調べた例を紹介します。具体的には、C<sub>4</sub>H<sub>6</sub>分子の電子環状反応を取り上げます。
入力データは <code class="code docutils literal notranslate"><span class="pre">samples/dynamics/meta_dynamics/C4H6</span></code> にあります。
C<sub>4</sub>H<sub>6</sub>分子は、trans 1-3ブタジエン、cis 1-3 ブタジエン、シクロブテンの3種類の安定構造が知られています。シクロブテンは環状分子、trans 1-3ブタンジエンは平面状の分子ですが、cis 1-3ブタジエンは平面状にはならず、2面角を30°ほどひねった構造が安定な構造です(gauche配座)。その分子構造を <a class="reference internal" href="#advanced-mtd-c4h6-1"><span class="std std-numref">図 9.40</span></a> に示します。エネルギーは、高い順にシクロブテン、cis
1-3ブタジエン、trans 1-3ブタジエンであり、分子の反応としては、1-3 ブタジエンが閉環して環状化合物であるシクロブテンを生成する、あるいは逆にシクロブテンが開環し1-3ブタジエンが生成される反応（電子環状反応）、また、2種類の1-3 ブタジエンの間のcis-trans反応が考えられます。閉環・開環反応は化学結合の切断を要することから大きな障壁エネルギーがあり、1 eV程度のオーダーであると考えられます。他方、cisからtransへの変化はそこまでの障壁はなく、100 meV程度のオーダーであると考えられます。
特に、環状反応においては、1-3ブタジエンとシクロブテンとでは2重結合の数が異なり、電子状態としては全く異なるものであるため、古典的なポテンシャルで取り扱うのは一般に難しいと言えます。この点をPHASEで正しく扱えるかどうかを確認します。</p>
<figure class="align-default" id="advanced-mtd-c4h6-1">
<a class="reference internal image-reference" href="../_images/image202.png"><img alt="../_images/image202.png" src="../_images/image202.png" style="width: 400pt;" /></a>
<figcaption>
<p><span class="caption-number">図 9.40 </span><span class="caption-text">C<sub>4</sub>H<sub>6</sub>分子の分子構造</span><a class="headerlink" href="#advanced-mtd-c4h6-1" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
<p>初期の原子配置は、 <a class="reference internal" href="#advanced-mtd-c4h6-2"><span class="std std-numref">図 9.41</span></a> で示すシクロブテンを採用します。この初期構造は、PHASEによって最適化したものです。</p>
<figure class="align-default" id="advanced-mtd-c4h6-2">
<a class="reference internal image-reference" href="../_images/image203.png"><img alt="../_images/image203.png" src="../_images/image203.png" style="width: 200pt;" /></a>
<figcaption>
<p><span class="caption-number">図 9.41 </span><span class="caption-text">C<sub>4</sub>H<sub>6</sub>分子の分子構造</span><a class="headerlink" href="#advanced-mtd-c4h6-2" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
</section>
<section id="id133">
<h4><span class="section-number">9.8.5.2. </span>入力パラメータ<a class="headerlink" href="#id133" title="この見出しへのパーマリンク"></a></h4>
<p>Meta dynamics法を有効に指定します。これは、controlブロックの下のdriver変数にmeta_dynamicsを指定することによって行います。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>condition{
    driver = meta_dynamics
    ....
}
</pre></div>
</div>
<p>次に集団変数を定義します。その方針は様々ですが、ここでは以下を採用します。</p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#advanced-mtd-c4h6-2"><span class="std std-numref">図 9.41</span></a> の原子1と原子2の距離。パラメーターds, delta_sはそれぞれ0.1 Åと0.05 Å</p></li>
<li><p><a class="reference internal" href="#advanced-mtd-c4h6-2"><span class="std std-numref">図 9.41</span></a> の、原子1-4-3-2の作る二面角。パラメーターds, delta_sはそれぞれ10°と5°</p></li>
</ol>
<p>この設定は、meta_dynamicsブロックの下で以下のように実現します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>meta_dynamics{
....
....
  collective_variable1{
     type=bond_length
     atom1=5
     atom2=4
     delta_s=0.05 angstrom
!for bpot output
     smin=1 angstrom
     smax=5 angstrom
     ds = 0.1 angstrom
   }
   collective_variable2{
     type=dihedral_angle
     atom1=5
     atom2=3
     atom3=2
     atom4=4
     delta_s = 5 degree
!for bpot output
     smin = -180 degree
     smax = +180 degree
     ds = 10 degree
   }
}
</pre></div>
</div>
<p>バイアスポテンシャルの高さは0.02 eV(0.46
kcal/mol)とします。バイアスポテンシャルの更新頻度は、20
MDステップに一度とします。この設定は、meta_dynamicsブロックの下にbias_potentialブロックを作成し、heightパラメーターで指定することによって行います。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>meta_dynamics{
    ....
    ....
    bias_potential{
        update_frequency = 20
        height=0.02 eV
    }
}
</pre></div>
</div>
<p>バイアスポテンシャルを更新する回数は任意ですが、信頼できる自由エネルギー表面を得るためには相当数の更新回数が必要です。</p>
</section>
<section id="id134">
<h4><span class="section-number">9.8.5.3. </span>計算結果<a class="headerlink" href="#id134" title="この見出しへのパーマリンク"></a></h4>
<p>本シミュレーションによって得られる計算結果を解説します。まず、 <a class="reference internal" href="#advanced-mtd-result1"><span class="std std-numref">図 9.42</span></a> にバイアスポテンシャルを18,140回程度更新した結果得られたエネルギー表面の等高線図を示します。</p>
<figure class="align-default" id="advanced-mtd-result1">
<a class="reference internal image-reference" href="../_images/image204.svg"><img alt="../_images/image204.svg" src="../_images/image204.svg" width="435pt" /></a>
<figcaption>
<p><span class="caption-number">図 9.42 </span><span class="caption-text">C<sub>4</sub>H<sub>6</sub>分子の自由エネルギー表面</span><a class="headerlink" href="#advanced-mtd-result1" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
<p><a class="reference internal" href="#advanced-mtd-result1"><span class="std std-numref">図 9.42</span></a> より、ここで得られたエネルギーの等高線図には4つの安定点があることが理解できます。すなわち、原子間距離が約1.5 Å程度で角度がほぼ0 radianの点、原子間距離が3.3 Å程度で角度が0 radian、原子間距離が3.7 Å程度で角度が<span class="math notranslate nohighlight">\(\pm\)</span>3 radian程度の2つの点です。これらは、それぞれシクロブテン、cis 1-3ブタジエン、trans 1-3ブタジエンに相当します。絶対零度の計算の場合、cisではなくgauche 配座となりますが、300KのMeta dynamicsシミュレーションではcisとgaucheの明確な区別がつけられる結果は得られませんでした。得られたシクロブテンとtrans 1-3ブタジエンのエネルギー差は、16 kcal/mol程度、シクロブテンとcisブタジエンのエネルギー差は12kcal/mol程度となりました。いずれも、絶対零度の計算と比較するとより大きなエネルギー差です。</p>
<p><a class="reference internal" href="#advanced-mtd-result2"><span class="std std-numref">図 9.43</span></a> および <a class="reference internal" href="#advanced-mtd-result3"><span class="std std-numref">図 9.44</span></a> には、集団変数がバイアスポテンシャルの更新と共にどのように変化していったかを示しています。二面角が <a class="reference internal" href="#advanced-mtd-result2"><span class="std std-numref">図 9.43</span></a> 、炭素原子間距離が <a class="reference internal" href="#advanced-mtd-result3"><span class="std std-numref">図 9.44</span></a> の振る舞いです。 <a class="reference internal" href="#advanced-mtd-result2"><span class="std std-numref">図 9.43</span></a> および <a class="reference internal" href="#advanced-mtd-result3"><span class="std std-numref">図 9.44</span></a> より、バイアスポテンシャルを約700回更新した時点で鞍点を超えてブタジエンに至っていることが理解できます。そこから18,000回程度の更新までは幅広くエネルギー表面を探索しています。<a class="reference internal" href="#advanced-mtd-c4h6-1"><span class="std std-numref">図 9.40</span></a> らも分かるように、ここで考えている系はシクロブタンを除くと二面角に対して幅広い範囲の構造を取り得ます。そのため、この谷を埋め尽くすのに多くのバイアスポテンシャルの更新が必要となっています。18,000回程度のバイアスポテンシャル更新の結果、再びシクロブタンへ戻ったことが確認できた時点(<a class="reference internal" href="#advanced-mtd-c4h6-1"><span class="std std-numref">図 9.40</span></a> )で計算を終了させました。</p>
<figure class="align-default" id="advanced-mtd-result2">
<a class="reference internal image-reference" href="../_images/image205.svg"><img alt="../_images/image205.svg" src="../_images/image205.svg" width="350pt" /></a>
<figcaption>
<p><span class="caption-number">図 9.43 </span><span class="caption-text">2面角とバイアスポテンシャル更新回数の関係</span><a class="headerlink" href="#advanced-mtd-result2" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
<figure class="align-default" id="advanced-mtd-result3">
<a class="reference internal image-reference" href="../_images/image206.svg"><img alt="../_images/image206.svg" src="../_images/image206.svg" width="350pt" /></a>
<figcaption>
<p><span class="caption-number">図 9.44 </span><span class="caption-text">炭素原子間距離とバイアスポテンシャル更新回数の関係</span><a class="headerlink" href="#advanced-mtd-result3" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
<p><a class="reference internal" href="#advanced-mtd-result4"><span class="std std-numref">図 9.45</span></a> (a)から(d)までに、Meta dynamicsシミュレーション中に実際に得られた原子配置のスナップショットを示しました。ここで示しているように、バイアスポテンシャルの効果によって様々な分子構造が実現していることが分かります。</p>
<figure class="align-default" id="advanced-mtd-result4">
<a class="reference internal image-reference" href="../_images/image207.png"><img alt="../_images/image207.png" src="../_images/image207.png" style="width: 400pt;" /></a>
<figcaption>
<p><span class="caption-number">図 9.45 </span><span class="caption-text">Meta dynamicsシミュレーションによって得られた分子構造のスナップショット。(a) : バイアスポテンシャル2回更新 (b) バイアスポテンシャル690回更新 (c) バイアスポテンシャル1,500回更新 (d) バイアスポテンシャル18,070回更新</span><a class="headerlink" href="#advanced-mtd-result4" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
</section>
</section>
<section id="id135">
<h3><span class="section-number">9.8.6. </span>使用における注意点<a class="headerlink" href="#id135" title="この見出しへのパーマリンク"></a></h3>
<p>Meta dynamics法は、すべての擬ポテンシャルと組み合わせて利用することができます。レプリカ並列を含めた並列計算も行うことができます。
ただし、意味のある結果を得るためには膨大な計算量を費やす必要があります。
レプリカ並列を行う場合、継続計算のタイミングでレプリカ並列数を変化させる場合、対応するレプリカの継続計算ファイルが存在しない場合があります。この場合は近くのランクの継続計算データを読み込み、さらにcontinuation_strategyで設定した指針に従って初期レプリカを作成します。</p>
<p><strong>参考文献</strong></p>
<div role="list" class="citation-list">
<div class="citation" id="laio02" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id125">Laio02</a><span class="fn-bracket">]</span></span>
<p>A. Laio and M. Parrinello, Proceedings of the National Academy of Sciences <strong>99</strong>, (2002) p. 12562.</p>
</div>
<div class="citation" id="iannuzzi03" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id126">Iannuzzi03</a><span class="fn-bracket">]</span></span>
<p>M. Iannuzzi, A. Laio and M. Parrinello, Physical Review Letters <strong>90</strong>, (2003) p. 238302.</p>
</div>
<div class="citation" id="laio05" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id127">Laio05</a><span class="fn-bracket">]</span></span>
<p>A. Laio, A. Rodriguez-Fortea, F. L. Gervasio, Ceccarelli and M.  Parrinello, J. Phys. Chem. B <strong>109</strong>, (2005) p. 6714.</p>
</div>
</div>
</section>
</section>
<section id="section-constant-chemical-potential">
<span id="id136"></span><h2><span class="section-number">9.9. </span>化学ポテンシャル一定のシミュレーション<a class="headerlink" href="#section-constant-chemical-potential" title="この見出しへのパーマリンク"></a></h2>
<section id="id137">
<h3><span class="section-number">9.9.1. </span>概要<a class="headerlink" href="#id137" title="この見出しへのパーマリンク"></a></h3>
<p>PHASE/0による通常のシミュレーションでは、電子数一定の計算を行います。これに対し、化学ポテンシャル（フェルミエネルギー）を一定とし、構造最適化や分子動力学シミュレーション、NEB計算などを行う <a class="reference internal" href="#bonnet12" id="id138"><span>[Bonnet12]</span></a> ことができる機能（constant-mu法）もPHASE/0には備わっています。この場合、電子数はシミュレーション中変化します。</p>
</section>
<section id="id139">
<h3><span class="section-number">9.9.2. </span>入力パラメーター<a class="headerlink" href="#id139" title="この見出しへのパーマリンク"></a></h3>
<p>化学ポテンシャル一定のシミュレーションを行うには、accuracyブロックの下にfcpブロックを作成し、次の例のように設定を行います。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>accuracy{
  ...
  fcp{
    sw_fcp = ON
    mu = -0.1
    relax_crit = 1.0d-5
  }
  ...
}
</pre></div>
</div>
<p>fcpブロックにおいて定義可能なパラメータは下記の通りです。</p>
<table class="longtable docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>sw_fcp</p></th>
<th class="head"><p>化学ポテンシャル一定の計算を行うかどうかを指定するスイッチです。</p>
<p>行う場合にonとします。</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>mu</p></td>
<td><p>ターゲットとなる化学ポテンシャルの値をエネルギーの単位で指定します。事前に通常の計算で状態密度を計算しておき、フェルミエネルギー近辺のエネルギー固有値の分布や電子数などを調べておくと設定しやすいでしょう。</p></td>
</tr>
<tr class="row-odd"><td><p>temperature</p></td>
<td><p>化学ポテンシャルを制御するための&quot;粒子浴&quot;の温度を指定します。分子動力学シミュレーションの場合に意味のある設定です。</p></td>
</tr>
<tr class="row-even"><td><p>qmass</p></td>
<td><p>化学ポテンシャルを制御するための&quot;粒子浴&quot;の質量を指定します。分子動力学シミュレーションの場合に意味のある設定です。</p></td>
</tr>
<tr class="row-odd"><td><p>mass</p></td>
<td><p>化学ポテンシャルを制御するための&quot;電子の質量&quot;を指定します。分子動力学シミュレーションの場合に意味のある設定です。</p></td>
</tr>
<tr class="row-even"><td><p>relax_crit</p></td>
<td><p>構造最適化の際の収束判定条件を指定します。得られる化学ポテンシャルの値とターゲットの値の差の絶対値がここで指定する値よりも小さくなった場合に収束したと見なされます（これ以外に、通常の原子間力に関する収束判定条件も考慮されます）。</p></td>
</tr>
<tr class="row-odd"><td><p>tot_charge_first</p></td>
<td><p>NEB計算の際に、始点のレプリカに与える電荷を指定します。</p></td>
</tr>
<tr class="row-even"><td><p>tot_charge_last</p></td>
<td><p>NEB計算の際に、終点のレプリカに与える電荷を指定します。</p></td>
</tr>
</tbody>
</table>
<p>なお、本計算機能を使って（ジョブ１とする）得られた（中性でない）電荷を外部電荷としてあたえて通常の計算を行う（ジョブ２とする）場合、（ジョブ１において）与えたmuの値とは異なるフェルミエネルギーが（ジョブ２において）得られます。逆に、外部電荷を与えて通常の計算を行って（ジョブ３とする）得られたフェルミエネルギーをmuに指定して（ジョブ４によって）最適化を行うと、得られる電荷はもとの（ジョブ３における）外部電荷とは異なる電荷となります。このようにつじつまの合わない結果が得られるのは、中性でない電荷を与える場合は初期電荷の与え方が中性の場合と異なるので、エネルギーの原点が変化するためです。つじつまの合った結果を得るためには、外部電荷を与えた計算について以下のような設定を加え、初期電荷の計算方法を合わせるようにしてください。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>accuracy{
  ...
  sw_add_qex_to_initial_charge = off
  ...
}
</pre></div>
</div>
</section>
<section id="id140">
<h3><span class="section-number">9.9.3. </span>計算の実行<a class="headerlink" href="#id140" title="この見出しへのパーマリンク"></a></h3>
<p>通常の構造最適化もしくは分子動力学シミュレーションの設定に加え、化学ポテンシャル一定のシミュレーションの設定を施したら、通常通りPHASE/0を実行すれば計算を行うことができます。</p>
<p>計算中に電荷がどのように変化したかは、以下の要領で調べることができます。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>%<span class="w"> </span>grep<span class="w"> </span><span class="s1">&#39;Total Charge&#39;</span><span class="w"> </span>output000
FCP<span class="w"> </span>:<span class="w"> </span>Total<span class="w"> </span><span class="nv">Charge</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">31</span>.98942095
FCP<span class="w"> </span>:<span class="w"> </span>Total<span class="w"> </span><span class="nv">Charge</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">31</span>.99795170
FCP<span class="w"> </span>:<span class="w"> </span>Total<span class="w"> </span><span class="nv">Charge</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">32</span>.01254363
FCP<span class="w"> </span>:<span class="w"> </span>Total<span class="w"> </span><span class="nv">Charge</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">32</span>.02605805
FCP<span class="w"> </span>:<span class="w"> </span>Total<span class="w"> </span><span class="nv">Charge</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">32</span>.03237025
FCP<span class="w"> </span>:<span class="w"> </span>Total<span class="w"> </span><span class="nv">Charge</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">32</span>.02886985
FCP<span class="w"> </span>:<span class="w"> </span>Total<span class="w"> </span><span class="nv">Charge</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">32</span>.01742419
FCP<span class="w"> </span>:<span class="w"> </span>Total<span class="w"> </span><span class="nv">Charge</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">32</span>.00372842
FCP<span class="w"> </span>:<span class="w"> </span>Total<span class="w"> </span><span class="nv">Charge</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">31</span>.99503316
...
...
</pre></div>
</div>
<p>また、化学ポテンシャル（フェルミエネルギー）がどのように変化したかは、以下の要領で調べることができます。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>%<span class="w"> </span>grep<span class="w"> </span><span class="s1">&#39;Fermi Energy&#39;</span><span class="w"> </span>output002
FCP<span class="w"> </span>:<span class="w"> </span>Fermi<span class="w"> </span><span class="nv">Energy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span>.24621583
FCP<span class="w"> </span>:<span class="w"> </span>Fermi<span class="w"> </span><span class="nv">Energy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span>.24679898
FCP<span class="w"> </span>:<span class="w"> </span>Fermi<span class="w"> </span><span class="nv">Energy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span>.24700415
FCP<span class="w"> </span>:<span class="w"> </span>Fermi<span class="w"> </span><span class="nv">Energy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span>.24674191
FCP<span class="w"> </span>:<span class="w"> </span>Fermi<span class="w"> </span><span class="nv">Energy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span>.24618985
...
...
</pre></div>
</div>
</section>
<section id="id141">
<h3><span class="section-number">9.9.4. </span>例題<a class="headerlink" href="#id141" title="この見出しへのパーマリンク"></a></h3>
<p>非常に単純な例題として、シリコン8原子の系の分子動力学シミュレーションを取り上げます。この例題の入力ファイルは、 <code class="code docutils literal notranslate"><span class="pre">samples/dynamics/FCP/NVT_nose_hoover</span></code> にあります。</p>
<p>この例題の入力ファイルは、基本的には <code class="code docutils literal notranslate"><span class="pre">samples/dynamics/molecular_dynamics/NVT</span></code> 以下にあるものと同等ですが、以下のように“化学ポテンシャル一定の分子動力学シミュレーション”を行うための設定が施されています。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">accuracy</span><span class="p">{</span>
  <span class="o">...</span>
  <span class="n">fcp</span><span class="p">{</span>
    <span class="n">sw_fcpopt</span> <span class="o">=</span> <span class="n">ON</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="mf">9.0e-3</span>
    <span class="n">mass</span> <span class="o">=</span> <span class="mf">1000.0</span><span class="n">d0</span>
    <span class="n">qmass</span> <span class="o">=</span> <span class="mi">4000</span>
  <span class="p">}</span>
  <span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この入力ファイルを利用して、通常通りPHASE/0を実行すれば化学ポテンシャル一定の第一原理分子動力学シミュレーションを行うことが可能です。その結果、たとえば <a class="reference internal" href="#advanced-constant-mu-fig1"><span class="std std-numref">図 9.46</span></a> に示すように電荷がシミュレーション中時々刻々と変化します。</p>
<figure class="align-default" id="advanced-constant-mu-fig1">
<img alt="../_images/image263.svg" src="../_images/image263.svg" /><figcaption>
<p><span class="caption-number">図 9.46 </span><span class="caption-text">分子動力学シミュレーション中の電荷の変化。</span><a class="headerlink" href="#advanced-constant-mu-fig1" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
</section>
<section id="id142">
<h3><span class="section-number">9.9.5. </span>使用上の注意<a class="headerlink" href="#id142" title="この見出しへのパーマリンク"></a></h3>
<p>本計算機能は、すべての機能と組み合わせて利用することが可能ですが、本計算機能を利用すると電荷中性ではない計算を行うことになる点には注意が必要です。有効遮蔽体法（ESM法。<a class="reference internal" href="../advanced_electronic_structure/advanced_electronic_structure.html#advanced-section-esm"><span class="std std-numref">7.7 章</span></a> 参照）で境界条件をpe1（両側のESMが金属）とすると、隣り合う単位胞の相互作用の影響を取り除くこともできます。</p>
<p><strong>参考文献</strong></p>
<div role="list" class="citation-list">
<div class="citation" id="bonnet12" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id138">Bonnet12</a><span class="fn-bracket">]</span></span>
<p>N. Bonnet, T. Morishita, O. Sugino, and M. Otani, “First-Principles Molecular Dynamics at a Constant Electrode Potential”, Physical Review Letters <strong>109</strong> 266101 (2012).</p>
</div>
</div>
</section>
</section>
<section id="section-rigid-body-dynamics">
<span id="id143"></span><h2><span class="section-number">9.10. </span>剛体ダイナミクス (バージョン2022.01以降)<a class="headerlink" href="#section-rigid-body-dynamics" title="この見出しへのパーマリンク"></a></h2>
<section id="id144">
<h3><span class="section-number">9.10.1. </span>概要<a class="headerlink" href="#id144" title="この見出しへのパーマリンク"></a></h3>
<p>指定の原子群を「剛体」とみなし、構造緩和、MDなどを行う際剛体内部について内部の緩和は行わず、外部からの力に応じて原子団全体で応答するようにすることができます。</p>
</section>
<section id="id145">
<h3><span class="section-number">9.10.2. </span>使い方<a class="headerlink" href="#id145" title="この見出しへのパーマリンク"></a></h3>
<section id="id146">
<h4><span class="section-number">9.10.2.1. </span>入力<a class="headerlink" href="#id146" title="この見出しへのパーマリンク"></a></h4>
<p>剛体計算機能を利用するためには、まずは <code class="docutils literal notranslate"><span class="pre">atoms</span></code> テーブルにおいて属性値 <code class="docutils literal notranslate"><span class="pre">rigid_body</span></code> を用いて原子を剛体に割り当てます。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>atom_list{
    atoms{
      #tag    element    rx    ry    rz    mobile rigid_body
            C  0.000681250  0.502399973  0.33460425   on 1
            C  0.504018645  0.000282432 -0.31959746   on 2
            O  0.000846341  0.502991932  0.60238033   on 1
            O  0.506466274  0.004949716 -0.59285598   on 2
            ...
    }
  }
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">rigid_body</span></code> のデフォルト値は0であり、この場合その原子はどの剛体にも属さず通常通りの扱いとなります。1以上の値を指定すると剛体に属するようになります。数値自体は任意に割り当てることが可能です。同じ数値が指定された原子が共通の剛体に属することになります。</p>
<p>剛体ごとの振る舞いを設定するためには <code class="docutils literal notranslate"><span class="pre">rigid_body</span></code> ブロックおよび <code class="docutils literal notranslate"><span class="pre">rigid_bodyx</span></code> ブロックを用います。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>rigid_body{
  mobile=on
  dt_translation = 100
  dt_rotation    = 200
}
rigid_body1{
  mobilex      = off
  mobilerot    = off
  thermo_group = 2
}
</pre></div>
</div>
<p>ここで <code class="docutils literal notranslate"><span class="pre">x</span></code> は剛体のIDであり、 <code class="docutils literal notranslate"><span class="pre">atoms</span></code> テーブルの属性値 <code class="docutils literal notranslate"><span class="pre">rigid_body</span></code> に指定する値です。 <code class="docutils literal notranslate"><span class="pre">rigid_body</span></code> ブロックで剛体全体に通用する設定を、 <code class="docutils literal notranslate"><span class="pre">rigid_bodyx</span></code> で剛体 <code class="docutils literal notranslate"><span class="pre">x</span></code> に適用したい設定を施します。 <code class="docutils literal notranslate"><span class="pre">rigid_body</span></code> ,  <code class="docutils literal notranslate"><span class="pre">rigid_bodyx</span></code> で利用できる変数は下記の通り。</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>変数名    説明</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>dt_rotation</p></td>
<td><p>重心回りの回転の時間発展に用いる刻み幅。デフォルト値は通常の時間刻みと同じ値。</p></td>
</tr>
<tr class="row-odd"><td><p>dt_translation</p></td>
<td><p>重心の並進の時間発展に用いる刻み幅。デフォルト値は通常の時間刻みと同じ値。</p></td>
</tr>
<tr class="row-even"><td><p>mobile</p></td>
<td><p>重心の並進の可動性をon/offで設定します。デフォルト値はon.</p></td>
</tr>
<tr class="row-odd"><td><p>mobilex, mobiley, mobilez</p></td>
<td><p>重心の並進のx, y, z方向の可動性をon/offで設定します。デフォルト値はon.</p></td>
</tr>
<tr class="row-even"><td><p>mobilerot</p></td>
<td><p>重心回りの可動性をon/offで設定します。デフォルト値はon.</p></td>
</tr>
<tr class="row-odd"><td><p>thermo_group</p></td>
<td><p>重心に割り当てる熱浴を設定します。剛体は、速度スケーリングによって割り当てられた熱浴の温度にいたります。デフォルト値は1.</p></td>
</tr>
</tbody>
</table>
<p>最適化計算の際、剛体の並進力と重心回りのトルクがともに閾値以下になった段階で収束したとみなされます。これらの閾値は以下のように設定します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>accuracy{
  force_convergence{
    max_translational_force = 1e-3 hartree/bohr
  }
  torque_convergence{
    max_torque = 1e-3 hartree
  }
}
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">accuracy</span></code> ブロックの <code class="docutils literal notranslate"><span class="pre">force_convergence</span></code> ブロックにおいて変数 <code class="docutils literal notranslate"><span class="pre">max_translational_force</span></code> を用いて最大の並進力を指定します。単位は <code class="docutils literal notranslate"><span class="pre">hartree/bohr</span></code>, デフォルト値は 1e-3です。
<code class="docutils literal notranslate"><span class="pre">accuracy</span></code> ブロックの <code class="docutils literal notranslate"><span class="pre">torque_convergence</span></code> ブロックにおいて変数 <code class="docutils literal notranslate"><span class="pre">max_torque</span></code> を用いて最大のトルクを指定します。単位は <code class="docutils literal notranslate"><span class="pre">hartree</span></code>, デフォルト値は 1e-3です。
利用できる最適化手法はQuenched MD法のみです。</p>
<p>分子動力学シミュレーションは通常通り設定すれば実行することができます。</p>
<p>なお、最適化の場合も分子動力学シミュレーションの場合も、時間きざみは剛体全体の質量を考慮してきめるようにしてください。</p>
</section>
<section id="id147">
<h4><span class="section-number">9.10.2.2. </span>出力<a class="headerlink" href="#id147" title="この見出しへのパーマリンク"></a></h4>
<p>通常の計算と同様、座標データの履歴は <code class="docutils literal notranslate"><span class="pre">F_DYNM</span></code> ファイルに記録されます。 <code class="docutils literal notranslate"><span class="pre">F_ENF</span></code> ファイルには通常出力されるエネルギーや原子間力最大値のほか、重心の並進力の最大値、トルクの最大値が記録されます。ログファイルには以下の要領で読み込んだ剛体に関する情報が記録されるので、想定通りの剛体指定ができているかどうか確認することが推奨されます。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>!** rigid body no.     2 ID     2
!** number of atoms defined in this rigid body     8
      2       4       6       7      10      11      14      15
!** mass         109473.91903
!** COM               5.44118             0.05616            -2.77364
!** inertia         298097.06023        313978.40985        611375.59512
!** quaternion              0.25970             0.65157            -0.28261
!** initial rotation matrix
  0.70537  -0.70827  -0.02842
  0.03142  -0.00882   0.99947
 -0.70814  -0.70589   0.01603
 ...
</pre></div>
</div>
</section>
</section>
<section id="id148">
<h3><span class="section-number">9.10.3. </span>計算例<a class="headerlink" href="#id148" title="この見出しへのパーマリンク"></a></h3>
<p>簡単な計算例として、尿素結晶による構造最適化や分子動力学シミュレーションを実施した例を紹介します。
例題の入力ファイルは <code class="docutils literal notranslate"><span class="pre">samples/dynamics/rigid_body/urear</span></code> 以下にあります(MDの適用例は <code class="docutils literal notranslate"><span class="pre">samples/dynamics/rigid_body/urea</span></code> 以下にあります)
尿素結晶とは次に示すような結晶構造を持つ分子性結晶です。</p>
<figure class="align-default" id="ion-dynamics-urea-structure">
<img alt="../_images/urea_structure.png" src="../_images/urea_structure.png" />
<figcaption>
<p><span class="caption-number">図 9.47 </span><span class="caption-text">分子性結晶尿素の構造。</span><a class="headerlink" href="#ion-dynamics-urea-structure" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
<p>基本的な計算条件は下記の通り。</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>平面波カットオフ [Ry]</p></td>
<td><p>30</p></td>
</tr>
<tr class="row-even"><td><p>電荷密度カットオフ [Ry]</p></td>
<td><p>300</p></td>
</tr>
<tr class="row-odd"><td><p>k点サンプリング</p></td>
<td><p>Monkhorst-Pack 2×2×2</p></td>
</tr>
</tbody>
</table>
<p>剛体の最適化手法はquenched MDのみを利用することができます。構造最適化の履歴を <a class="reference internal" href="#ion-dynamics-urea-relax-history"><span class="std std-numref">図 9.48</span></a> に示します。
iteration進行とともに順調にエネルギーが下がり、最大トルクおよび最大並進力も時折上昇しながらもトレンドとしてはiteration_ionicとともに下降しており、
想定通り最適化を行うことができています。</p>
<figure class="align-default" id="ion-dynamics-urea-relax-history">
<img alt="../_images/urea_relax.svg" src="../_images/urea_relax.svg" /><figcaption>
<p><span class="caption-number">図 9.48 </span><span class="caption-text">剛体ダイナミクスによる構造最適化の履歴。</span><a class="headerlink" href="#ion-dynamics-urea-relax-history" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
</section>
</section>
<section id="section-neural-network-potential">
<span id="id149"></span><h2><span class="section-number">9.11. </span>機械学習によるニューラルネットワークポテンシャルの作成 (バージョン2021.01以降)<a class="headerlink" href="#section-neural-network-potential" title="この見出しへのパーマリンク"></a></h2>
<section id="id150">
<h3><span class="section-number">9.11.1. </span>概要<a class="headerlink" href="#id150" title="この見出しへのパーマリンク"></a></h3>
<p>ニューラルネットワークポテンシャルとは、凝縮系のポテンシャルエネルギー表面を近似することのできる学習モデルです <a class="reference internal" href="#behler07" id="id151"><span>[Behler07]</span></a> 。その学習は、PHASE/0などの第一原理計算の結果を教師データとして行われます。PHASE/0には、<a class="reference external" href="http://ann.atomistic.net/">ænet</a> <a class="reference internal" href="#artrith16" id="id152"><span>[Artrith16]</span></a> や <a class="reference external" href="https://compphysvienna.github.io/n2p2/">n2p2</a> <a class="reference internal" href="#singraber19" id="id153"><span>[Singraber19]</span></a> などのソフトウェアと連携し、ニューラルネットワークポテンシャルを作成することができる機能が備わっています。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>2024.01版以降 <a class="reference external" href="https://docs.deepmodeling.com/projects/deepmd/en/master/">deepmd</a>  <a class="reference internal" href="#wang18" id="id154"><span>[Wang18]</span></a> の教師データも出力することができるようになりました。</p>
</div>
</section>
<section id="id155">
<h3><span class="section-number">9.11.2. </span>使い方<a class="headerlink" href="#id155" title="この見出しへのパーマリンク"></a></h3>
<section id="id156">
<h4><span class="section-number">9.11.2.1. </span>教師データの作成<a class="headerlink" href="#id156" title="この見出しへのパーマリンク"></a></h4>
<p>以下に説明するような手続きによって、n2p2, ænetおよびdeepmdの教師データとして用いることのできるデータを出力することができます。</p>
<p>入力パラメーターファイルに以下のような設定を施します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">structure_evolution</span><span class="p">{</span>
  <span class="o">...</span>
  <span class="o">...</span>
  <span class="n">nnp_output</span><span class="p">{</span>
    <span class="n">sw_nnp_output</span> <span class="o">=</span> <span class="n">on</span>
    <span class="n">filetype</span> <span class="o">=</span> <span class="nb">all</span>
    <span class="n">frequency</span> <span class="o">=</span> <span class="mi">100</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Structure_evolutionブロックにおいてnnp_outputブロックを作成し、機械学習ポテンシャル用出力の設定を行います。sw_nnp_output = onとすると機械学習ポテンシャル用出力が行われます。filetypeで出力するファイルの種類を指定することができます。XSFを指定するとænetで利用できるXSF形式、n2p2を指定するとn2p2で利用できる形式、deepmdを指定するとdeepmdで利用できる形式、allを指定すると対応しているすべての形式の教師データが出力されます。frequencyによってサンプリングの頻度を指定します。このパラメーターのデフォルト値は100です。ファイル名のデフォルト値は、n2p2がinput.data, XSFがnfdynm <em>xxxxx</em> .xsfです。ここで <em>xxxxx</em> はMDステップ数です。n2p2は学習データが一つのファイルに記録されるのに対し、ænetはスナップショット1つにつき1つのXSFが必要です。deepmdの場合、 <code class="docutils literal notranslate"><span class="pre">type.raw</span></code> <code class="docutils literal notranslate"><span class="pre">type_map.raw</span></code> というファイルに元素情報が出力され、さらに <code class="docutils literal notranslate"><span class="pre">set.000</span></code> というディレクトリーの下に教師データファイルが固定ファイル名で出力されます。</p>
<p>file_names.dataファイルにおいては、n2p2およびXSF形式のファイルのファイル名を指定することができます。デフォルト値はそれぞれinput.dataおよびnfdynm <em>xxxxx</em> .xsfです。deepmdの場合ファイル名は固定で変更することはできません。</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>ファイルポインター</p></th>
<th class="head"><p>説明</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>F_N2P2</p></td>
<td><p>n2p2の教師データの出力先。デフォルト値はnfdynm.n2p2</p></td>
</tr>
<tr class="row-odd"><td><p>F_XSF</p></td>
<td><p>ænetの教師データの出力先。ここで指定した文字列の拡張子に相当する部分の直前にMDのイテレーション数が付加されたファイル名が採用される。デフォルト値はnfdynm.xsf</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id157">
<h4><span class="section-number">9.11.2.2. </span>サンプル時の収束判定条件の切り替え<a class="headerlink" href="#id157" title="この見出しへのパーマリンク"></a></h4>
<p>教師データをサンプルする際、相関が強くなりすぎないようある程度間隔をあけて行うことが一般的ですが、サンプルするステップ以外のステップの重要性は低いと考えられます。そこで、サンプルするステップ以外は甘い収束判定で計算を行うことによって計算時間の短縮をはかることができます。このような処理を実現するには、以下のような設定を入力パラメーターファイルに施します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">accuracy</span><span class="p">{</span>
    <span class="o">...</span>
    <span class="n">scf_convergence</span><span class="p">{</span>
        <span class="n">delta_total_energy</span> <span class="o">=</span> <span class="mf">1e-4</span> <span class="n">Hartree</span>
        <span class="n">delta_total_energy_sampling</span> <span class="o">=</span> <span class="mf">1.e-9</span>
        <span class="n">succession</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>accuracyブロックのscf_convergenceブロックにおいてSCF計算の収束判定条件の設定は行われるが、ここでdelta_total_energy_samplingキーワードを使ってサンプリングの時のみに用いる収束判定条件を指定することができます。この例では、通常のSCF計算では1e-4 hartreeという収束判定条件が採用されますが、サンプリングステップの場合1e-9という収束判定条件が採用されます。</p>
</section>
<section id="id158">
<h4><span class="section-number">9.11.2.3. </span>教師データの形式<a class="headerlink" href="#id158" title="この見出しへのパーマリンク"></a></h4>
<p>教師データのファイル形式について説明します。</p>
<p>input.n2p2ファイル</p>
<blockquote>
<div><p>input.n2p2ファイルはn2p2プログラムで利用できる教師データ形式です。以下の形式で原子配置と対応するエネルギーが記録されます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">begin</span>
<span class="n">comment</span> <span class="n">iteration</span>      <span class="mi">100</span>
<span class="n">lattice</span>             <span class="mf">5.6022996655</span>             <span class="mf">0.0000000000</span>             <span class="mf">0.0000000000</span>
<span class="n">lattice</span>             <span class="mf">0.0000000000</span>             <span class="mf">9.7034676599</span>             <span class="mf">0.0000000000</span>
<span class="n">lattice</span>             <span class="mf">0.0000000000</span>             <span class="mf">0.0000000000</span>            <span class="mf">14.7489157721</span>
<span class="n">atom</span> <span class="mf">5.054</span> <span class="mf">4.636</span> <span class="mf">1.407</span> <span class="n">Li</span> <span class="mf">0.00</span> <span class="mf">0.00</span> <span class="o">-</span><span class="mf">0.141</span> <span class="o">-</span><span class="mf">0.0743</span> <span class="mf">0.1568</span>
<span class="o">...</span>
<span class="n">energy</span> <span class="o">-</span><span class="mf">25706.79549229032</span>
<span class="n">charge</span> <span class="mf">0.0</span>
<span class="n">end</span>
<span class="n">begin</span>
<span class="o">...</span>
<span class="n">end</span>
</pre></div>
</div>
<p>beginとendの間に1つのデータが記録されます。commentから始まる行でコメントを記述できます。latticeから始まる行で格子ベクトルの指定を行います。atomから始まる行で原子の情報を記述します。2カラム目から4カラム目に原子のxyz座標を指定し、5カラム目に元素名を指定します。6, 7カラム目は未使用領域ですが、適当な数値を記述する必要があります。8カラム目から10カラム目で原子間力を指定します。原子間力は学習に直接利用されるわけではありませんが、結果得られる機械学習ポテンシャルから得られる原子間力との差を評価し、誤差を推測する、という使われ方がなされる場合があります。energyから始まる行でエネルギーを指定します。chargeから始まる行で系の総電荷を指定します。ただしcharge指定による情報は現バージョンのn2p2では利用されないようです。利用される単位は単位はエネルギーがeV, 距離がÅ, 原子間力がeV/Åです。</p>
<p>n2p2の入力として利用するには、データはinput.dataというファイルに記録されている必要があります。複数のディレクトリーにまたがって行った計算の結果を活用したい場合、これらをcatコマンドとリダイレクトなどを利用して一つのファイルにまとめる必要があります。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cat A/input.data &gt;  input.data
$ cat B/input.data &gt;&gt; input.data
$ cat C/input.data &gt;&gt; input.data
...
</pre></div>
</div>
</div></blockquote>
<p>xsf</p>
<blockquote>
<div><p>xsfは <a class="reference external" href="http://www.xcrysden.org/">XCrysDen</a> などにおいて標準的に用いられる座標データ形式です。ænetはこの形式を教師データ形式として採用しています。XSFにおいては、以下の形式で原子配置と対応するエネルギーが記録されます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># total energy =         -25711.2660427032 eV</span>
<span class="n">CRYSTAL</span>
<span class="n">PRIMVEC</span>
             <span class="mf">5.6022996655</span>             <span class="mf">0.0000000000</span>             <span class="mf">0.0000000000</span>
             <span class="mf">0.0000000000</span>             <span class="mf">9.7034676599</span>             <span class="mf">0.0000000000</span>
             <span class="mf">0.0000000000</span>             <span class="mf">0.0000000000</span>            <span class="mf">14.7489157721</span>
<span class="n">PRIMCOORD</span>
      <span class="mi">84</span>       <span class="mi">1</span>
 <span class="n">Li</span>  <span class="mf">5.0229472700</span> <span class="mf">5.0300845743</span> <span class="mf">1.8014586046</span> <span class="o">-</span><span class="mf">0.1368952902</span> <span class="o">-</span><span class="mf">0.0902290564</span> <span class="o">-</span><span class="mf">0.4716359333</span>
<span class="o">...</span>
</pre></div>
</div>
<p>#から始まる行はXSF形式ではコメント行とみなされますが、ænetは# total energyという文字列がある場合はエネルギーが指定される行とみなし、= の後の数値をエネルギー値として採用します。CRYSTAL行を記述することによってこのあと結晶のデータが記録されていることを指定します。PRIMVEC行を記述することによってこのあとの3行が <em>a</em> 軸、 <em>b</em> 軸、<em>c</em> 軸の格子ベクトルの指定であることを指定します。PRIMCOORDを記述することによって続く行が原子座標や原子間力の指定に利用されることを指定します。まずは原子数が指定されます。この例では84 1となっており、84原子系であることが指定されています。その次の1という数値はænetでは利用しない情報ですがXSF形式の様式を満たすために必要です。その次の行以降が原子の情報です。1カラム目が元素名、2カラム目から4カラム目が原子位置、5カラム目から7カラム目が原子間力です。単位はn2p2の場合と同様エネルギーがeV, 距離がÅ, 原子間力がeV/Åです。</p>
</div></blockquote>
<p>deepmdの教師データファイル</p>
<blockquote>
<div><p>deepmdの教師データファイルはいくつかのファイルからなります。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">type.raw</span></code> : 各原子の原子種が記録されます。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">type_map.raw</span></code> : <code class="docutils literal notranslate"><span class="pre">type.raw</span></code> においては0からはじまる整数値で原子種を指定します。この数値と元素名のマッピングを定義するのがこのファイルです。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">set.000/energy.raw</span></code> : エネルギーの履歴がeV単位で記録されるファイルです。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">set.000/box.raw</span></code> : セルベクトルの履歴がÅ単位で記録されるファイルです。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">set.000/coord.raw</span></code> : 原子座標の履歴がÅ単位で記録されるファイルです。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">set.000/force.raw</span></code> : 原子間力の履歴がeV/Å単位で記録されるファイルです。</p></li>
</ul>
</div></blockquote>
</section>
</section>
<section id="id159">
<h3><span class="section-number">9.11.3. </span>ニューラルネットワークポテンシャル作成例<a class="headerlink" href="#id159" title="この見出しへのパーマリンク"></a></h3>
<p>ここでは、<span class="math notranslate nohighlight">\(\alpha\)</span> Quartz結晶を例に、ニューラルネットワークポテンシャルの作成方法について説明します。</p>
<section id="id160">
<h4><span class="section-number">9.11.3.1. </span>用いた結晶<a class="headerlink" href="#id160" title="この見出しへのパーマリンク"></a></h4>
<p>六方晶の <span class="math notranslate nohighlight">\(\alpha\)</span> Quartz結晶を直方晶に取り直し、さらに <em>a</em> 軸と <em>c</em> 軸をそれぞれ2倍とするスーパーセルを作成しました。合計72原子の系です。その初期配置は <a class="reference internal" href="#quartz72"><span class="std std-numref">図 9.49</span></a> に示す通り。</p>
<figure class="align-default" id="quartz72">
<img alt="../_images/Quartz72.png" src="../_images/Quartz72.png" />
<figcaption>
<p><span class="caption-number">図 9.49 </span><span class="caption-text">72原子 <span class="math notranslate nohighlight">\(\alpha\)</span> Quartz結晶</span><a class="headerlink" href="#quartz72" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
</section>
<section id="id161">
<h4><span class="section-number">9.11.3.2. </span>第一原理計算<a class="headerlink" href="#id161" title="この見出しへのパーマリンク"></a></h4>
<p><a class="reference internal" href="#quartz72"><span class="std std-numref">図 9.49</span></a> の結晶を初期構造として、温度500K, 800K, 1200Kで定温の第一原理計算分子動力学シミュレーションを実施しました。入力ファイルと教師データのアーカイブはサンプルディレクトリーの下のnnp/SiO2/fpmd以下のサブディレクトリーにあります。温度以外の主要な計算条件は下記の通り。</p>
<table class="docutils align-default" id="nnp-table1">
<caption><span class="caption-number">表 9.14 </span><span class="caption-text">第一原理分子動力学の主要な計算条件</span><a class="headerlink" href="#nnp-table1" title="このテーブルへのパーマリンク"></a></caption>
<tbody>
<tr class="row-odd"><td><p>計算条件</p></td>
<td><p>値</p></td>
</tr>
<tr class="row-even"><td><p>カットオフエネルギー</p></td>
<td><p>25 Rydberg</p></td>
</tr>
<tr class="row-odd"><td><blockquote>
<div><p><strong>k</strong> 点サンプリング</p>
</div></blockquote>
</td>
<td><blockquote>
<div><p><span class="math notranslate nohighlight">\(\Gamma\)</span> 点のみ</p>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td><p>収束判定条件</p></td>
<td><p>1e-9 hartree</p></td>
</tr>
<tr class="row-odd"><td><p>サンプリング頻度</p></td>
<td><p>10 MDステップに一度</p></td>
</tr>
<tr class="row-even"><td><p>総MDステップ数</p></td>
<td><p>10000</p></td>
</tr>
<tr class="row-odd"><td><p>教師データ出力</p></td>
<td><p>XSF形式</p></td>
</tr>
</tbody>
</table>
<p>このシミュレーションにおいてはサンプリング頻度が10 MDステップに一度と比較的高いため、収束判定条件を切り替える機能は用いていません。</p>
</section>
<section id="id162">
<h4><span class="section-number">9.11.3.3. </span>ニューラルネットワークポテンシャルの作成の準備<a class="headerlink" href="#id162" title="この見出しへのパーマリンク"></a></h4>
<p>得られた教師データを用いてニューラルネットワークポテンシャルを作成する方法を説明します。用いるアプリケーションはænetです。ænetの詳細については <a class="reference external" href="http://ann.atomistic.net/">ウェブサイトの情報</a> を参照してください</p>
<p>まずは、サンプルディレクトリーの下に教師データのアーカイブ（ファイル名xsf.tar.bz2）が配置されているので、それを解凍します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cd samples/nnp/SiO2/fpmd/500K
$ tar -jxvf xsf.tar.bz2
$ ...
$ cd ../800K
$ ...
</pre></div>
</div>
<p>成功すると、各ディレクトリーにファイル名がnfdynm <em>xxxxx</em> .xsfの1000個のxsfが作成されるはずです。</p>
<p>また、ænetのウェブサイトから最新版のアーカイブをダウンロードし、コンパイルしてください。成功すれば、ænetのインストールディレクトリーの下のbinディレクトリーにgenerate.x-*, train.x-*, predict.x-*の3つのバイナリーが作成されるはずです(ここで* はænetのバージョンやコンパイル環境を識別する文字列; 以降-*は省略)</p>
<p>最後に、<a class="reference external" href="https://lammps.sandia.gov/">古典分子動力学シミュレーターLAMMPS</a> <a class="reference internal" href="#plimpton95" id="id164"><span>[Plimpton95]</span></a> からænetで作れるニューラルネットワークポテンシャルを用いる場合、LAMMPSのænetインターフェース <a class="reference internal" href="#mori20" id="id165"><span>[Mori20]</span></a> を <a class="reference external" href="https://github.com/HidekiMori-CIT/aenet-lammps">作者のウェブサイト</a> からダウンロードし、指示に従ってLAMMPSに組み込んでください。</p>
</section>
<section id="id167">
<h4><span class="section-number">9.11.3.4. </span>教師データの変換<a class="headerlink" href="#id167" title="この見出しへのパーマリンク"></a></h4>
<p>教師データとしての原子配置は、必ずしも機械学習に適したものではないので、それを機械学習に適した形式（記述子）に変換する必要があります。このような変換を行うプログラムがgenerate.xです。
generate.xを実行するために必要な入力はgenerate.xの全体の振る舞いを制御するコントロールファイル (generate.in) と元素ごとの記述子の構築の仕方を指定するセットアップファイルです。サンプルデータは <code class="code docutils literal notranslate"><span class="pre">samples/nnp/SiO2/aenet/generate</span></code> の下にあります。</p>
<p>generate.inファイルの内容は、典型的には下記のようになります。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">OUTPUT</span> <span class="n">SiO</span><span class="o">.</span><span class="n">train</span>

<span class="n">TYPES</span>
<span class="mi">2</span>
<span class="n">Si</span> <span class="o">-</span><span class="mf">107.171</span> <span class="o">|</span> <span class="n">eV</span>
<span class="n">O</span>  <span class="o">-</span><span class="mf">434.109</span> <span class="o">|</span> <span class="n">eV</span>

<span class="n">SETUPS</span>
<span class="n">Si</span>  <span class="n">Si</span><span class="o">.</span><span class="n">fingerprint</span><span class="o">.</span><span class="n">stp</span>
<span class="n">O</span>   <span class="n">O</span><span class="o">.</span><span class="n">fingerprint</span><span class="o">.</span><span class="n">stp</span>

<span class="n">FILES</span>
<span class="mi">3000</span>
<span class="o">../../</span><span class="n">fpmd</span><span class="o">/</span><span class="mi">800</span><span class="n">K</span><span class="o">/</span><span class="n">nfdynm000772</span><span class="o">.</span><span class="n">xsf</span>
<span class="o">../../</span><span class="n">fpmd</span><span class="o">/</span><span class="mi">800</span><span class="n">K</span><span class="o">/</span><span class="n">nfdynm000038</span><span class="o">.</span><span class="n">xsf</span>
<span class="o">...</span>
<span class="o">...</span>
</pre></div>
</div>
<ul class="simple">
<li><p>OUTPUTにgenerate.xの結果を出力するファイルを指定します。この例ではSiO.trainです。</p></li>
<li><p>TYPESにおいて原子種の指定を行います。まず利用する元素数を指定し（この例では2）, 一行に1元素ずつ元素名と原子の参照エネルギーを指定します。この例では、シリコン結晶と酸素分子の1原子あたりのエネルギーを採用しました。</p></li>
<li><p>SETUPSに元素ごとのセットアップファイルを <code class="docutils literal notranslate"><span class="pre">元素名</span> <span class="pre">セットアップファイル</span></code> という形式で指定します。</p></li>
<li><p>FILESにおいて教師データを指定します。まず教師データの数を指定し、1行に1ファイル教師データが記録されたファイルのパスを指定します。</p></li>
</ul>
<p>セットアップファイルの内容は、典型的には下記のようになります。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ATOM</span> <span class="n">Si</span>

<span class="n">ENV</span> <span class="mi">2</span>
<span class="n">Si</span>
<span class="n">O</span>

<span class="n">RMIN</span> <span class="mf">0.85</span><span class="n">d0</span>

<span class="n">BASIS</span> <span class="nb">type</span><span class="o">=</span><span class="n">Chebyshev</span>
<span class="n">radial_Rc</span> <span class="o">=</span> <span class="mf">6.0</span>  <span class="n">radial_N</span> <span class="o">=</span> <span class="mi">16</span> <span class="n">angular_Rc</span> <span class="o">=</span> <span class="mf">6.0</span>  <span class="n">angular_N</span> <span class="o">=</span> <span class="mi">8</span>
</pre></div>
</div>
<ul class="simple">
<li><p>ATOM 元素名とし、対象元素を指定します。</p></li>
<li><p>ENV Nとし、その元素と相互作用し得る元素の数を指定します。さらに、具体的にどの元素が相互作用し得るかを1行につき1元素名という形式で指定します。</p></li>
<li><p>RMINによって最小距離を指定します。</p></li>
<li><p>BASISにおいて記述子の種類を指定します。type=ChebyshevとするとChebyshev展開を用いて記述子を構築します <a class="reference internal" href="#artrith17" id="id168"><span>[Artrith17]</span></a> この場合、後段のradial_Rcとradial_Nによって動径方向のカットオフ距離と分割数、angular_Rcとangular_Nによって角度方向のカットオフ距離と分割数を指定します。</p></li>
</ul>
<p>generate.inファイルとセットアップファイルが準備できたら、generate.xを実行します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ generate.x generate.in &gt; generate.log
</pre></div>
</div>
<p>この処理の結果、generate.inにおいてOUTPUTキーワードで指定したファイルに結果が記録されます。このファイルを学習用のディレクトリー（今の例の場合 <code class="code docutils literal notranslate"><span class="pre">samples/nnp/SiO2/aenet/train</span></code> ）にコピーします。</p>
</section>
<section id="id169">
<h4><span class="section-number">9.11.3.5. </span>ニューラルネットワークポテンシャルの学習<a class="headerlink" href="#id169" title="この見出しへのパーマリンク"></a></h4>
<p>generate.xによって変換した座標データとエネルギーのセットを用いてtrain.xによる学習を行うことができます。そのコントロールファイル(train.in)は、典型的には以下のように記述します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>TRAININGSET SiO.train
TESTPERCENT 10
ITERATIONS  5000

MAXENERGY 1.0

METHOD
bfgs

 NETWORKS
 ! atom   network         hidden
 ! types  file-name       layers  nodes:activation
   Si    Si.10t-10t.nn    2      10:tanh 10:tanh
   O      O.10t-10t.nn    2      10:tanh 10:tanh
</pre></div>
</div>
<ul class="simple">
<li><p>TRAININGSETでgenerate.xによって作成されたファイルを指定します。</p></li>
<li><p>TESTPERCENTで教師データの内学習ではなくテストに利用するパーセンテージを指定します。</p></li>
<li><p>ITERATIONS 学習はiterativeに行われますが、そのiterationの最大回数を指定します。</p></li>
<li><p>METHOD : 学習の手法を指定します。bfgsのほか、Levenberg-Marquardt法などを利用することができます。bfgs法は設定が必要なパラメーターが少なく、ロバストな最適化が可能なため推奨の方法です。</p></li>
<li><p>NEWORKSにおいてベースとなるニューラルネットワークを指定します。1行につき1元素の指定を行います。まず元素名を記述し、つぎにニューラルネットワークの重みを記録するファイルを指定します。さらに隠れ層の数を指定し、最後に隠れ層の数分ノード数とactivation function (階段関数の近似)の形式を指定します。</p></li>
</ul>
<p>train.xを以下の要領で実行します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mpiexec -n 8 train.x train.in &gt; train.log
</pre></div>
</div>
<p>このコマンドはMPIを介して8並列で実行する例です。具体的なコマンドはシステムによって異なる可能性があります。</p>
<p>ログは標準出力に出力されるので、この例ではリダイレクトされtrain.logというファイルに出力されます。train.logには様々な情報が記録されます。学習がうまくいっているかどうかの確認は以下のようにTraining process以降のデータを参照するようにしてください。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">----------------------------------------------------------------------</span>
                           <span class="n">Training</span> <span class="n">process</span>
<span class="o">----------------------------------------------------------------------</span>

<span class="n">Weight</span> <span class="n">optimization</span> <span class="k">for</span> <span class="mi">5000</span> <span class="n">epochs</span> <span class="n">using</span> <span class="n">the</span> <span class="n">Limited</span> <span class="n">Memory</span> <span class="n">BFGS</span> <span class="n">method</span><span class="o">.</span>

<span class="n">Sampling</span> <span class="nb">type</span>               <span class="p">:</span> <span class="n">sequential</span>

       <span class="o">|------------</span><span class="n">TRAIN</span><span class="o">-----------|</span>  <span class="o">|------------</span><span class="n">TEST</span><span class="o">------------|</span>
<span class="n">epoch</span>             <span class="n">MAE</span>          <span class="o">&lt;</span><span class="n">RMSE</span><span class="o">&gt;</span>             <span class="n">MAE</span>          <span class="o">&lt;</span><span class="n">RMSE</span><span class="o">&gt;</span>
    <span class="mi">0</span>    <span class="mf">2.055153E-01</span>    <span class="mf">2.392261E-01</span>    <span class="mf">2.059784E-01</span>    <span class="mf">2.414336E-01</span> <span class="o">&lt;</span>
    <span class="mi">1</span>    <span class="mf">2.055153E-01</span>    <span class="mf">2.392261E-01</span>    <span class="mf">2.059784E-01</span>    <span class="mf">2.414336E-01</span> <span class="o">&lt;</span>
    <span class="mi">2</span>    <span class="mf">1.338985E-01</span>    <span class="mf">1.499288E-01</span>    <span class="mf">1.358931E-01</span>    <span class="mf">1.509523E-01</span> <span class="o">&lt;</span>
    <span class="mi">3</span>    <span class="mf">4.876623E-02</span>    <span class="mf">7.448498E-02</span>    <span class="mf">4.891127E-02</span>    <span class="mf">7.381589E-02</span> <span class="o">&lt;</span>
    <span class="mi">4</span>    <span class="mf">3.806436E-02</span>    <span class="mf">5.418523E-02</span>    <span class="mf">3.679157E-02</span>    <span class="mf">5.251901E-02</span> <span class="o">&lt;</span>
   <span class="o">...</span>
   <span class="o">...</span>
</pre></div>
</div>
<p>特にTESTのMAE (mean absolute error), RMSE (root mean square error)の値に注目し、これが初期値に比べ小さくなっているepochを採用するようにしてください。</p>
<p>ネットワークの重みづけファイル（分子動力学シミュレーションなどにおいて利用するファイル）はtrain.inにおいて指定した文字列に、学習のiteration回数が付与されたファイル名(たとえばSi.10t-10t.nn-00100など)のファイルに出力されます。</p>
</section>
<section id="id170">
<h4><span class="section-number">9.11.3.6. </span>ニューラルネットワークポテンシャルの検証<a class="headerlink" href="#id170" title="この見出しへのパーマリンク"></a></h4>
<p>ænet付属のプログラムpredict.xを用いることによって、作成したニューラルネットワークポテンシャルの検証を行うことができます。predict.xはxsfとニューラルネットワークポテンシャルの重みファイルを入力とし、エネルギーや原子間力の計算と構造最適化を行うことができます (predict.xでできることはこれだけなので、本格的な活用のためにはLAMMPSインターフェースなどを利用することが推奨されます)</p>
<p>predict.xのコントロールファイル (predict.in)は典型的には以下のようになります（このサンプル入力は <code class="code docutils literal notranslate"><span class="pre">samples/nnp/SiO2/aenet/predict</span></code> 以下にあります）</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">TYPES</span>
<span class="mi">2</span>
<span class="n">Si</span>
<span class="n">O</span>

<span class="n">NETWORKS</span>
  <span class="n">Si</span> <span class="n">Si</span><span class="mf">.10</span><span class="n">t</span><span class="o">-</span><span class="mi">10</span><span class="n">t</span><span class="o">.</span><span class="n">nn</span>
   <span class="n">O</span>  <span class="n">O</span><span class="mf">.10</span><span class="n">t</span><span class="o">-</span><span class="mi">10</span><span class="n">t</span><span class="o">.</span><span class="n">nn</span>

<span class="n">FORCES</span>

<span class="n">FILES</span>
<span class="mi">3000</span>
<span class="o">../../</span><span class="n">fpmd</span><span class="o">/</span><span class="mi">800</span><span class="n">K</span><span class="o">/</span><span class="n">nfdynm000772</span><span class="o">.</span><span class="n">xsf</span>
<span class="o">../../</span><span class="n">fpmd</span><span class="o">/</span><span class="mi">800</span><span class="n">K</span><span class="o">/</span><span class="n">nfdynm000038</span><span class="o">.</span><span class="n">xsf</span>
<span class="o">...</span>
<span class="o">...</span>
</pre></div>
</div>
<ul class="simple">
<li><p>TYPESの次の行で原子種の数を指定します。それに続く行で元素名を記述します。</p></li>
<li><p>NETWORKSに続く行で、元素名 ニューラルネットワークポテンシャルの重みファイル名 という形式でニューラルネットワークポテンシャルの重みファイルを指定します。</p></li>
<li><p>原子間力を計算する場合、FORCESというキーワードを記述します。</p></li>
<li><p>FILESキーワードとそれに続く行において、generate.inと同じ形式で対象の原子配置を記述したXSFを指定することができます。この部分がない場合、対象の原子配置ファイルはpredict.x実行時に引数指定する。</p></li>
</ul>
<p>predict.xはgenerate.x, train.xと同じように実行することができます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ predict.x predict.in &gt; predict.log
</pre></div>
</div>
<p>結果は標準出力に出力されるので、上述のコマンド例の場合predict.logファイルに記録されます。たとえば以下のような内容になります。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">----------------------------------------------------------------------</span>
                             <span class="n">Parallel</span> <span class="n">run</span>
<span class="o">----------------------------------------------------------------------</span>

<span class="n">Number</span> <span class="n">of</span> <span class="n">processes</span> <span class="p">:</span> <span class="mi">1</span>
<span class="o">...</span>
<span class="o">...</span>
<span class="o">...</span>
<span class="n">Cartesian</span> <span class="n">atomic</span> <span class="n">coordinates</span> <span class="p">(</span><span class="nb">input</span><span class="p">)</span> <span class="ow">and</span> <span class="n">corresponding</span> <span class="n">atomic</span> <span class="n">forces</span><span class="p">:</span>

         <span class="n">x</span>             <span class="n">y</span>             <span class="n">z</span>             <span class="n">Fx</span>           <span class="n">Fy</span>            <span class="n">Fz</span>
        <span class="p">(</span><span class="n">Ang</span><span class="p">)</span>         <span class="p">(</span><span class="n">Ang</span><span class="p">)</span>         <span class="p">(</span><span class="n">Ang</span><span class="p">)</span>       <span class="p">(</span><span class="n">eV</span><span class="o">/</span><span class="n">Ang</span><span class="p">)</span>      <span class="p">(</span><span class="n">eV</span><span class="o">/</span><span class="n">Ang</span><span class="p">)</span>      <span class="p">(</span><span class="n">eV</span><span class="o">/</span><span class="n">Ang</span><span class="p">)</span>
<span class="o">--------------------------------------------------------------------------------------</span>
<span class="n">Si</span>      <span class="mf">9.649365</span>      <span class="mf">8.409237</span>      <span class="mf">9.994378</span>      <span class="mf">0.235924</span>      <span class="mf">0.525635</span>     <span class="o">-</span><span class="mf">1.368195</span>
<span class="n">Si</span>      <span class="mf">1.351787</span>      <span class="mf">1.864069</span>      <span class="mf">0.963064</span>      <span class="mf">2.655693</span>      <span class="mf">2.032425</span>     <span class="o">-</span><span class="mf">0.024373</span>
<span class="n">Si</span>      <span class="mf">1.296394</span>      <span class="mf">6.654412</span>      <span class="mf">2.411131</span>      <span class="mf">1.116420</span>      <span class="mf">0.752235</span>      <span class="mf">1.365680</span>
<span class="n">O</span>       <span class="mf">8.774874</span>      <span class="mf">1.120195</span>      <span class="mf">9.374453</span>     <span class="o">-</span><span class="mf">0.116155</span>      <span class="mf">1.088577</span>     <span class="o">-</span><span class="mf">0.440955</span>
<span class="o">...</span>
<span class="o">...</span>

<span class="n">Cohesive</span> <span class="n">energy</span>            <span class="p">:</span>         <span class="o">-</span><span class="mf">184.66378181</span> <span class="n">eV</span>
<span class="n">Total</span> <span class="n">energy</span>               <span class="p">:</span>       <span class="o">-</span><span class="mf">23593.99978181</span> <span class="n">eV</span>
<span class="n">Mean</span> <span class="n">force</span> <span class="p">(</span><span class="n">must</span> <span class="n">be</span> <span class="n">zero</span><span class="p">)</span>  <span class="p">:</span>     <span class="o">-</span><span class="mf">0.000000</span>      <span class="mf">0.000000</span>      <span class="mf">0.000000</span>
<span class="o">...</span>
<span class="o">...</span>
</pre></div>
</div>
<p><a class="reference internal" href="#nnp-fig1"><span class="std std-numref">図 9.50</span></a> にpredict.xで計算したエネルギーと第一原理計算によって得られたエネルギーをプロットした図を示します。この図では、完全な学習ができていた場合はすべての点が斜め45度の直線にのります。学習が完璧であることはないので直線からのバラつきはあるものの、直線からの乖離は原子あたりおおむね1 meV以下であり、よく学習できていることが分かります。</p>
<figure class="align-default" id="nnp-fig1">
<img alt="../_images/nnp1.svg" src="../_images/nnp1.svg" /><figcaption>
<p><span class="caption-number">図 9.50 </span><span class="caption-text">第一原理計算とニューラルネットワークポテンシャルによって得られるエネルギーの比較</span><a class="headerlink" href="#nnp-fig1" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
</section>
<section id="aenetlammps">
<h4><span class="section-number">9.11.3.7. </span>ænetインターフェースを組み込んだLAMMPSの使い方<a class="headerlink" href="#aenetlammps" title="この見出しへのパーマリンク"></a></h4>
<p>ニューラルネットワークポテンシャルを用いてLAMMPSによる計算を行うには、まず重みファイル(Si.10t-10t.nn-xxxxxなど)のファイルを実行ディレクトリーにコピーします。その際、ファイル名末尾の“-xxxxx”の部分は取り除いたファイル名にします。</p>
<p>LAMMPSの入力スクリプトは通常通り用意します。単位はmetal, atom_styleはatomicを用います。すなわち、以下のような指定は必須です。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">units</span> <span class="n">metal</span>
<span class="n">atom_style</span> <span class="n">atomic</span>
</pre></div>
</div>
<p>ポテンシャル指定部分には以下のような文字列を指定します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pair_style</span>      <span class="n">aenet</span>
<span class="n">pair_coeff</span>      <span class="o">*</span> <span class="o">*</span> <span class="n">v00</span> <span class="n">Si</span> <span class="n">O</span> <span class="mi">10</span><span class="n">t</span><span class="o">-</span><span class="mi">10</span><span class="n">t</span><span class="o">.</span><span class="n">nn</span> <span class="n">Si</span> <span class="n">O</span>
</pre></div>
</div>
<ul class="simple">
<li><p>pair_style aenetによってænetのニューラルネットワークポテンシャルを利用することを指定します。</p></li>
<li><p>pair_coeffによってニューラルネットワークの重みファイルと元素のマッピングを行います。</p>
<ul>
<li><p>* *という文字列によってすべての元素間が対象であることを指定します。</p></li>
<li><p>v00によってænetプログラムが出力するファイルを利用することを指定します。</p></li>
<li><p>つづくSi O 10t-10t.nnはSi.10t-10t.nn, O.10t-10t.nnの2つのファイル指定の短縮形です。</p></li>
<li><p>最後のSi Oは元素へのマッピングで、1つ目のファイルはSi, 2つ目のファイルはOに対応する重みファイルであることを意味します。</p></li>
</ul>
</li>
<li><p>初期座標データファイルは、LAMMPSのatom_style atomicで用いられる形式で準備します。</p></li>
</ul>
<p><a class="reference internal" href="#nnp-fig2"><span class="std std-numref">図 9.51</span></a> に、ニューラルネットワークポテンシャルとPHASE/0による500Kおよび800Kにおける <span class="math notranslate nohighlight">\(\alpha\)</span> Quartzの分子動力学シミュレーションのトラジェクトリーから得られた二体分布関数および結合角分布関数を比較した結果を示します。<a class="reference internal" href="#nnp-fig2"><span class="std std-numref">図 9.51</span></a> より、得られたニューラルネットワークポテンシャルは第一原理計算の結果をよく再現するものであることが分かります。</p>
<figure class="align-default" id="nnp-fig2">
<img alt="../_images/nnp2.svg" src="../_images/nnp2.svg" /><figcaption>
<p><span class="caption-number">図 9.51 </span><span class="caption-text">500Kおよび800Kにおける二体分布関数と結合角分布関数の比較。赤線：PHASE/0による第一原理分子動力学シミュレーション、緑線：ニューラルネットワークポテンシャルによる古典分子動力学シミュレーション。</span><a class="headerlink" href="#nnp-fig2" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
<div role="list" class="citation-list">
<div class="citation" id="behler07" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id151">Behler07</a><span class="fn-bracket">]</span></span>
<p>J. Behler and M. Parrinello, Phys. Rev. Lett. 98, 146401 (2007)</p>
</div>
<div class="citation" id="artrith16" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id152">Artrith16</a><span class="fn-bracket">]</span></span>
<p>N. Artrith and A. Urban, Comput. Mater. Sci. 114 (2016) 135-150.</p>
</div>
<div class="citation" id="singraber19" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id153">Singraber19</a><span class="fn-bracket">]</span></span>
<p>Singraber, A.; Behler, J.; Dellago, C. J. Chem. Theory Comput. 15 (2019) 1827–1840.</p>
</div>
<div class="citation" id="plimpton95" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id164">Plimpton95</a><span class="fn-bracket">]</span></span>
<p>S. Plimpton, J. Comp. Phys. 117 (1995) 1-19.</p>
</div>
<div class="citation" id="mori20" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id165">Mori20</a><span class="fn-bracket">]</span></span>
<p>H. Mori and T. Ozaki, Physical Review Materials 4 (2020) 040601.</p>
</div>
<div class="citation" id="artrith17" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id168">Artrith17</a><span class="fn-bracket">]</span></span>
<p>N. Artrith, A. Urban, and G. Ceder, Phys. Rev. B 96 (2017) 014112.</p>
</div>
<div class="citation" id="wang18" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id154">Wang18</a><span class="fn-bracket">]</span></span>
<p>Han Wang, Linfeng Zhang, Jiequn Han, and Weinan E. Computer Physics Communications 228 (2018): 178-184.</p>
</div>
</div>
</section>
</section>
</section>
<section id="pimd-2022-01">
<span id="section-ion-dynamics-pimd"></span><h2><span class="section-number">9.12. </span>PIMDコードを用いた経路積分分子動力学シミュレーション (バージョン2022.01以降)<a class="headerlink" href="#pimd-2022-01" title="この見出しへのパーマリンク"></a></h2>
<section id="id171">
<h3><span class="section-number">9.12.1. </span>概要<a class="headerlink" href="#id171" title="この見出しへのパーマリンク"></a></h3>
<p>PIMDコード <a class="reference internal" href="#shiga22" id="id172"><span>[Shiga22]</span></a> <a class="reference internal" href="#shiga01" id="id173"><span>[Shiga01]</span></a> <a class="reference internal" href="#shiga00" id="id174"><span>[Shiga00]</span></a> はその名の通りPIMD (経路積分分子動力学)をはじめとした様々なシミュレーションを行うことができる分子動力学シミュレーターです。その特徴の一つに様々な第一原理シミュレーションソフトウェアなどを原子間力やエネルギーを計算するエンジンとして利用できるところにありますが、PHASE/0もこのエンジンとして用いることができるようになっています。すなわち、「ライブラリー版」のPHASE/0をビルドし、PIMDのライブラリーディレクトリーに配置した上でPIMDをビルドすることによってPHASE/0をPIMDのエネルギー/原子間力エンジンとして用いることができるようになります。対応するPIMDのバージョンは2.6.0以降です。</p>
</section>
<section id="id175">
<h3><span class="section-number">9.12.2. </span>ビルド方法<a class="headerlink" href="#id175" title="この見出しへのパーマリンク"></a></h3>
<p>まずPHASE/0のライブラリー版を作成します。<code class="docutils literal notranslate"><span class="pre">src_phase</span></code> もしくは <code class="docutils literal notranslate"><span class="pre">src_phase_3d</span></code> ディレクトリーにおいて以下のコマンドを実行します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>make libphase.a libesm.a
</pre></div>
</div>
<p>バージョン2.6.0以降のPIMDをダウンロードし、任意のディレクトリー（たとえば <code class="docutils literal notranslate"><span class="pre">pimd</span></code> ）に展開します。 <code class="docutils literal notranslate"><span class="pre">pimd/lib</span></code> に <code class="docutils literal notranslate"><span class="pre">phase0</span></code> というディレクトリーを作成し、そこに <code class="docutils literal notranslate"><span class="pre">libphase.a</span> <span class="pre">libesm.a</span></code> をコピーします。</p>
<pre class="literal-block">cd pimd/lib
mkdir phase0
cp $HOME/phase0_2024.01/src_phase_3d/libphase.a phase0/
cp $HOME/phase0_2024.01/src_phase_3d/libesm.a phase0/</pre>
<p>つぎに、PIMDのmakefileを編集します。makefileはPIMDインストールディレクトリーの下のsourceディレクトリーにあります。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>#     compile PIMD with PHASE/0
# PHASE0 = -Dphase0
PHASE0 =
</pre></div>
</div>
<p>この箇所を</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>#     compile PIMD with PHASE/0
PHASE0 = -Dphase0
#PHASE0 =
</pre></div>
</div>
<p>のように編集し、 <code class="docutils literal notranslate"><span class="pre">make</span></code> コマンドを実行すればPIMDをビルドすることができます。</p>
<p>うまくいけばバイナリーファイル <code class="docutils literal notranslate"><span class="pre">pimd.mpi.x</span></code> が作成されます。
なお、シリアル実行版のバイナリーファイル <code class="docutils literal notranslate"><span class="pre">pimd.x</span></code> も作成されますが、これは PHASE/0をエンジンとして用いることはできません。</p>
</section>
<section id="id176">
<h3><span class="section-number">9.12.3. </span>使い方<a class="headerlink" href="#id176" title="この見出しへのパーマリンク"></a></h3>
<p>PHASE/0の入力ファイルは通常通り用意します。原子配置についてはPHASE/0が配列などを確保する目的で必要ですが、実際の座標値はPIMDから渡されます。
したがって原子のならびや原子種はあっている必要がありますが、座標値や属性値はどのようなものでも問題ありません。</p>
<p>PIMDの入力ファイル (ファイル名 <code class="docutils literal notranslate"><span class="pre">input.dat</span></code> ) には以下のような設定を施します。</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&lt;ipotential&gt;
PHASE0

&lt;phase0_proc&gt;
ne nk ng
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">ne</span> <span class="pre">nk</span> <span class="pre">ng</span></code> にはそれぞれバンド並列数/k点並列数/G点並列数に相当する数値を入力してくだささい。2次元版を用いる場合 <code class="docutils literal notranslate"><span class="pre">ng</span></code> に相当する数値としては1を指定するようにしてください。
なお、各数値はPIMDによって各レプリカに割り当てられるMPI並列数が <code class="docutils literal notranslate"><span class="pre">ne</span> <span class="pre">nk</span> <span class="pre">ng</span></code> の積に等しくなるように決める必要があります。</p>
</section>
<section id="id177">
<h3><span class="section-number">9.12.4. </span>計算例<a class="headerlink" href="#id177" title="この見出しへのパーマリンク"></a></h3>
<p>PIMDを用いて六方晶氷の経路積分分子動力学シミュレーションを実行してみました。
PIMDのポテンシャルとしてはPHASE/0を用いました。
サンプルの入力データは <code class="docutils literal notranslate"><span class="pre">samples/dynamics/PIMD/ice</span></code> 以下の <code class="docutils literal notranslate"><span class="pre">pbe</span></code> および <code class="docutils literal notranslate"><span class="pre">pbe_classical</span></code> 以下に配置されています。前者にPIMDの入力、後者に古典MDの入力が配置されています。</p>
<figure class="align-default" id="hexagonal-ice-structure">
<img alt="../_images/hexagonal_ice.png" src="../_images/hexagonal_ice.png" />
<figcaption>
<p><span class="caption-number">図 9.52 </span><span class="caption-text">六方晶氷結晶の原子配置</span><a class="headerlink" href="#hexagonal-ice-structure" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
<p>計算条件は次に示す通りです。</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>カットオフエネルギー</p></td>
<td><p>25 Rydberg</p></td>
</tr>
<tr class="row-even"><td><p>k点サンプリング</p></td>
<td><p>2x2x2 Monkhorst-Packメッシュ</p></td>
</tr>
<tr class="row-odd"><td><p>格子定数</p></td>
<td><p>a=7.60357Å, c=7.142962Å</p></td>
</tr>
<tr class="row-even"><td><p>時間刻み</p></td>
<td><p>0.25 fs</p></td>
</tr>
<tr class="row-odd"><td><p>アンサンブル</p></td>
<td><p>NVTアンサンブル</p></td>
</tr>
<tr class="row-even"><td><p>温度</p></td>
<td><p>300K</p></td>
</tr>
<tr class="row-odd"><td><p>ビーズ数</p></td>
<td><p>1 (通常の分子動力学シミュレーション) 16 (PIMD)</p></td>
</tr>
</tbody>
</table>
<p>1000ステップほどMD/PIMDを実行した結果得られた二体分布関数を <a class="reference internal" href="#hexagonal-ice-gofr"><span class="std std-numref">図 9.53</span></a> に示します。
PIMDによるトラジェクトリーは通常の分子動力学シミュレーションによって得られるそれと大きく異なることがわかります。特に第一ピーク（水分子内の酸素原子と水素原子の結合）の振る舞いが大きく異なり、PIMDの場合はよりブロードなピークとなっています。これは水素の量子効果が効いているためと考えられます。</p>
<figure class="align-default" id="hexagonal-ice-gofr">
<img alt="../_images/hexagonal_ice_gofr.svg" src="../_images/hexagonal_ice_gofr.svg" /><figcaption>
<p><span class="caption-number">図 9.53 </span><span class="caption-text">六方晶氷結晶の二体分布関数。赤線：PIMD, 緑線：古典MD</span><a class="headerlink" href="#hexagonal-ice-gofr" title="この画像へのパーマリンク"></a></p>
</figcaption>
</figure>
</section>
<section id="id178">
<h3><span class="section-number">9.12.5. </span>注意事項<a class="headerlink" href="#id178" title="この見出しへのパーマリンク"></a></h3>
<p>ライブラリー版PHASE/0はストレステンソル計算には対応していません。したがって、PIMDのNPT計算などに用いることはできません。</p>
<p><strong>参考文献</strong></p>
<div role="list" class="citation-list">
<div class="citation" id="shiga22" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id172">Shiga22</a><span class="fn-bracket">]</span></span>
<p>M. Shiga, PIMD version 2.6.0 (2023).</p>
</div>
<div class="citation" id="shiga01" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id173">Shiga01</a><span class="fn-bracket">]</span></span>
<p>M. Shiga, M. Tachikawa, S. Miura, J. Chem. Phys. 115, 9149-9159 (2001).  &quot;A unified scheme for ab initio molecular orbital theory and path integral molecular dynamics''</p>
</div>
<div class="citation" id="shiga00" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id174">Shiga00</a><span class="fn-bracket">]</span></span>
<p>M. Shiga, M. Tachikawa, S. Miura, Chem. Phys. Lett. 332, 396-402 (2000).  &quot;Ab initio molecular orbital calculation considering the quantum mechanical effect of nuclei by path integral molecular dynamics''</p>
</div>
</div>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../analysis/analysis.html" class="btn btn-neutral float-left" title="8. 解析機能" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../uvsor/uvsor.html" class="btn btn-neutral float-right" title="10. 誘電応答解析機能 UVSOR" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, PHASEシステム研究会.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>