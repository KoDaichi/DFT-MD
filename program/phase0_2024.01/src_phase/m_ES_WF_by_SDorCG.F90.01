#ifdef NEC_TIMER
#  define START_TIMER(a) call start_timer(a)
#  define STOP_TIMER(a)  call stop_timer(a)
#else
#  define START_TIMER(a)
#  define STOP_TIMER(a)
#endif
!=======================================================================
!
!  PROGRAM  PHASE/0 2014.03 ($Rev$)
!
!  MODULE:  m_ES_WF_by_SDorCG
!
!  AUTHOR(S): T. Yamasaki   August/20/2003
!
!  FURTHER MODIFICATION: T. Yamasaki, January/13/2004
!
!  Contact address :  Phase System Consortium
!                     E-mail: phase_system@nims.go.jp URL https://azuma.nims.go.jp
!
!
!
!=======================================================================
!
!     The original version of this set of the computer programs "PHASE"
!  was developed by the members of the Theory Group of Joint Research
!  Center for Atom Technology (JRCAT), based in Tsukuba, in the period
!  1993-2001.
!
!     Since 2002, this set has been tuned and new functions have been
!  added to it as a part of the national project "Frontier Simulation
!  Software for Industrial Science (FSIS)",  which is supported by
!  the IT program of the Ministry of Education, Culture, Sports,
!  Science and Technology (MEXT) of Japan.
!     Since 2006, this program set has been developed as a part of the
!  national project "Revolutionary Simulation Software (RSS21)", which
!  is supported by the next-generation IT program of MEXT of Japan.
!   Since 2013, this program set has been further developed centering on PHASE System
!  Consortium.
!   The activity of development of this program set has been supervised by Takahisa Ohno.
!
!
module m_ES_WF_by_SDorCG
!     (m_ESsd or m_ESSD)
! $Id: m_ES_WF_by_SDorCG.F90.01 409 2014-10-27 09:24:52Z jkoga $
! This module evolves wave functions.
! MSD: modified steepest descent algorithm (Original subroutine name was
! "msdv").
! Following lines are comments in the "msdv".
!
!!$C ref.: Williams and Soler, Bull.Am.Phys.Soc.32 ('87),p562.
!!$c
!!$c      revised by T.Yamasaki
!!$c         #1) 2 folding inline expansion at an do loop of NEG is
!!$c            rewrited as before as a simple do loop
!!$c                                               5th May 1994
!!$c         #2) Parallelization                   9th May 1994
!!$c         #3) Parallelization transient
!!$c                         by T.Yamasaki        15th May 1994
!!$c
!!$c         #4)  Following arrays are removed from the arguments.
!!$c                                  ----> 31th May '94 Y.M
!!$cc   >        VXC,CHGQ,PSC,ZFM3,
!!$c                                  ----> 3rd June '94, Y.M.
!!$cc   W        W31,
!!$c                                  ----> 3rd June '94, Y.M.
!!$cc   W        W310,
!!$c
!!$c         #5)  data array size is reduced by T.Yamasaki
!!$c             snlfmc(kng1,klmt),snlfms(kng1,klmt)
!!$c          -->  snlfmc(kng1), snlfms(kng1)       on 17th Jun. 1994
!!$c
!!$c         #6) Data parallelization               on 24th Jun. 1994
!!$c                 eko --> eko_l             by T.Yamasaki
!!$c         #7) indx0 is removed                      26th Jun. 1994
!!$c         #8) Interface has changed                 27th Jun. 1994
!!$c         #9) imsd is added in the argument list     4th Aug. 1994
!!$cc      imsd = 1
!!$cc    for preconditioning IMSD=2   '94.6.14 Tsuyoshi Miyazaki
!!$cc      imsd = 2
!!$c         #10) ivanl is inserted in the arugment list  13th Sep. 1994
!!$c         #11) A do loop of 450 is tuned up.        15th Sep. 1994
!!$c         #12) Spin polarization is introduced.     11th Dec. 1994
!!$c         #13) vlhxc --> vlhxc_l                    31st Jan. 1995
!!$c                                          by T.Yamasaki
!!$c         #14) gx,gy,gz --> ngabc, vx,vy,vz --> vkxyz
!!$c                   by T.Yamasaki                on 15th Feb. 1995
!!$c         #15) antiferromagnetic calculation is added on 9th Jul. 1996
!!$c                                          by H.Sawada
!
! The "msdv" subroutine was translated into a subroutine,
! "evolve_WFs_in_MSD_direction" by T. Yamasaki in 1999.
!
  use m_Control_Parameters,  only : nspin,ipri,iprisolver,kimg,neg,af
  use m_Const_Parameters,    only : DP,SP,DIRECT,ON,SD,MSD,eazyCG,CG,SKIP,EXECUT,zi &
 &                                , ORTHONORMALIZATION, NORMALIZATION, ELECTRON &
 &                                , OTHER_BANDS, SAME_BAND, ALL_BANDS, SCF, OFF, GAMMA
  use m_Crystal_Structure,   only : rltv
  use m_Electronic_Structure,only : zaj_l, afft,bfft &
 &                                , eko_l,vnlph_l,vlhxcQ &
 &                                , vlhxc_l &
!$$#ifndef PARA3D
 &                                , m_ES_WF_in_Rspace &
 &                                , m_ES_sort_eigen_values &
 &                                , m_ES_Vlocal_in_Rspace  &
 &                                , m_ES_eigen_values_for_each_k  &
 &                                , m_ES_wd_zaj_small_portion &
 &                                , m_ES_wd_eko &
 &                                , m_ES_decide_precon_factor     &
!$$#endif
 &                                , m_ES_sum_of_LocalPart,m_ES_sum_of_LocalPart2
!FNS  use m_ES_ortho            ,only : m_ES_MGS_4_each_k                                 &
  use m_ES_ortho            ,only : m_ES_MGS_4_each_k
!$$#ifndef PARA3D
  use m_ES_ortho            ,only : m_ES_orthogonalize_SD_to_WFs
!$$#endif
  use m_ES_nonlocal         ,only : sc,ss,qc                                          &
!$$#ifndef PARA3D
 &                                , m_ES_alloc_afft_scss_etc                          &
!$$#endif
 &                                , m_ES_dealloc_afft_scss_etc
!$$#ifndef PARA3D
  use m_ES_nonlocal         ,only : m_ES_Vnonlocal_W                                  &
 &                                , m_ES_betar_dot_Psi_4_each_k
!$$#endif
!FNS  use m_FFT,                 only : nfft, fft_box_size_WF, m_FFT_Vlocal_W, m_FFT_WF
  use m_FFT,                 only : nfft, fft_box_size_WF
!$$#ifndef PARA3D
  use m_FFT,                 only : m_FFT_Vlocal_W, m_FFT_WF
!$$#endif
  use m_Ionic_System,        only : ntyp, natm, ityp, iwei
  use m_Kpoints,             only : kv3,vkxyz,k_symmetry
  use m_NonLocal_Potential,  only : snl
  use m_Files,               only : nfout
  use m_Parallelization,     only : MPI_CommGroup,is_kngp,ie_kngp,npes,mype &
       &, nrank_e, myrank_e, map_e, ista_e, iend_e, istep_e, map_z, np_e &
       &, nrank_k, myrank_k, map_k, ista_k, iend_k, mpi_k_world, nis_k, nel_k, ierr
!FNS  use m_PlaneWaveBasisSet,   only : kg1,iba, igf, nbase, m_pwBS_kinetic_energies
  use m_PlaneWaveBasisSet,   only : kg1,iba, igf, nbase
!$$#ifndef PARA3D
  use m_PlaneWaveBasisSet,   only : m_pwBS_kinetic_energies
!$$#endif
  use m_PseudoPotential,     only : ilmt, lmtt, ltp, mtp, q, dion, modnrm, nlmta &
       &                           ,m_PP_include_vanderbilt_pot,ipaw,dion_paw
  use m_Timing,              only : tstatc0_begin, tstatc0_end

#ifdef NEC_TIMER
  use nec_timer
#endif
  implicit none
!$$#ifndef PARA3D
  real(kind=DP),private,allocatable,dimension(:,:,:,:):: zaj_old !d(kg1,np_e,ista_k:iend_k,kimg)
!$$#endif
  real(kind=DP),private,allocatable,dimension(:,:,:,:):: wfsd_l  !d(kg1,np_e,ik:ik,kimg)
! ----------- Added by T. Yamasaki, 28 June 2008 -----
  real(kind=DP),private,allocatable,dimension(:,:,:,:):: wfred_l !d(kg1,np_e,ista_k:iend_k,kimg)
  logical, private                                    :: wfred_is_allocated = .false.
! ----------------------------------------------------
!FJFJ  real(kind=DP),private,allocatable,dimension(:,:,:,:):: wfsd_old!d(kg1,np_e,ista_k:iend_k,kimg)
  real(kind=DP),public ,allocatable,dimension(:,:,:,:):: wfsd_old!d(kg1,np_e,ista_k:iend_k,kimg)
  real(kind=DP),private,allocatable,dimension(:,:,:,:):: wfsd_np !d(kg1,np_e,1,kimg)
  real(kind=DP),private,allocatable,dimension(:,:,:)  :: bsdr_l, bsdi_l !d(np_e,nlmta,1)
  real(kind=DP),private,allocatable,dimension(:,:,:)  :: bsdr_np, bsdi_np !d(np_e,nlmta,1)

  real(kind=DP),private,allocatable,dimension(:)          :: dzajn2  !d(kv3)
  real(kind=DP),private                               :: betacg

!   1. m_ESsd_alloc_dzajn2            <-(Initial_Electronic_Structure)
!   2. m_ESsd_dealloc_dzajn2          <-(Finalization_of_mpi)
!   3. m_ESsd_alloc_zaj_old           <-(Initial_Electronic_Structure)
!   4. m_ESsd_evolve_WFs_again        <-(Renewal_of_WaveFunctions) ->(5)
!   5. evolve_each_WF_again           <-(4)
!   6. m_ESsd_decide_CG_direction     <-(Renewal_of_WaveFunctions) ->(7)
!   7. decide_CG_direction_core       <-(6,) ->(16,29)
!   8. m_ESsd_renew_WF_by_SDorCG      <-(Renewal_of_WaveFunctions) ->(9,10,11,12,13,14)
!   9. evolve_WFs_in_MSD_direction    <-(8) ->(15,19)
!  10. evolve_WFs_in_SD_direction     <-(8)
!  11. evolve_WFs_in_eazyCG_direction <-(8) ->(16,17,18,26,28,30,33)
!  12. evolve_WFs_in_CG_direction     <-(8) ->(18,26,28,29)
!  13. evolve_WFs_in_CG_direction0    <-(8) ->(26,27)
!  14. vlhxc_l_zero_term              <-(8)
!  15. modified_steepest_descent      <-(9)
!  16. square_of_SD_direction(ik,ibo,dz) <-(7,11)
!  17. square_of_SD_direction2(ik,ibo,dz) <-(11)
!  18. SD_direction                   <-(11,12)
!  19. Vnonlocal_Diagonal_part        <-(9)
!  20.  - Vnonlocal_D_vanderbilt_case, - Vnonlocal_D_norm_conserve_case
!  21. m_ESsd_reset_dzajn2            <-(Renewal_of_WaveFunctions)
!  22. m_ESsd_copy_zaj_to_zaj_old     <-(Renewal_of_WaveFunctions)
!  23. m_ESsd_copy_zaj_old_to_zaj     <-(m_ES_WF_by_RMM.zajold2zaj_phi2zaj_old)
!  24. m_ESsd_copy_phi_to_zaj_old     <-(m_ES_WF_by_RMM.zajold2zaj_phi2zaj_old)
!  25. m_ESsd_diff_WFs_to_zaj_old     <-(m_ES_WF_by_RMM.m_ESrmm_renew_WF)
!  26. WF_conjugate_gradient          <-(11,12,13)
!  27. WF_conjugate_gradient0         <-(13)
!  28. make_CG_direction              <-(11,12)
!  29. orthogonalize_SD_drctns        <-(7,12)
!  30. Precon_dot_SD                  <-(11)  ->(31)
!  31. decide_precon_factor_wfsd      <-(30)  ->(32)
!  32. kinetic_energy_wfsd            <-(31)
!  33. cp_wfsd_to_wfsd_old            <-(11)

  include 'mpif.h'

contains
  subroutine m_ESsd_alloc_dzajn2
    allocate(dzajn2(ista_k:iend_k)); dzajn2 = 0.d0
  end subroutine m_ESsd_alloc_dzajn2

  subroutine m_ESsd_dealloc_dzajn2
    deallocate(dzajn2)
  end subroutine m_ESsd_dealloc_dzajn2

  subroutine m_ESsd_alloc_zaj_old
    allocate(zaj_old(kg1,np_e,ista_k:iend_k,kimg))
  end subroutine m_ESsd_alloc_zaj_old

  subroutine m_ESsd_alloc_wfsd
    if(.not.allocated(wfsd_old)) then
       allocate(wfsd_old(kg1,np_e,ista_k:iend_k,kimg))
       wfsd_old = 0.d0
    end if
  end subroutine m_ESsd_alloc_wfsd

  subroutine m_ESsd_dealloc_wfsd
    if(allocated(wfsd_old)) deallocate(wfsd_old)
  end subroutine m_ESsd_dealloc_wfsd

! -------------------- Added by T. Yamasaki, 28 June 2008 --->>
  subroutine m_ESsd_alloc_wfred()
    allocate(wfred_l(kg1,np_e,ista_k:iend_k,kimg)); wfred_l = 0.d0
    wfred_is_allocated = .true.
  end subroutine m_ESsd_alloc_wfred

  subroutine m_ESsd_dealloc_wfred()
    deallocate(wfred_l)
    wfred_is_allocated = .false.
  end subroutine m_ESsd_dealloc_wfred

!$$#ifndef PARA3D
  subroutine cp_wfred(ik)
    integer, intent(in) :: ik
    integer :: ir, ib, ig
    do ir = 1, kimg
       do ib = 1, np_e
          do ig = 1, iba(ik)
             wfred_l(ig,ib,ik,ir) = zaj_l(ig,ib,ik,ir) - zaj_old(ig,ib,ik,ir)
          end do
       end do
    end do
  end subroutine cp_wfred
!$$#endif
! ----------------------------------<<

!$$#ifndef PARA3D
  subroutine alloc_wfsd_bsdri(ik)
    integer, intent(in) :: ik
    allocate(wfsd_l(kg1,np_e,ik:ik,kimg)); wfsd_l = 0.d0
    allocate(bsdr_l(np_e,nlmta,ik:ik))
    allocate(bsdi_l(np_e,nlmta,ik:ik)); bsdi_l = 0.0d0
!!$    write(nfout,'(" -- bsdr_l, bsdi_l have been allocated --  np_e, nlmta, ik = ",3i5)') np_e,nlmta,ik
  end subroutine alloc_wfsd_bsdri
!$$#endif

!$$#ifndef PARA3D
  subroutine dealloc_wfsd_bsdri()
    deallocate(wfsd_l)
    deallocate(bsdr_l)
    deallocate(bsdi_l)
  end subroutine dealloc_wfsd_bsdri
!$$#endif

  subroutine alloc_wfsdnp_bsdrinp(ik)
    integer, intent(in) :: ik
    allocate(wfsd_np(kg1,np_e,ik:ik,kimg))
    allocate(bsdr_np(np_e,nlmta,ik:ik))
    allocate(bsdi_np(np_e,nlmta,ik:ik))
  end subroutine alloc_wfsdnp_bsdrinp

  subroutine dealloc_wfsdnp_bsdrinp()
    deallocate(wfsd_np)
    deallocate(bsdr_np)
    deallocate(bsdi_np)
  end subroutine dealloc_wfsdnp_bsdrinp

  subroutine m_ESsd_dealloc_zaj_old
    if(allocated(zaj_old)) deallocate(zaj_old)
!!$    deallocate(wfsd_l)
!!$    deallocate(wfsd_np)
!!$    deallocate(bsdr_l)
!!$    deallocate(bsdi_l)
!!$    deallocate(bsdr_np)
!!$    deallocate(bsdi_np)
  end subroutine m_ESsd_dealloc_zaj_old

  subroutine m_ESsd_evolve_WFs_again(nfout,isolver2,mode,dtim_old,dtim_new)
#ifdef __TIMER__
    use m_Const_Parameters,   only : VDB
    use m_ES_ortho,           only : mgs_4_each_k_G_3D
#endif
    integer,       intent(in) :: nfout,isolver2 &
         &                     , mode   ! mode = {ORTHONORMALIZATION | NORMALIZATION}
    real(kind=DP), intent(in) :: dtim_old, dtim_new
    integer       :: ispin, ik, iksnl
    real(kind=DP), pointer, dimension(:) :: ekin
#ifdef __TIMER__
    integer       :: ierr
#endif

!$$#ifndef PARA3D
    call m_ES_alloc_afft_scss_etc()
    ekin => sc(1:kg1)
!$$#endif

!$$#ifndef PARA3D

    do ispin = 1, nspin, af+1
       call m_ES_Vlocal_in_Rspace(ispin,afft)                 ! (ptfft1)
       do ik = ispin, kv3-nspin+ispin, nspin
          if(map_k(ik) == myrank_k ) then                     ! MPI
             call m_pwBS_kinetic_energies(ik,vkxyz,ekin) !-(PWBS) (diakin) ->ekin
             call evolve_each_WF_again(ik,isolver2,dtim_new,dtim_old)  !-(m_ES_WF_by_SDorCG)
!!$             if(modnrm == EXECUT) call m_ES_betar_dot_WFs_4_each_k(nfout,ik)       ! -> fsr_l, fsi_l
             call m_ES_MGS_4_each_k(nfout,ik,mode)
             call m_ES_eigen_values_for_each_k(ispin,ik,ekin,afft)
          end if
       end do
    end do
 #ifdef LMM_PREVIOUS
    call m_ES_sort_eigen_values    !-(m_Elec.)
 ! --> T. Yamasaki, 21th Jul. 2009
 !!$    call m_ES_sort_eigen_values    !-(m_Elec.)
 ! <--
 #endif
!$$#endif

    call m_ES_dealloc_afft_scss_etc()

  end subroutine m_ESsd_evolve_WFs_again

!$$#ifndef PARA3D
  subroutine evolve_each_WF_again(ik,isolver2,dt_new,dt_old)
    integer,       intent(in) :: ik,isolver2
    real(kind=DP), intent(in) :: dt_new,dt_old
    integer ::        ir, ib, ig
    real(kind=DP) ::  dtt
    integer   :: id_sname = -1
    call tstatc0_begin('evolve_each_WF_again ', id_sname,1)

!!$    if(isolver2 == CG .or. isolver2 == eazyCG) then
    if(isolver2 == eazyCG) then
       do ir = 1, kimg
          do ib = 1, np_e
             do ig = 1, iba(ik)
                zaj_l(ig,ib,ik,ir) = zaj_old(ig,ib,ik,ir) + dt_new*wfsd_l(ig,ib,ik,ir)
             end do
          end do
       end do
    else
       dtt = dt_new/dt_old
!!$       if(ipri >= 3) write(nfout,'(" dtt = ",f8.4)') dtt
! ------------------- Revised by T. Yamasaki,  31 Oct 2008 --->>
       if(wfred_is_allocated) then
          do ir = 1, kimg
             do ib = 1, np_e
                do ig = 1, iba(ik)
! ------------------- Revised by T. Yamasaki,  03 July 2008 --->>
                   zaj_l(ig,ib,ik,ir) = zaj_old(ig,ib,ik,ir) + dtt*wfred_l(ig,ib,ik,ir)
! ------------------------------------<<
                end do
             end do
          end do
       else if(.not.wfred_is_allocated) then
          do ir = 1, kimg
             do ib = 1, np_e
                do ig = 1, iba(ik)
                   zaj_l(ig,ib,ik,ir) = (1-dtt)*zaj_old(ig,ib,ik,ir) + dtt*zaj_l(ig,ib,ik,ir)
                end do
             end do
          end do
       end if
! <----------------
    end if
!!$    do ir = 1, kimg
!!$       do ib = 1, np_e                         ! MPI
!!$          do i = 1, iba(ik)
!!$             dzz = zaj_l(i,ib,ik,ir) - zaj_old(i,ib,ik,ir)
!!$             zaj_l(i,ib,ik,ir) = zaj_old(i,ib,ik,ir) + dtt*dzz
!!$          end do
!!$       end do
!!$    end do
    call tstatc0_end(id_sname)
  end subroutine evolve_each_WF_again
!$$#endif

  subroutine m_ESsd_decide_CG_direction(precon)
    integer, intent(in) :: precon

    integer ispin, iksnl, ik
    real(kind=DP), parameter             :: Delta = 1.d-10
    real(kind=DP), pointer, dimension(:) :: ekin, p
    real(kind=DP)                        :: gmgm, gmmgmm, sumdz2, x
!$$#ifndef PARA3D
    call m_ES_alloc_afft_scss_etc()
    ekin => sc(1:kg1); p => ss(1:kg1)
!$$#endif
    gmgm = 0.d0; gmmgmm = 0.d0

    do ispin = 1, nspin, (af+1)
!$$#ifndef PARA3D
       call m_ES_Vlocal_in_Rspace(ispin,afft)      ! (ptfft1) -> afft
!$$#endif
       do ik = ispin, kv3-nspin+ispin, nspin
!$$#ifndef PARA3D
          if(map_k(ik) == myrank_k) then           ! MPI
             iksnl = (ik-1)/nspin + 1
             call m_ES_Vnonlocal_W(ik,iksnl,ispin,ON)    ! (nonloc) ->(vnlph_l)
             call m_pwBS_kinetic_energies(ik,vkxyz,ekin) ! -(m_PWBS) (diakin) ->ekin
             call decide_CG_direction_core &     ! -(m_ES_WF_by_SDorCG) ->wfsd_l
                  &(precon,ik,ekin,afft,bfft,p,sumdz2)
             gmgm   = gmgm + sumdz2
             gmmgmm = gmmgmm + dzajn2(ik)
             dzajn2(ik) = sumdz2
             if(ipri >= 2) write(nfout,'(" dzajn2(",i3,") = ",d20.8)') ik,dzajn2(ik)
             call dealloc_wfsd_bsdri()
!$$#endif
          end if
       enddo
    enddo

    if(npes > 1) then
       call mpi_allreduce(gmgm,x,1,mpi_double_precision,mpi_sum,MPI_CommGroup,ierr)    ! MPI
       gmgm = x
       call mpi_allreduce(gmmgmm,x,1,mpi_double_precision,mpi_sum,MPI_CommGroup,ierr)    ! MPI
       gmmgmm = x
    end if

    if(gmmgmm > Delta) then
       betacg = gmgm/gmmgmm
    else
       betacg = 0.d0
    endif
    if(ipri >= 1) write(nfout,'(" ! betacg = ",d20.8," gmgm = ",d20.8," gmmgmm = ",d20.8)') betacg,gmgm,gmmgmm
    if(betacg > 1.d0) then
       betacg = 0.d0
       if(ipri >= 1) write(nfout,*) ' beta for CG is too large, and it sets to be zero'
    else if(betacg < 0.d0) then
       betacg = 0.d0
       if(ipri >= 1) write(nfout,*) ' beta for CG is less than zero, and it sets to be zero'
    end if

    call m_ES_dealloc_afft_scss_etc()
!!$  contains
!!$    subroutine bcast_dzajn2                     ! MPI
!!$      integer       :: i
!!$
!!$      do i = 0, nrank_k-1
!!$         call mpi_bcast(dzajn2(nis_k(i)),nel_k(i),mpi_double_precision &
!!$              & ,i*nrank_e,MPI_CommGroup,ierr)
!!$      end do
!!$    end subroutine bcast_dzajn2
  end subroutine m_ESsd_decide_CG_direction

!$$#ifndef PARA3D
  subroutine decide_CG_direction_core(precon,ik,ekin,afft,bfft,p,sumdz2)
    integer, intent(in)        :: precon, ik
    real(kind=DP), intent(in)  :: ekin(kg1)
    real(kind=DP), intent(in)  :: afft(nfft)
    real(kind=DP), intent(out) :: bfft(nfft)
    real(kind=DP)              :: p(kg1)
    real(kind=DP), intent(out) :: sumdz2

    integer :: ib
    integer :: id_sname = -1
    call tstatc0_begin('decide_CG_direction_core ', id_sname,1)

    do ib = ista_e, iend_e, istep_e      ! MPI
       call m_ES_WF_in_Rspace(ik,ib,bfft)! (swffft)
       call m_FFT_Vlocal_W(afft,bfft)    ! (afft, bfft) -> (bfft)
       call m_FFT_WF(ELECTRON,nfout,bfft,DIRECT,ON) ! bfft: G-space repres.
       call SD_direction(precon,ik,ib,ekin,bfft,p) !-(m_ES_WF_by_SDorCG)
    end do

    call orthogonalize_SD_drctns(ik,to=OTHER_BANDS)  ! -(m_ES_WF_by_SDorCG) ->(wfsd_l, bsd(ri)_l)

    call WFSD_dot_WFSD                   ! -(contained here)
    !    ~~~~~~~~~~~~~
    call tstatc0_end(id_sname)
  contains
    subroutine WFSD_dot_WFSD
      real(kind=DP) :: sum_mpi   ! MPI
      real(kind=DP) :: dz
      integer :: ib

      sumdz2 = 0.d0
      do ib = ista_e, iend_e, istep_e      ! MPI
         call square_of_SD_direction(ik,ib,dz)
!!$         write(nfout,'(" dz = ",d20.8)') dz
         sumdz2 = sumdz2 + dz
      end do
!!$      write(nfout,'(" sumdz2 = ",d20.8)') sumdz2
      if(npes > 1) then
         call mpi_allreduce(sumdz2,sum_mpi,1,mpi_double_precision &
              & ,mpi_sum,mpi_k_world(myrank_k),ierr)    ! MPI
         sumdz2 = sum_mpi                               ! MPI
      end if
    end subroutine WFSD_dot_WFSD
  end subroutine decide_CG_direction_core
!$$#endif

  subroutine m_ESsd_renew_WF_by_SDorCG(nfout,isolver,precon,dtim)
#ifdef __TIMER__
    use m_Const_Parameters,   only : VDB
    use m_ES_ortho,           only : mgs_4_each_k_G_3D
#endif
    integer, intent(in) :: nfout,isolver, precon
    real(kind=DP)       :: dtim

    integer                              :: ispin, iksnl, ik, mode, ipri0
    real(kind=DP), pointer, dimension(:) :: ekin, p, vnldi
    real(kind=DP)                        :: vlhxc0

!$$#ifndef PARA3D
    call m_ES_alloc_afft_scss_etc()
    ekin => sc(1:kg1); p => ss(1:kg1); vnldi => qc(1:kg1)
!$$#endif

    mode = ORTHONORMALIZATION

    if(iprisolver >= 2) then
       if(isolver == SD) then
          write(nfout,'(" !! isolver_core = SD")')
       else if(isolver == MSD) then
          write(nfout,'(" !! isolver_core = MSD")')
       else if(isolver == CG) then
          write(nfout,'(" !! isolver_core = CG")')
       end if
    end if

!$$#ifndef PARA3D
    do ispin = 1, nspin, (af+1)
       if(isolver == MSD) call vlhxc_l_zero_term(vlhxc0,ispin) ! -(m_ES_WF_by_SDorCG) ->vlhxc0
       call m_ES_Vlocal_in_Rspace(ispin,afft)      ! (ptfft1) vlhxc_l->afft
       do ik = ispin, kv3-nspin+ispin, nspin
          if(map_k(ik) == myrank_k) then           ! MPI
             iksnl = (ik-1)/nspin + 1
             call m_ES_Vnonlocal_W(ik,iksnl,ispin,ON)    ! (nonloc) ->(vnlph_l)
             call m_pwBS_kinetic_energies(ik,vkxyz,ekin) ! (diakin) ->ekin
             if(isolver == SD) then
                call evolve_WFs_in_SD_direction&      ! -(m_ES_WF_by_SDorCG)
                     &(precon,ik,dtim,ekin, afft,bfft,p)
             else if(isolver == MSD ) then
                call evolve_WFs_in_MSD_direction&     !-(m_ES_WF_by_SDorCG)
                     &(precon,ik,iksnl,ispin,dtim,ekin, afft,bfft,p,vnldi,vlhxc0)
                if(ipri>=3.and.ik==1) &
                     & call m_ES_wd_zaj_small_portion(nfout,ik," -- after MSD --",16)
             else if(isolver == eazyCG) then
                call evolve_WFs_in_eazyCG_direction(precon,ik,dtim,ekin,afft,bfft,p)
             else if(isolver == CG) then
                call evolve_WFs_in_CG_direction(precon,ik,dtim,ekin,afft,bfft,p)
!!$                call evolve_WFs_in_CG_direction0(precon,ik,dtim,ekin,afft,bfft,p)
             endif
!!$             if(modnrm == EXECUT) call m_ES_betar_dot_WFs_4_each_k(nfout,ik) !-> fsr_l,fsi_l
! --------------- Added by T. Yamasaki, 28 June 2008 ---
             if(wfred_is_allocated) call cp_wfred(ik)
! ------------------------------------------------------<<
             call m_ES_MGS_4_each_k(nfout,ik,mode)
             call m_ES_eigen_values_for_each_k(ispin,ik,ekin,afft)
          end if
       enddo
    enddo

!!$    if(nspin == 2 .and. sw_so == ON) then
!!$       do ik = 1, kv3, nspin

 #ifdef LMM_PREVIOUS
    call m_ES_sort_eigen_values()   ! -> neordr, nrvf_ordr
! --> T. Yamasaki, 21th Jul. 2009
!!$    call m_ES_sort_eigen_values()   ! -> neordr, nrvf_ordr
! <--
 #endif

!$$#endif
    call get_ipri0(ipri, ipri0)
!$$#ifndef PARA3D
    if(ipri0 >= 2) call m_ES_wd_eko(nfout,mode=SCF)
!$$#endif
    call m_ES_dealloc_afft_scss_etc()

  contains
    subroutine get_ipri0(ipri_in, ipri_out)
      integer, intent(in)  :: ipri_in
      integer, intent(out) :: ipri_out
      if(npes > 1) then
         if(mype == 0) ipri_out = ipri_in
         call mpi_bcast(ipri_out,1,mpi_integer,0,MPI_CommGroup,ierr)
      else
         ipri_out = ipri_in
      end if
    end subroutine get_ipri0
  end subroutine m_ESsd_renew_WF_by_SDorCG

!$$#ifndef PARA3D
  subroutine evolve_WFs_in_MSD_direction&
       &(precon,ik,iksnl,ispin,dtim,ekin,afft,bfft,p,vnldi,vlhxc0)
    integer, intent(in)        :: precon, ik, iksnl, ispin
    real(kind=DP), intent(in)  :: dtim,ekin(kg1)
    real(kind=DP), intent(in)  :: afft(nfft)
    real(kind=DP), intent(out) :: bfft(nfft)
    real(kind=DP)              :: p(kg1), vnldi(kg1)
    real(kind=DP), intent(in)  :: vlhxc0

    integer ib, ig
    integer :: id_sname = -1
    call tstatc0_begin('evolve_WFs_in_MSD_direction ', id_sname,1)

#ifdef NEC_TUNE_SMP
!CDIR PARALLEL DO private(bfft,vnldi,p)
#endif
    do ib = ista_e, iend_e, istep_e      ! MPI
       call m_ES_WF_in_Rspace(ik,ib,bfft)! (swffft)

       if(ipri >= 2) then
          write(nfout,'(" --- afft and bfft <<evolve_WFs_in_MSD_direction>>,  ib = ",i5)') ib
          write(nfout,'(" afft: ",5d16.8)') (afft(ig),ig=1,min(5,nfft))
          write(nfout,'(" bfft: ",5d16.8)') (bfft(ig),ig=1,min(5,nfft))
       end if

       call m_FFT_Vlocal_W(afft,bfft)    ! (afft, bfft)-> (bfft)
       call m_FFT_WF(ELECTRON,nfout,bfft,DIRECT,ON)
       call Vnonlocal_Diagonal_part(ispin,ik,iksnl,ib,vnldi)
                                         ! -(m_ES_WF_by_SDorCG) (nonldj)
       if(ipri >= 2) then
          write(nfout,'(" --- vnlph_l <<evolve_WFs_in_MSD_direction>>,  ib = ",i5)') ib
                       write(nfout,'(" vnlph_l: Re ",5d16.8)') (vnlph_l(ig,ib,1),ig=1,min(5,iba(ik)))
          if(kimg== 2) write(nfout,'(" vnlph_l: Im ",5d16.8)') (vnlph_l(ig,ib,2),ig=1,min(5,iba(ik)))

          write(nfout,'(" vnldi ",5d16.8)') (vnldi(ig),ig=1,min(5,iba(ik)))
          write(nfout,'(" VlocalW: Re ",5d16.8)') (bfft(2*igf(nbase(ig,ik))-1),ig=1,min(5,iba(ik)))
          write(nfout,'(" VlocalW: Im ",5d16.8)') (bfft(2*igf(nbase(ig,ik))),ig=1,min(5,iba(ik)))
          write(nfout,'(" vlhxc0 = ",5d16.8)') vlhxc0
       end if
       call modified_steepest_descent&   ! -(m_ES_WF_by_SDorCG)
            &(precon,ik,ib,dtim,vnldi,vlhxc0,ekin,bfft,p)
    end do
    call tstatc0_end(id_sname)
  end subroutine evolve_WFs_in_MSD_direction
!$$#endif

!$$#ifndef PARA3D
  subroutine evolve_WFs_in_SD_direction&
       &(precon,ik,dtim,ekin,afft,bfft,p)
    integer, intent(in)        :: precon, ik
    real(kind=DP), intent(in)  :: dtim,ekin(kg1)
    real(kind=DP), intent(in)  :: afft(nfft)
    real(kind=DP), intent(out) :: bfft(nfft)
    real(kind=DP)              :: p(kg1)

    integer :: ib
    integer :: id_sname = -1
    call tstatc0_begin('evolve_WFs_in_SD_direction ', id_sname,1)

    do ib = ista_e, iend_e, istep_e      ! MPI
       call m_ES_WF_in_Rspace(ik,ib,bfft)! (swffft)
       call m_FFT_Vlocal_W(afft,bfft)    ! (afft, bfft)-> (bfft)
       call m_FFT_WF(ELECTRON,nfout,bfft,DIRECT,ON)
       call steepest_descent(precon,ik,ib,dtim,ekin,bfft,p)
                                         ! -(m_ES_WF_by_SDorCG)
    end do
    call tstatc0_end(id_sname)
  end subroutine evolve_WFs_in_SD_direction
!$$#endif

!$$#ifndef PARA3D
  subroutine evolve_WFs_in_eazyCG_direction(precon,ik,dtim,ekin,afft,bfft,p)
    integer, intent(in)        :: precon, ik
    real(kind=DP), intent(in)  :: dtim,ekin(kg1)
    real(kind=DP), intent(in)  :: afft(nfft)
    real(kind=DP), intent(out) :: bfft(nfft)
    real(kind=DP)              :: p(kg1)

    real(kind=DP), parameter   :: Delta = 1.d-10
!!$    real(kind=DP)   :: dz, sumdz2
    integer :: ib
    integer :: id_sname = -1
    call tstatc0_begin('evolve_WFs_in_eazyCG_direction ', id_sname,1)

    if(modnrm == EXECUT) call alloc_wfsd_bsdri(ik)
    if(modnrm == EXECUT .and. precon == ON) call alloc_wfsdnp_bsdrinp(ik)

    do ib = ista_e, iend_e, istep_e      ! MPI
       call m_ES_WF_in_Rspace(ik,ib,bfft)! (swffft)
       call m_FFT_Vlocal_W(afft,bfft)    ! (afft, bfft) -> (bfft)
       call m_FFT_WF(ELECTRON,nfout,bfft,DIRECT,ON) ! bfft: G-space repres.
       call SD_direction(precon,ik,ib,ekin,bfft,p)! -(m_ES_WF_by_SDorCG) zaj_l, etc -> wfsd_l
       !    ~~~~~~~~~~~~
    end do

!!$    call orthogonalize_SD_drctns(ik,to=OTHER_BANDS)   ! -(m_ES_WF_by_SDorCG) ->wfsd_l
    if(precon == ON) call Precon_dot_SD(ik,ekin,p)  ! -(m_ES_WF_by_SDorCG) -> wfsd_np, wfsd_l
!!$    call orthogonalize_SD_drctns(ik,to=ALL_BANDS)     ! -(m_ES_WF_by_SDorCG) ->wfsd_l
    !                                      wfsd_l is orthogonalized to zaj_l's
    if(modnrm == EXECUT) call m_ES_betar_dot_Psi_4_each_k(wfsd_l,ik,ik,ik,bsdr_l,bsdi_l)
    if(modnrm == EXECUT .and. precon == ON ) then
       write(6,'(" m_ES_betar_dot_Psi_4_each_k is being called (evolve_WFs_in_eazyCG_direction)")')
       call m_ES_betar_dot_Psi_4_each_k(wfsd_np,ik,ik,ik,bsdr_np,bsdi_np)
    end if
    call get_betacg                      ! -(contained here) wfsd_l ->betacg, dzajn2
    !    ~~~~~~~~~~
!!$    do ib = ista_e, iend_e, istep_e      ! MPI
!!$       call m_ES_WF_in_Rspace(ik,ib,bfft)! (swffft)
!!$       call m_FFT_Vlocal_W(afft,bfft)    ! (afft, bfft) -> (bfft)
!!$       call m_FFT_WF(ELECTRON,nfout,bfft,DIRECT,ON) ! bfft: G-space repres.
!!$       call SD_direction(precon,ik,ib,ekin,bfft,p)! -(m_ES_WF_by_SDorCG) zaj_l, etc -> wfsd_l
!!$       !    ~~~~~~~~~~~~
!!$    end do
!!$
!!$    sumdz2 = 0.d0
!!$    do ib = ista_e, iend_e, istep_e      ! MPI
!!$       call square_of_SD_direction(ik,ib,dz)  ! wfsd_l dot wfsd_l
!!$       write(nfout,'(" dz = ",d20.8)') dz
!!$       sumdz2 = sumdz2 + dz
!!$    end do

    call make_CG_direction(ik)
!!$    write(6,'(" -- before orthonormalization -- ")')
!!$    call check_of_orthonormality(ik)  ! z = <wfsd_l(i)|zaj_l(j)>
!!$    call orthogonalize_SD_drctns(ik,to=OTHER_BANDS)     ! -(m_ES_WF_by_SDorCG) ->wfsd_l
    call cp_wfsd_to_wfsd_old(ik)                        ! -(m_ES_WF_by_SDorCG) wfsd_l ->wfsd_old
!!$    write(6,'(" -- after orthonormalization -- ")')
!!$    call check_of_orthonormality(ik)  ! z = <wfsd_l(i)|zaj_l(j)>

!!$    write(6,'(" -- before evolution -- ")')
!!$    call check_of_orthonormality2(ik)  ! <zaj_l(i)|zaj_l(j)>
    do ib = ista_e, iend_e, istep_e      ! MPI
       call WF_conjugate_gradient(ik,ib,dtim) !-(m_ES_WF_by_SDorCG)
    end do
!!$    write(6,'(" -- after evolution -- ")')
!!$    call check_of_orthonormality2(ik)  ! <zaj_l(i)|zaj_l(j)>

!!$    do ib = ista_e, iend_e, istep_e      ! MPI
!!$       call m_ES_WF_in_Rspace(ik,ib,bfft)! (swffft)
!!$       call m_FFT_Vlocal_W(afft,bfft)    ! (afft, bfft) -> (bfft)
!!$       call m_FFT_WF(ELECTRON,nfout,bfft,DIRECT,ON)
!!$       call WF_conjugate_gradient0(precon,ik,ib,dtim,ekin,bfft,p)
!!$       !    ~~~~~~~~~~~~~~~~~~~~~~         -(m_ES_WF_by_SDorCG)
!!$    end do
    if(modnrm == EXECUT) call dealloc_wfsd_bsdri()
    if(modnrm == EXECUT .and. precon == ON) call dealloc_wfsdnp_bsdrinp()
    call tstatc0_end(id_sname)
  contains
    subroutine get_betacg
      real(kind=DP) :: sumdz2, dz, avbetacg, betacg_min, betacg_max, avnewbetacg
      real(kind=DP) :: d_mpi   ! MPI
      integer       :: ib

      if(ik == ista_k) then                ! MPI
         betacg_min = 1.d+10; betacg_max = -1.d+10; avbetacg = 0.d0
         avnewbetacg = 0.d0
      end if

      sumdz2 = 0.d0
      do ib = ista_e, iend_e, istep_e      ! MPI
         if(ipri >=1 ) write(6,'(" !! square_of_SD_direction(2?) is being called (evolve_WFs_in_eazyCG_direction.betacg)")')
         if(Precon == ON) then
            call square_of_SD_direction2(ik,ib,dz)
         else
            call square_of_SD_direction(ik,ib,dz)
         end if
         sumdz2 = sumdz2 + dz
      end do
      if(npes > 1) then
         call mpi_allreduce(sumdz2,d_mpi,1,mpi_double_precision,mpi_sum &
              &,mpi_k_world(myrank_k),ierr)                   ! MPI
         sumdz2 = d_mpi                                       ! MPI
      end if

      if(dabs(dzajn2(ik)) > Delta) then
         betacg = sumdz2/dzajn2(ik)
      else
         betacg = 0.d0
      endif
      dzajn2(ik) = sumdz2

      if(ipri >= 1) write(nfout,'(" ik = ",i5," sumdz2 = ", d20.8, " betacg = ",d20.8)') ik,sumdz2,betacg
      if(betacg_min > betacg) betacg_min = betacg
      if(betacg_max < betacg) betacg_max = betacg
      avbetacg = avbetacg + betacg/kv3

      if(betacg > 1.d0) betacg = 1.d0
      if(betacg < 0.d0) betacg = 0.d0

      if(kv3 > 1 .and. ik == iend_k) then              ! MPI
         avnewbetacg = avnewbetacg + betacg/kv3
         if(ipri >= 1) write(nfout, '(" ! average of betacg = ",2f10.6," range ",f10.6,"-" &
              &,       f10.6)') avbetacg, avnewbetacg, betacg_min, betacg_max
      end if
    end subroutine get_betacg

    subroutine check_of_orthonormality(ik)
      integer, intent(in) :: ik
      integer             :: i, j, ig
      real(kind=DP)       :: wz

      if(k_symmetry(ik) == GAMMA) then
         do j = ista_e, iend_e, istep_e
            do i = ista_e, iend_e, istep_e
               wz = 0.d0
               do ig = 2, iba(ik)
                  wz = wz + wfsd_l(ig,i,ik,1)*zaj_l(ig,j,ik,1)
               end do
               wz = wz*2.d0 + wfsd_l(1,i,ik,1)*zaj_l(1,j,ik,1)
               if(ipri >= 1) write(6,'(" (i,j) = ",2i5, " wz = ",d20.8)') i,j, wz
            end do
         end do
      else
         do j = ista_e, iend_e, istep_e
            do i = ista_e, iend_e, istep_e
               wz = 0.d0
               do ig = 1, iba(ik)
                  wz = wz + wfsd_l(ig,i,ik,1)*zaj_l(ig,j,ik,1)
               end do
               if(ipri >= 1) write(6,'(" (i,j) = ",2i5, " wz = ",d20.8)') i,j, wz
            end do
         end do
      end if
    end subroutine check_of_orthonormality

    subroutine check_of_orthonormality2(ik)
      integer, intent(in) :: ik
      integer             :: i, j, ig
      real(kind=DP)       :: wz

      if(k_symmetry(ik) == GAMMA) then
         do j = ista_e, iend_e, istep_e
            do i = ista_e, iend_e, istep_e
               wz = 0.d0
               do ig = 2, iba(ik)
                  wz = wz + zaj_l(ig,i,ik,1)*zaj_l(ig,j,ik,1)
               end do
               wz = wz*2.d0 + zaj_l(1,i,ik,1)*zaj_l(1,j,ik,1)
               if(ipri >=1 ) write(6,'(" (i,j) = ",2i5, " zz = ",d20.8)') i,j, wz
            end do
         end do
      else
         do j = ista_e, iend_e, istep_e
            do i = ista_e, iend_e, istep_e
               wz = 0.d0
               do ig = 1, iba(ik)
                  wz = wz + zaj_l(ig,i,ik,1)*zaj_l(ig,j,ik,1)
               end do
               wz = wz*2.d0
               if(ipri >=1 ) write(6,'(" (i,j) = ",2i5, " zz = ",d20.8)') i,j, wz
            end do
         end do
      end if
    end subroutine check_of_orthonormality2
  end subroutine evolve_WFs_in_eazyCG_direction
!$$#endif

!$$#ifndef PARA3D
  subroutine evolve_WFs_in_CG_direction(precon,ik,dtim,ekin,afft,bfft,p)
    integer, intent(in)        :: precon, ik
    real(kind=DP), intent(in)  :: dtim,ekin(kg1)
    real(kind=DP), intent(in)  :: afft(nfft)
    real(kind=DP), intent(out) :: bfft(nfft)
    real(kind=DP)              :: p(kg1)

    integer :: ib
    integer :: id_sname = -1
    call tstatc0_begin('evolve_WFs_in_CG_direction ', id_sname,1)

    call alloc_wfsd_bsdri(ik)

    do ib = ista_e, iend_e, istep_e      ! MPI
       call m_ES_WF_in_Rspace(ik,ib,bfft)! (swffft)
       call m_FFT_Vlocal_W(afft,bfft)    ! (afft, bfft) -> (bfft)
       call m_FFT_WF(ELECTRON,nfout,bfft,DIRECT,ON) ! bfft: G-space repres.
       call SD_direction(precon,ik,ib,ekin,bfft,p)     ! -(m_ES_WF_by_SDorCG) -> wfsd_l
       !                wfsd_l : -(H-e_{k\mu}^m)\Psi_{k\mu}^m
    end do

    call orthogonalize_SD_drctns(ik,to=SAME_BAND) ! -(m_ES_WF_by_SDorCG) ->(wfsd_l,bsd(ri)_l)
    call make_CG_direction(ik)       ! -(m_ES_WF_by_SDorCG) -> wfsd_l + betacg*wfsd_old -> wfsd_l
!!$    call orthogonalize_SD_drctns(ik,to=SAME_BAND) ! Actually, CG direction ->(wfsd_l,bsd(ri)_l)

    do ib = ista_e, iend_e, istep_e           ! MPI
       call WF_conjugate_gradient(ik,ib,dtim) !-(m_ES_WF_by_SDorCG)
    end do

!!$    do ib = ista_e, iend_e, istep_e      ! MPI
!!$       call m_ES_WF_in_Rspace(ik,ib,bfft)! (swffft)
!!$       call m_FFT_Vlocal_W(afft,bfft)    ! (afft, bfft) -> (bfft)
!!$       call m_FFT_WF(ELECTRON,nfout,bfft,DIRECT,ON)
!!$       call WF_conjugate_gradient0(precon,ik,ib,dtim,ekin,bfft,p)
!!$       !    ~~~~~~~~~~~~~~~~~~~~~~         -(m_ES_WF_by_SDorCG)
!!$    end do

    call cp_wfsd_to_wfsd_old(ik)    ! -(m_ES_WF_by_SDorCG) wfsd_l ->wfsd_old

    call dealloc_wfsd_bsdri()
    call tstatc0_end(id_sname)
  end subroutine evolve_WFs_in_CG_direction
!$$#endif

!$$#ifndef PARA3D
  subroutine evolve_WFs_in_CG_direction0 &
       &(precon,ik,dtim,ekin,afft,bfft,p)
    integer, intent(in)        :: precon, ik
    real(kind=DP), intent(in)  :: dtim,ekin(kg1)
    real(kind=DP), intent(in)  :: afft(nfft)
    real(kind=DP), intent(out) :: bfft(nfft)
    real(kind=DP)              :: p(kg1)

    integer :: ib
    integer :: id_sname = -1
    call tstatc0_begin('evolve_WFs_in_CG_direction0 ', id_sname,1)

    do ib = ista_e, iend_e, istep_e      ! MPI
       call m_ES_WF_in_Rspace(ik,ib,bfft)! (swffft)
       call m_FFT_Vlocal_W(afft,bfft)    ! (afft, bfft) -> (bfft)
       call m_FFT_WF(ELECTRON,nfout,bfft,DIRECT,ON)
       call WF_conjugate_gradient0(precon,ik,ib,dtim,ekin,bfft,p) !-(m_ES_WF_by_SDorCG)
    end do
    call tstatc0_end(id_sname)
  end subroutine evolve_WFs_in_CG_direction0
!$$#endif

!$$#ifndef PARA3D
  subroutine vlhxc_l_zero_term(vlhxc0,ispin)
    real(kind=DP), intent(out) :: vlhxc0
    integer, intent(in)        :: ispin

    if(mype == 0) vlhxc0 = vlhxc_l(1,1,ispin)
    call mpi_bcast(vlhxc0,1,mpi_double_precision,0,MPI_CommGroup,ierr)
  end subroutine vlhxc_l_zero_term
!$$#endif

!$$#ifndef PARA3D
  subroutine modified_steepest_descent&
       &(precon,ik,ibo,dtim,vnldi,vlhxc0,ekin,VlocalW,p)
    integer      , intent(in)                  :: precon,ik,ibo
    real(kind=DP), intent(in)                  :: dtim
    real(kind=DP), intent(in), dimension(kg1)  :: vnldi
    real(kind=DP), intent(in)                  :: vlhxc0
    real(kind=DP), intent(in), dimension(kg1)  :: ekin
    real(kind=DP), intent(in), dimension(nfft) :: VlocalW
    real(kind=DP)            , dimension(kg1)  :: p

    integer       :: i, i1, ib
    real(kind=DP) :: evr,devr,denom, wdi, evi,e1, devi, fdexp
!!$    integer :: id_sname = -1
!!$    call tstatc0_begin('modified_steepest_descent ', id_sname)

    ib = map_z(ibo)                            ! MPI
    denom = 1.d0/product(fft_box_size_WF(1:3,1))
    call m_ES_decide_precon_factor(precon,ik,ibo,ekin,p)  ! -> p(1:iba(ik))
    if(ipri >= 3) then
       write(nfout,'(" ekin : ",5d16.8)') (ekin(i),i=1,iba(ik))
       write(nfout,'(" p    : ",5d16.8)') (p(i),i=1,iba(ik))
    end if

    if(kimg == 1) then
       do i = 1, iba(ik)
          i1    = igf(nbase(i,ik))
          evr   = zaj_l(i,ib,ik,1)
          devr  = (ekin(i)-eko_l(ib,ik))*evr&
               & + VlocalW(i1)*denom + vnlph_l(i,ib,1)
          wdi   = ekin(i) + vlhxc0 + vnldi(i) - eko_l(ib,ik)
          fdexp = dexp( -p(i) * wdi * dtim)
          zaj_l(i,ib,ik,1) = (fdexp - 1)*devr/wdi + evr
       end do
    else if(kimg == 2) then
       do i = 1, iba(ik)
          i1    = igf(nbase(i,ik))
          evr   = zaj_l(i,ib,ik,1);    evi   = zaj_l(i,ib,ik,2)
          e1    = ekin(i) - eko_l(ib,ik)
          devr  = e1*evr+VlocalW(2*i1-1)*denom+vnlph_l(i,ib,1)
          devi  = e1*evi+VlocalW(2*i1  )*denom+vnlph_l(i,ib,2)
          wdi   = ekin(i) + vlhxc0 + vnldi(i) - eko_l(ib,ik)
          fdexp = dexp( -p(i) * wdi * dtim)
          zaj_l(i,ib,ik,1) = (fdexp - 1)*devr/wdi + evr
          zaj_l(i,ib,ik,2) = (fdexp - 1)*devi/wdi + evi
       end do
    end if
!!$    call tstatc0_end(id_sname)
  end subroutine modified_steepest_descent
!$$#endif

!$$#ifndef PARA3D
  subroutine steepest_descent(precon,ik,ibo,dtim,ekin,VlocalW,p)
    integer      , intent(in)                  :: precon,ik,ibo
    real(kind=DP), intent(in)                  :: dtim
    real(kind=DP), intent(in), dimension(kg1)  :: ekin
    real(kind=DP), intent(in), dimension(nfft) :: VlocalW
    real(kind=DP)            , dimension(kg1)  :: p

    integer       :: i, i1, ib
    real(kind=DP) :: evr,devr,denom, evi,e1, devi

    ib = map_z(ibo)                            ! MPI
    denom = 1.d0/product(fft_box_size_WF(1:3,1))
    call m_ES_decide_precon_factor(precon,ik,ibo,ekin,p)  ! -> p(1:iba(ik))

    if(kimg == 1) then
       do i = 1, iba(ik)
          i1    = igf(nbase(i,ik))
          evr   = zaj_l(i,ib,ik,1)
          devr  = (ekin(i)-eko_l(ib,ik))*evr + VlocalW(i1)*denom + vnlph_l(i,ib,1)
          zaj_l(i,ib,ik,1) = evr - p(i)*dtim*devr
       end do
    else if(kimg == 2) then
       do i = 1, iba(ik)
          i1    = igf(nbase(i,ik))
          evr   = zaj_l(i,ib,ik,1);    evi   = zaj_l(i,ib,ik,2)
          e1    = ekin(i) - eko_l(ib,ik)
          devr  = e1*evr+VlocalW(2*i1-1)*denom+vnlph_l(i,ib,1)
          devi  = e1*evi+VlocalW(2*i1  )*denom+vnlph_l(i,ib,2)
          zaj_l(i,ib,ik,1) = evr - p(i)*dtim*devr
          zaj_l(i,ib,ik,2) = evi - p(i)*dtim*devi
       end do
    end if
  end subroutine steepest_descent
!$$#endif

  subroutine square_of_SD_direction(ik,ibo,dz)
    integer,       intent(in)       :: ik,ibo
    real(kind=DP), intent(out)      :: dz  ! dz = <wfsd|w|wfsd>
    integer                         :: i,ib

    dz = 0.d0
    if(modnrm == EXECUT) then
       call m_ES_sum_of_LocalPart(ik,ibo,bsdr_l,bsdi_l,dz)
    end if
    ib = map_z(ibo)                     ! MPI
    if(k_symmetry(ik) == GAMMA) then
       if(kimg == 1) then
          dz = dz + wfsd_l(1,ib,ik,1)*wfsd_l(1,ib,ik,1)
          do i = 2, iba(ik)
             dz = dz + 2.d0*wfsd_l(i,ib,ik,1)*wfsd_l(i,ib,ik,1)
          end do
       else
          dz = dz + wfsd_l(1,ib,ik,1)**2 + wfsd_l(1,ib,ik,2)**2
          do i = 2, iba(ik)
             dz = dz + 2.d0*(wfsd_l(i,ib,ik,1)**2 + wfsd_l(i,ib,ik,2)**2)
          end do
       end if
    else
       if(kimg == 1) then
          do i = 1, iba(ik)
             dz = dz + wfsd_l(i,ib,ik,1)*wfsd_l(i,ib,ik,1)
          end do
       else
          do i = 1, iba(ik)
             dz = dz + wfsd_l(i,ib,ik,1)**2 + wfsd_l(i,ib,ik,2)**2
          end do
       end if
    end if
  end subroutine square_of_SD_direction


  subroutine square_of_SD_direction2(ik,ibo,dz)
    integer,       intent(in)       :: ik,ibo
    real(kind=DP), intent(out)      :: dz  ! dz = <wfsd|w|wfsd>
    integer                         :: i,ib

    ib = map_z(ibo)                     ! MPI
    dz = 0.d0
    if(modnrm == EXECUT) then
       call m_ES_sum_of_LocalPart2(ik,ibo,bsdr_l,bsdi_l,bsdr_np,bsdi_np,dz)
    end if
    if(k_symmetry(ik) == GAMMA) then
       if(kimg == 1) then
          dz = dz + wfsd_l(1,ib,ik,1)*wfsd_np(1,ib,ik,1)
          do i = 2, iba(ik)
             dz = dz + 2.d0*wfsd_l(i,ib,ik,1)*wfsd_np(i,ib,ik,1)
          end do
       else
          dz = dz + wfsd_l(1,ib,ik,1)*wfsd_np(1,ib,ik,1)
          do i = 2, iba(ik)
             dz = dz + 2.d0*( wfsd_l(i,ib,ik,1)*wfsd_np(i,ib,ik,1) &
                  &         + wfsd_l(i,ib,ik,2)*wfsd_np(i,ib,ik,2))
          end do
       end if
    else
       if(kimg == 1) then
          do i = 1, iba(ik)
             dz = dz + wfsd_l(i,ib,ik,1)*wfsd_np(i,ib,ik,1)
          end do
       else
          do i = 1, iba(ik)
             dz = dz + wfsd_l(i,ib,ik,1)*wfsd_np(i,ib,ik,1) &
                  &  + wfsd_l(i,ib,ik,2)*wfsd_np(i,ib,ik,2)
          end do
       end if
    end if
  end subroutine square_of_SD_direction2

!$$#ifndef PARA3D
  subroutine SD_direction(precon,ik,ibo,ekin,VlocalW,p)
    integer      , intent(in)                  :: precon,ik,ibo
    real(kind=DP), intent(in), dimension(kg1)  :: ekin
    real(kind=DP), intent(in), dimension(nfft) :: VlocalW
    real(kind=DP)            , dimension(kg1)  :: p

    integer       :: i, i1, ib
    real(kind=DP) :: devr,denom, e1, devi

    ib = map_z(ibo)                                  ! MPI
    denom = 1.d0/product(fft_box_size_WF(1:3,1))
    call m_ES_decide_precon_factor(precon,ik,ibo,ekin,p)  ! -> p(1:iba(ik))

    if(kimg == 1) then
       do i = 1, iba(ik)
          i1    = igf(nbase(i,ik))
          devr  = (ekin(i)-eko_l(ib,ik))*zaj_l(i,ib,ik,1)&
               & + VlocalW(i1)*denom + vnlph_l(i,ib,1)
          wfsd_l(i,ib,ik,1) = - p(i)*devr
       end do
    else if(kimg == 2) then
       do i = 1, iba(ik)
          i1    = igf(nbase(i,ik))
          e1    = ekin(i) - eko_l(ib,ik)
          devr  = e1*zaj_l(i,ib,ik,1) + VlocalW(2*i1-1)*denom+vnlph_l(i,ib,1)
          devi  = e1*zaj_l(i,ib,ik,2) + VlocalW(2*i1  )*denom+vnlph_l(i,ib,2)
          wfsd_l(i,ib,ik,1) = - p(i)*devr
          wfsd_l(i,ib,ik,2) = - p(i)*devi
       end do
    end if
  end subroutine SD_direction
!$$#endif

!$$#ifndef PARA3D
  subroutine Vnonlocal_Diagonal_part(ispin,ik,iksnl,ibo,vnldi)
    integer, intent(in)                        :: ispin, ik, iksnl,ibo
    real(kind=DP), intent(out), dimension(kg1) :: vnldi

    integer :: it,mdvdb,ib

!!$    integer :: id_sname = -1
!!$    call tstatc0_begin('Vnonlocal_Diagonal_part ', id_sname)

    ib = map_z(ibo)                ! MPI
    vnldi = 0.d0
    do it = 1, ntyp
       mdvdb = m_PP_include_vanderbilt_pot(it)
       if(mdvdb == SKIP) then
          call Vnonlocal_D_norm_conserve_case
       else if(mdvdb == EXECUT) then
          call Vnonlocal_D_vanderbilt_case
       end if
    end do

!!$    call tstatc0_end(id_sname)
  contains
    subroutine Vnonlocal_D_vanderbilt_case
      integer       :: ia, p1,p2,lmtt1,il1,lmtt2,il2,i
      real(kind=DP) :: ph,fac, dion_eq

      do p1 = 1, ilmt(it)
         lmtt1 = lmtt(p1,it); il1 = ltp(p1,it)
         do p2 = p1, ilmt(it)
            lmtt2 = lmtt(p2,it); il2 = ltp(p2,it)
            if( p1 /= p2) then
               ph = 2.d0*real(zi**(il2-il1))
            else
               ph = 1.d0
            endif
            if(mod(il1+il2,2) == 1) cycle
            dion_eq = dion(p1,p2,it)-eko_l(ib,ik)*q(p1,p2,it)
            fac = 0.d0
            do ia = 1, natm
               if(ityp(ia) /= it) cycle
!!$               fac = fac + ph*iwei(ia) * (dion_eq+vlhxcQ(p1,p2,ia,ispin))
               if(ipaw(it)==0) then
                   fac = fac + ph*iwei(ia) * (dion_eq+vlhxcQ(p1,p2,ia,ispin))
               else
                   fac = ph*iwei(ia) * &
                        & (dion_paw(p1,p2,ispin,ia)-eko_l(ib,ik)*q(p1,p2,it)+vlhxcQ(p1,p2,ia,ispin))
               end if
            end do

            do i = 1, iba(ik)
               vnldi(i) = vnldi(i)+fac*snl(i,lmtt1,iksnl)*snl(i,lmtt2,iksnl)
            end do
         end do
      end do

!!$      do p1 = 1, ilmt(it)
!!$         lmtt1 = lmtt(p1,it); il1 = ltp(p1,it)
!!$         do p2 = p1, ilmt(it)
!!$            lmtt2 = lmtt(p2,it); il2 = ltp(p2,it)
!!$            if( p1 /= p2) then
!!$               ph = 2.d0*real(zi**(il2-il1))
!!$            else
!!$               ph = 1.d0
!!$            endif
!!$            if(mod(il1+il2,2) == 1) cycle
!!$            dion_eq = dion(p1,p2,it)-eko_l(ib,ik)*q(p1,p2,it)
!!$            do ia = 1, natm
!!$               if(ityp(ia) /= it) cycle
!!$!!$               fac = ph*iwei(ia) * &
!!$!!$                    & (dion(p1,p2,it)-eko_l(ib,ik)*q(p1,p2,it)+vlhxcQ(p1,p2,ia,ispin))
!!$               fac = ph*iwei(ia) * (dion_eq+vlhxcQ(p1,p2,ia,ispin))
!!$               do i = 1, iba(ik)
!!$                  vnldi(i) = vnldi(i)+fac*snl(i,lmtt1,iksnl)*snl(i,lmtt2,iksnl)
!!$               end do
!!$            end do
!!$         end do
!!$      end do
    end subroutine Vnonlocal_D_vanderbilt_case

    subroutine Vnonlocal_D_norm_conserve_case
      integer       :: ia, lmt1,lmt2,lmtt1,il1,im1,il2,im2,i
      real(kind=DP) :: ph,fac

      ph = 0.d0
      do ia = 1, natm
         if(ityp(ia) /= it) cycle
         ph = ph + iwei(ia)
      end do
      do lmt1 = 1, ilmt(it)
         lmtt1 = lmtt(lmt1,it); il1 = ltp(lmt1,it); im1 = mtp(lmt1,it)
         do lmt2 = lmt1, ilmt(it)
            il2 = ltp(lmt2,it); im2 = mtp(lmt2,it)
            if(il1 /= il2 .or. im1 /= im2) cycle
            if(mod(il1+il2,2) == 1) cycle
            fac = ph * dion(lmt1,lmt2,it)
            do i = 1, iba(ik)
               vnldi(i)  = vnldi(i) + fac * snl(i,lmtt1,iksnl)**2
            end do
         end do
      end do
    end subroutine Vnonlocal_D_norm_conserve_case
  end subroutine Vnonlocal_Diagonal_part
!$$#endif

  subroutine m_ESsd_reset_dzajn2
    dzajn2 = 0.d0
  end subroutine m_ESsd_reset_dzajn2

!$$#ifndef PARA3D
  subroutine m_ESsd_copy_zaj_to_zaj_old
    integer :: ik, ir
    do ir = 1, kimg
       do ik = 1, kv3, af+1
          if(map_k(ik) /= myrank_k) cycle                       ! MPI
          zaj_old(:,:,ik,ir) = zaj_l(:,:,ik,ir)
       end do
    end do
  end subroutine m_ESsd_copy_zaj_to_zaj_old
!$$#endif

!$$#ifndef PARA3D
  subroutine m_ESsd_copy_zaj_old_to_zaj(ik,ibo)
    integer, intent(in)                           :: ik, ibo

    integer    :: ir, ib

    ib = map_z(ibo)
     do ir = 1, kimg
       zaj_l(:,ib,ik,ir) = zaj_old(:,ib,ik,ir)
    end do
  end subroutine m_ESsd_copy_zaj_old_to_zaj
!$$#endif

!$$#ifndef PARA3D
  subroutine m_ESsd_copy_phi_to_zaj_old(ik,ibo,phi)
    integer, intent(in)                           :: ik, ibo
    real(kind=DP),intent(in),dimension(kg1,kimg)  :: phi

    integer    :: ir, ib

    ib = map_z(ibo)
     do ir = 1, kimg
       zaj_old(:,ib,ik,ir) = phi(:,ir)
    end do
  end subroutine m_ESsd_copy_phi_to_zaj_old
!$$#endif

  subroutine m_ESsd_diff_WFs_to_zaj_old(dt)
    real(kind=DP), intent(in) :: dt
    integer                   :: ik, ir
    real(kind=DP), parameter  :: Delta = 1.d-10
    real(kind=DP)             :: rdt

    if(dt < Delta ) then
       if(ipri >=1 ) write(nfout,'(" !! dt is smaller than ",d20.8)') Delta
       rdt = 0.d0
    else
       rdt = 1.d0/dt
    end if

    do ir = 1, kimg
       do ik = 1, kv3, af+1
          if(map_k(ik) /= myrank_k) cycle                ! MPI
          zaj_old(:,:,ik,ir) = rdt * (zaj_l(:,:,ik,ir) - zaj_old(:,:,ik,ir))
       end do
    end do
  end subroutine m_ESsd_diff_WFs_to_zaj_old

!$$#ifndef PARA3D
  subroutine WF_conjugate_gradient(ik,ibo,dtim)
! \Psi_{k\mu}^{m+1} = \Psi_{k\mu}^{m} + \Delta t_{opt}^{m} d^{m}
!   d^{m} = g^{m} + \beta_CG d^{m-1}
!   g^{m} = - \Phi_{k\mu}^{m}
!   d^{m-1} = (\Psi_{k\mu}^{m} - \Psi_{k\mu}^{m-1})\frac{1}{\Delta t_{opt}^{m-1}}
!
    integer      , intent(in)                  :: ik,ibo
    real(kind=DP), intent(in)                  :: dtim

    integer       :: i,ib
    real(kind=DP) :: evr,evi

    ib = map_z(ibo)                    ! MPI
    if(kimg == 1) then
       do i = 1, iba(ik)
          evr   = zaj_l(i,ib,ik,1)
          zaj_l(i,ib,ik,1) = evr + dtim*wfsd_l(i,ib,ik,1)
       end do
    else if(kimg == 2) then
       do i = 1, iba(ik)
          evr   = zaj_l(i,ib,ik,1);  evi   = zaj_l(i,ib,ik,kimg)
          zaj_l(i,ib,ik,1) = evr + dtim*wfsd_l(i,ib,ik,1)
          zaj_l(i,ib,ik,2) = evi + dtim*wfsd_l(i,ib,ik,2)
       end do
    end if
  end subroutine WF_conjugate_gradient
!$$#endif

!$$#ifndef PARA3D
  subroutine WF_conjugate_gradient0 &
       &(precon,ik,ibo,dtim,ekin,VlocalW,p)
! \Psi_{k\mu}^{m+1} = \Psi_{k\mu}^{m} + \Delta t_{opt}^{m} d^{m}
!   d^{m} = g^{m} + \beta_CG d^{m-1}
!   g^{m} = - \Phi_{k\mu}^{m}
!   d^{m-1} = (\Psi_{k\mu}^{m} - \Psi_{k\mu}^{m-1})\frac{1}{\Delta t_{opt}^{m-1}}
!
    integer      , intent(in)                  :: precon,ik,ibo
    real(kind=DP), intent(in)                  :: dtim
    real(kind=DP), intent(in), dimension(kg1)  :: ekin
    real(kind=DP), intent(in), dimension(nfft) :: VlocalW
    real(kind=DP)            , dimension(kg1)  :: p

    integer       :: i, i1, ib
    real(kind=DP) :: evr,devr,denom, evi,e1, devi

    ib = map_z(ibo)
    denom = 1.d0/product(fft_box_size_WF(1:3,1))
    call m_ES_decide_precon_factor(precon,ik,ibo,ekin,p)  ! ->p(1:iba(ik))

    if(kimg == 1) then
       do i = 1, iba(ik)
          i1    = igf(nbase(i,ik))
          evr   = zaj_l(i,ib,ik,1)
          devr  = (ekin(i)-eko_l(ib,ik))*evr&
               & + VlocalW(i1)*denom + vnlph_l(i,ib,1)
          zaj_l(i,ib,ik,1) = evr + dtim*(-p(i)*devr+betacg*zaj_old(i,ib,ik,1))
          zaj_old(i,ib,ik,1) = evr
       end do
    else if(kimg == 2) then
       do i = 1, iba(ik)
          i1    = igf(nbase(i,ik))
          evr   = zaj_l(i,ib,ik,1)
          evi   = zaj_l(i,ib,ik,kimg)
          e1    = ekin(i) - eko_l(ib,ik)
          devr  = e1*evr+VlocalW(2*i1-1)*denom+vnlph_l(i,ib,1)
          devi  = e1*evi+VlocalW(2*i1  )*denom+vnlph_l(i,ib,2)
          zaj_l(i,ib,ik,1) = evr +dtim*(-p(i)*devr+betacg*zaj_old(i,ib,ik,1))
          zaj_l(i,ib,ik,2) = evi +dtim*(-p(i)*devi+betacg*zaj_old(i,ib,ik,2))
          zaj_old(i,ib,ik,1) = evr; zaj_old(i,ib,ik,2) = evi
       end do
    end if
  end subroutine WF_conjugate_gradient0
!$$#endif

!$$#ifndef PARA3D
  subroutine make_CG_direction(ik)
    integer, intent(in) :: ik

    real(kind=DP), parameter             :: Delta = 1.d-20
    integer :: i, ib
    integer :: id_sname = -1
    call tstatc0_begin('make_CG_direction', id_sname)

    if(betacg > Delta) then
       if(kimg == 1) then
          do ib = 1, np_e
             do i = 1, iba(ik)
                wfsd_l(i,ib,ik,1) = wfsd_l(i,ib,ik,1) + betacg*wfsd_old(i,ib,ik,1)
             end do
          end do
       else
          do ib = 1, np_e
             do i = 1, iba(ik)
                wfsd_l(i,ib,ik,1) = wfsd_l(i,ib,ik,1) + betacg*wfsd_old(i,ib,ik,1)
                wfsd_l(i,ib,ik,2) = wfsd_l(i,ib,ik,2) + betacg*wfsd_old(i,ib,ik,2)
             end do
          end do
       end if
    end if
    call tstatc0_end(id_sname)
  end subroutine make_CG_direction
!$$#endif

!$$#ifndef PARA3D
  subroutine orthogonalize_SD_drctns(ik,to)
    integer, intent(in) :: ik,to

    integer :: id_sname = -1
    call tstatc0_begin('orthogonalize_SD_drctns ', id_sname)

!!$    if(modnrm == EXECUT) call m_ES_betar_dot_Psi_4_each_k(wfsd_l,ista_k,iend_k,ik,bsdr_l,bsdi_l)
    if(modnrm == EXECUT) call m_ES_betar_dot_Psi_4_each_k(wfsd_l,ik,ik,ik,bsdr_l,bsdi_l)
    !                                                          ->bsd(ri)_l
    call m_ES_orthogonalize_SD_to_WFs(ik,to,wfsd_l,bsdr_l,bsdi_l) ! ->(wfsd_l,bsd(ri)_l)

!!$    call orthogonalize_SD(ik,wfsd_l,bsdr_l,bsdi_l)           !-(m_E.S.) ->(wfsd_l)
    call tstatc0_end(id_sname)
  end subroutine orthogonalize_SD_drctns
!$$#endif

  subroutine Precon_dot_SD(ik,ekin,p)
    integer,      intent(in)                 :: ik
    real(kind=DP),intent(in),dimension(kg1)  :: ekin
    real(kind=DP),           dimension(kg1)  :: p

    integer :: ib, ri, i

    do ri = 1, kimg
       do ib = ista_e, iend_e, istep_e
          do i = 1, iba(ik)
             wfsd_np(i,map_z(ib),ik,ri) = wfsd_l(i,map_z(ib),ik,ri)
          end do
       end do
    end do

    do ib = ista_e, iend_e, istep_e   ! MPI
       call decide_precon_factor_wfsd(ik,ib,ekin,p)
       if(kimg == 1) then
          do i = 1, iba(ik)
             wfsd_l(i,map_z(ib),ik,1) = p(i)*wfsd_l(i,map_z(ib),ik,1)
          end do
       else if(kimg == 2) then
          do i = 1, iba(ik)
             wfsd_l(i,map_z(ib),ik,1) = p(i)*wfsd_l(i,map_z(ib),ik,1)
             wfsd_l(i,map_z(ib),ik,2) = p(i)*wfsd_l(i,map_z(ib),ik,2)
          end do
       end if
    end do

  end subroutine Precon_dot_SD

  subroutine decide_precon_factor_wfsd(ik,ib,ekin,p)
    integer, intent(in)                         :: ik,ib
    real(kind=DP), intent(in),  dimension(kg1)  :: ekin
    real(kind=DP), intent(out), dimension(kg1)  :: p

    integer       :: i
    real(kind=DP) :: ektot, x, x1, x2, d_ektot

    call kinetic_energy_wfsd(ik,ib,ekin,ektot)   ! -(m_ES_WF_by_SDorCG)
    d_ektot = 1.d0/ektot
    p = 0.d0
    do i = 1, iba(ik)
       x = ekin(i)*d_ektot
       x1 = 27 + ( 18 + (12 + 8*x) *x) *x
       x2 = 16*(x*x)*(x*x)
       p(i)  = x1/(x1 + x2 )
    end do
  end subroutine decide_precon_factor_wfsd

  subroutine kinetic_energy_wfsd(ik,ib,dekin,ektot)
    integer, intent(in) :: ik, ib
    real(kind=DP), intent(in), dimension(kg1)  :: dekin
    real(kind=DP), intent(out)                 :: ektot
    integer  :: i, ri
    ektot = 0.d0

    do ri = 1, kimg
       do i = 1, iba(ik)
          ektot = ektot + dekin(i)*wfsd_l(i,map_z(ib),ik,ri)**2   ! MPI
       end do
    end do

    if(k_symmetry(ik) == GAMMA) ektot = ektot*2.d0

  end subroutine kinetic_energy_wfsd

!$$#ifndef PARA3D
  subroutine cp_wfsd_to_wfsd_old(ik)
    integer, intent(in) :: ik
    wfsd_old(:,:,ik,:) = wfsd_l(:,:,ik,:)
  end subroutine cp_wfsd_to_wfsd_old
!$$#endif

  subroutine m_ESsd_dealloc
    if(allocated(zaj_old)) deallocate(zaj_old)
    if(allocated(dzajn2)) deallocate(dzajn2)


  end subroutine m_ESsd_dealloc


end module m_ES_WF_by_SDorCG
